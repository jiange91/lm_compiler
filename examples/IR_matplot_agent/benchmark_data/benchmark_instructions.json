[
    {
        "simple_instruction": "Generate a series of boxplots using matplotlib and numpy libraries. The boxplots should include a basic plot, a notched plot, a plot with changed outlier point symbols, a plot without outlier points, a horizontal boxplot, and a plot with changed whisker length. The data for these plots should be randomly generated and reproducible. Each subplot should have one boxplot. The plots should be arranged in two rows and three columns.",
        "expert_instruction": "1. Import the required libraries: matplotlib.pyplot and numpy.\n2. Import the Polygon module from matplotlib.patches.\n3. Set the random seed for reproducibility using np.random.seed(19920215).\n4. Generate new fake data for the plot by creating arrays: spread, center, flier_high, flier_low, and data.\n   - Generate the spread array by multiplying np.random.rand(50) by 100.\n   - Generate the center array by multiplying np.ones(25) by 60.\n   - Generate the flier_high array by adding np.random.rand(10) multiplied by 100 to 150.\n   - Generate the flier_low array by multiplying np.random.rand(10) by -100.\n   - Concatenate the spread, center, flier_high, and flier_low arrays into the data array.\n5. Create a figure and subplots.\n6. Plot the basic boxplot on the first subplot and set the title to 'basic plot'.\n7. Plot a notched boxplot on the second subplot and set the title to 'notched plot'.\n8. Change the outlier point symbols on the third subplot and set the title to 'change outlier point symbols'.\n9. Create a boxplot without showing the outlier points on the fourth subplot and set the title to \"don't show outlier points\".\n10. Create a horizontal boxplot on the fifth subplot and set the title to 'horizontal boxes'.\n11. Change the whisker length on the sixth subplot and set the title to 'change whisker length'.\n12. Adjust the spacing and layout of the subplots using.\n13. Display the plot.",
        "id": 1
    },
    {
        "simple_instruction": "Create a 3x3 grid of subplots using matplotlib, with shared x-axis for each column and y-axis for each row. Ensure there is no spacing between all the subplots. The overall title of the figure should be 'Sharing x per column, y per row'. The subplots should contain the following plots:\n\n1. `z` against `w`.\n2. `z**3` against `w` in blue.\n3. `-z` against `w + 1` in yellow.\n4. `-z**3` against `w + 2` in purple.\n5. `z**2` against `w**2` in brown.\n6. `-z**2` against `w**2 + 1` in pink.\n7. `z**2` against `-w**2 + 2` in grey.\n8. `-z**2` against `-w**2 + 3` in black.\n9. `z` against `-w` in white.\n\nOnly the outermost subplots should be labeled.",
        "expert_instruction": "1. Begin by creating a new visual representation using matplotlib's function that generates a new figure.\n2. Add a 3x3 grid to the figure using the function that allows you to add a grid specification, with no horizontal or vertical space between the plots.\n3. Create nine subplots within this grid, sharing the x-axis for each column and the y-axis for each row. Assign these subplots to nine variables: `ax1`, `ax2`, `ax3`, `ax4`, `ax5`, `ax6`, `ax7`, `ax8`, and `ax9`.\n4. Set the overall title of the figure to 'Sharing x per column, y per row' using the function that sets a super title.\n5. Plot `z` against `w` on the first subplot (`ax1`).\n6. Plot `z**3` against `w` on the second subplot (`ax2`), and use the color blue for the plot.\n7. Plot `-z` against `w + 1` on the third subplot (`ax3`), and use the color yellow for the plot.\n8. Plot `-z**3` against `w + 2` on the fourth subplot (`ax4`), and use the color purple for the plot.\n9. Plot `z**2` against `w**2` on the fifth subplot (`ax5`), and use the color brown for the plot.\n10. Plot `-z**2` against `w**2 + 1` on the sixth subplot (`ax6`), and use the color pink for the plot.\n11. Plot `z**2` against `-w**2 + 2` on the seventh subplot (`ax7`), and use the color grey for the plot.\n12. Plot `-z**2` against `-w**2 + 3` on the eighth subplot (`ax8`), and use the color black for the plot.\n13. Plot `z` against `-w` on the ninth subplot (`ax9`), and use the color white for the plot.\n14. Finally, loop through all the axes in the figure using the function that retrieves all axes, and call the function on each axis to only label the outermost subplots.\n\"\"\"",
        "id": 2
    },
    {
        "simple_instruction": "Create a Python script that uses mathematical and data visualization libraries to produce a violin plot. The plot should consist of two subplots sharing the y-axis, with the first subplot displaying a default violin plot and the second subplot showing a customized violin plot with no means, medians, or extrema. The bodies of the violins in the second subplot should be blue with black edges and an opacity alpha of 0.5. The data for the plot should be generated from a normal distribution with a seed of 12345678 for reproducibility, and should consist of five arrays of 150 sorted random numbers each, with standard deviations ranging from 2 to 6. The first quartile, median, and third quartile of the data should be calculated and the whiskers should be plotted using these values. The medians should be plotted as red dots on the first subplot, with vertical lines at the locations of the quartiles and whiskers. The x-axis labels for both subplots should be 'E', 'F', 'G', 'H', and 'I'. Adjust the bottom and wspace of the subplots for better visualization.",
        "expert_instruction": "Create a Python script that utilizes two libraries, one for mathematical functions and another for data visualization, to produce a violin plot. Start by importing the necessary libraries and defining two functions. The first function should calculate the upper and lower adjacent values, then return them. The second function should take two parameters, one for the axis and another for the labels, then set the x-ticks and x-label of the given axis.\n\nNext, generate some test data of random numbers from a normal distribution. Set a seed of 12345678 for reproducibility. The data should consist of five arrays of 150 sorted random numbers each, with standard deviations ranging from 2 to 6.\n\nCreate a figure with two subplots that share the y-axis. The first subplot should have the title 'Default violin plot' and the y-label 'Observed values'. It should display a default violin plot of the data. The second subplot should have the title 'Customized violin plot'. It should display a customized violin plot of the data, with no means, medians, or extrema shown. The bodies of the violins should be blue with black edges and an opacity alpha of 0.5.\n\nCalculate the first quartile, median, and third quartile of the data along the first axis. Calculate the whiskers using the first function you defined. Plot the medians as red dots on the first subplot. Add vertical lines at the locations of the quartiles and whiskers.\n\nFinally, set the x-axis style for both subplots using the second function you defined with labels 'E', 'F', 'G', 'H', and 'I'. Adjust the bottom and wspace of the subplots and display the plot.",
        "id": 3
    },
    {
        "simple_instruction": "\nCreate a matplotlib plot with the following characteristics:\n\nThe plot should be a 6x6 in figsize.\nIt should include a scatter plot of a correlated dataset with 700 data points, generated based on specific parameters ([0.6, 0.85] and [-0.3, 0.25] for correlations, and (1, 1) and (7, 6) for data point distribution).\nAdd vertical and horizontal lines in grey color through the dataset.\nOverlay three confidence ellipses on the scatter plot, each representing a different standard deviation (1, 2, and 3). The first ellipse should be in 'firebrick' color, the second in 'fuchsia' with a dashed line, and the third in 'blue' with a dotted line. Label these ellipses with '$1\\sigma$', '$2\\sigma$', and '$3\\sigma$' respectively.\nHighlight a specific point defined by the tuple (1, 1) on the plot with a red marker.\nThe title of the plot should be 'Different standard deviations'.\nInclude a legend for the plot.\nDisplay the final plot.",
        "expert_instruction": "Create a matplotlib plot that shows three confidence ellipses with different standard deviation, each wrapping a certain portion of scatter points:\n\n1. Begin by generating a subplot with a figure size of 6 by 6.\n2. Define a list, let's name it 'dependency_var', with two sublists: [0.6, 0.85] and [-0.3, 0.25].\n3. Define a tuple 'mu_var' with two elements: 1 and 1.\n4. Define another tuple 'scale_var' with two elements: 7 and 6.\n5. Draw a vertical and a horizontal line through the center of the plot with color 'grey' and line width 1.\n6. Generate a correlated dataset with 700 data points using the function that generates correlated dataset with 'dependency_var', 'mu_var', and 'scale_var' as arguments. Assign the output to two variables, let's call them 'x_var' and 'y_var'.\n7. Plot a scatter plot on 'ax_var' using 'x_var' and 'y_var' with a size of 0.5.\n8. Create three confidence ellipses on 'ax_var' using 'x_var' and 'y_var'. The first ellipse should have a standard deviation of 1, label '$1\\sigma$', and edge color 'firebrick'. The second ellipse should have a standard deviation of 2, label '$2\\sigma$', edge color 'fuchsia', and a dashed linestyle. The third ellipse should have a standard deviation of 3, label '$3\\sigma$', edge color 'blue', and a dotted linestyle.\n9. Plot a scatter point on the center with color 'red' and size 3.\n10. Set the title of 'ax_var' to 'Different standard deviations'.\n11. Add a legend to 'ax_var'.\n12. Finally, display the plot.",
        "id": 4
    },
    {
        "simple_instruction": "Create a plot consisting of a side-by-side pie chart and stacked bar chart with the following details:\n\nThe pie chart represents the distribution of fruits in a basket, with the proportions being 35% apples (with this slice separated from the others), 45% oranges, and 20% bananas.\nThe stacked bar chart shows the distribution of people favoring apples among different age groups: 25% under 18, 40% for ages 18-30, 20% for ages 30-50, and 15% for over 50.\nConnect the separated pie chart slice to the top and bottom of the stacked bar chart with lines, indicating the correspondence between the fruit types and their distribution among the age groups. These lines should be black in color and 1 in linewidth.\nEnsure the plot includes necessary adjustments for clarity and aesthetics, such as spacing between subplots, the orientation of the pie chart, labeling of the bar chart, titles for each subplot, a legend for clarity, and appropriate axis settings.\nDisplay the final plot.",
        "expert_instruction": "Compose a Python script that uses necessary libraries to generate a side-by-side pie chart and stacked bar chart. The stacked bar chart shows the composition of a specific slice of the pie chart. Start by importing the required libraries and creating a figure with two subplots. Adjust the space between the subplots.\n\nFor the pie chart, define the proportions, labels, and explode parameters. Rotate the chart so that the first segment is split by the x-axis. Create the pie chart on the first subplot, using the defined parameters.\n\nThe pie chart should represent the distribution of different types of fruits in a basket. The proportions could be 35% for apples, 45% for oranges, and 20% for bananas. The labels should correspond to these fruit types and the explode parameter should be set to separate the apple slice from the rest.\n\nFor the bar chart, define the proportions and labels. Create a loop to add bars to the existing bars from the top to stack them up. The legend should match the order of bars stacked. Set the title of the chart, add a legend, turn off the axis, and set the x-axis limit.\n\nThe bar chart should represent the distribution of these fruits among different age groups. The proportions shoud be 25% for under 18, 40% for 18-30, 20% for 30-50, and 15% for over 50. The labels should correspond to these age groups.\n\nUse a function from the imported libraries to draw connecting lines between the separated slice and the stacked bar chart. Calculate the coordinates for the top and bottom connecting lines based on the parameters of the pie chart and the height of the bar chart. Add the connecting lines to the second subplot and set their color and linewidth.\n\nFinally, display the plot.",
        "id": 5
    },
    {
        "simple_instruction": "Generate a nested pie plot using a bar plot method in polar coordinates. The plot should be based on a numerical array `data` with values [[80., 20.], [50., 50.], [40., 60.]]. Normalize this data to 2 pi. Use a colormap that provides a range of 20 colors to create two color arrays. Create two pie plots that are nested together with a blank center that is not filled in, the two rings should have the same thickness. The rings should have a white edge with line width of 1 to clearly delineate each segment, and they should be aligned at the edge of each bar segment for visual consistency. The outer pie plot should use the sum of the normalized data for the width and the inner pie plot should use the flattened normalized data for the width. Use outer_colors = cmap(np.arange(3)*4), inner_colors = cmap([1, 2, 5, 6, 9, 10]) to paint the nested pie chart. The title of the plot should be 'Pie plot with bar method and polar coordinates'. The axis should be turned off.",
        "expert_instruction": "Create a nested pie plot that utilizes the creation of bar plots in polar coordinates. Start by creating a subplot with a polar projection.\n\nNext, define a variable `thickness` with a value of 0.2 and a numerical array `data` with the values [[80., 20.], [50., 50.], [40., 60.]]. Normalize `data` to 2 pi and store it in `data_norm`. Then, calculate the ordinates of the bar edges and store them in `data_left`.\n\nDefine a colormap using a colormap from the data visualization library that provides a range of 20 colors and assign it to the variable `color_map`. Create two color arrays, `outer_colors` and `inner_colors`, using different ranges from the colormap.\n\nThen, create two bar plots using the method that allows for the creation of bar plots. The first bar plot should use the first column of `data_left` for the x-values, the sum of `data_norm` along axis 1 for the width, 1-thickness for the bottom, thickness for the height, `outer_colors` for the color, 'w' for the edgecolor, 1 for the linewidth, and align the edges. The second bar plot should use the flattened `data_left` for the x-values, the flattened `data_norm` for the width, 1-2*thickness for the bottom, thickness for the height, `inner_colors` for the color, 'w' for the edgecolor, 1 for the linewidth, and align the edges. The second bar plot should be wrapping the first one.\n\nFinally, set the title of the plot to \"Pie plot with bar method and polar coordinates\", turn off the axis, and display the plot.",
        "id": 6
    },
    {
        "simple_instruction": "Generate a Python script that creates a polar bar plot using a fixed seed for random number generation to ensure reproducibility. The plot should have 30 bars, with their positions, diameters, and thicknesses determined by linearly spaced and random values respectively. The colors of the bars should range from dark to light based on the normalized diameters. The transparency of the bars should be set to 0.5.",
        "expert_instruction": "1. Import the necessary modules for plotting and numerical operations.\n2. Set a fixed state for random number generation to ensure the results are reproducible. Use the seed value 12345678.\n3. Compute the slices for a pie chart by first defining a variable, let's call it M, with a value of 30.\n4. Create a variable, let's name it alpha, that is a linearly spaced array from 0.0 to 2 times a certain mathematical constant that represents the ratio of the circumference of a circle to its diameter, with M number of samples and without including the endpoint.\n5. Create a variable, let's call it diameters, that is an array of M random numbers, each multiplied by 20.\n6. Create a variable, let's name it thickness, that is an array of M random numbers, each multiplied by the aforementioned mathematical constant divided by 3.\n7. Create a variable, let's call it hues, that uses a color map from the plotting module to map the normalized diameters values to colors. Use a color map that provides a range of colors from dark to light.\n8. Create a subplot with polar projection and store it in a variable, let's call it chart.\n9. Use a method of chart to create a bar plot with alpha as the x values, diameters as the y values, thickness as the width of the bars, 0.0 as the bottom of the bars, hues as the color of the bars, and 0.5 as the alpha value of the bars.\n10. Finally, display the plot.",
        "id": 7
    },
    {
        "simple_instruction": "Generate a scatter plot with polar projection using Python. The plot should have 200 points with their positions and colors determined by random values. The area of each point should be proportional to the square of its radial distance from the origin, and the color should be determined by its angle from the positive x-axis. The colors should be represented in the HSV color space. The plot should be reproducible with a fixed random state.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computation.\n2. Set a fixed random state for reproducibility using the numerical computation library's random seed function with the seed value as 12345678.\n3. Compute areas and colors for a scatter plot. To do this, first, define a variable N with a value of 200. Then, generate an array 'r' of N random values between 0 and 3 using the random.rand function from the numerical computation library. Similarly, generate an array 'theta' of N random values between 0 and 3\u03c0. The area of each point in the scatter plot is calculated as 300 times the square of corresponding 'r' value. The color of each point is determined by the corresponding 'theta' value.\n4. Create a new figure using the data visualization library's figure function.\n5. Add a subplot to the figure with a polar projection.\n6. Create a scatter plot on the subplot using the 'theta' and 'r' arrays for the polar coordinates, 'colors' array for the color of each point, 'area' array for the size of each point, 'hsv' for the colormap, and 0.85 for the transparency of the points.",
        "id": 8
    },
    {
        "simple_instruction": "Generate a Python script using matplotlib to create a 4x4 inch figure that plots a line based on array 'x' from 0.0 to 10.0 (step 0.02) against 'y' which is sine(3pix). Annotate the midpoint at x=5 and the peak of the sine curve. Place an annotation of 'data point (4, sin(12pi))' at that data point and use an arrow to point at it. Place 'Sine Curve' text in the top-left using axis coordinates and 'Created by PlotAgent' in the bottom-right using figure coordinates. Add arrows pointing to the midpoint and peak annotations. Set the x-axis limit from -2 to 10 and the y-axis limit from -6 to 6.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computations.\n2. Create a figure with a size of 4x4 using a function from the data visualization library.\n3. Generate an array 'x' using a function from the numerical computation library, starting from 0.0, ending at 10.0 with a step of 0.02.\n4. Create another array 'y' which is the sine of 3*pi*x.\n5. Plot a line on the axes using 'x' and 'y'.\n6. Add an annotation 'Sine Curve' at position (0.05, 0.95) in axes fraction, aligned to the left and top with a font size of 20.\n7. Add another annotation 'Created by PlotAgent' at position (0.95, 0.05) in figure fraction, aligned to the right and bottom with a font size of 12.\n8. Add two more annotations with arrows pointing to data points. The first one should be 'Midpoint' at position (4, sin(12pi)) in data coordinates, with an arrow with a black face color and a shrink factor of 0.05. The second one should be 'Peak' at position (4, 1) in data coordinates, with an arrow with a black face color and a shrink factor of 0.05.\n9. Finally, set the x-axis limit from -2 to 10 and the y-axis limit from -6 to 6.",
        "id": 9
    },
    {
        "simple_instruction": "\"Could you assist me in creating a Python script that generates a plot with the following specifications?\n\n1. The plot should contain three lines. The first line should represent the square of a numerical sequence ranging from 0.0 to 3.0 in increments of 0.02. The second line should represent the cosine of '3*pi' times the same sequence, displayed with a dashed line and circle markers. The third line should represent the product of the square of the sequence and the cosine of '3*pi' times the sequence, displayed with a line style of 's-.'.\n\n2. The plot should also include a numerical sequence ranging from 0.0 to 3.0 in increments of 0.2, plotted against the square root of '1' plus the sequence, displayed with dot markers.\n\n3. The plot should have a legend in the upper left corner, with shadows, labeling the second line as 'oscillatory' and the third line as 'damped'.\n\n4. The x-axis should be labeled as 'time' and the y-axis as 'amplitude'. The title of the plot should be 'Damped oscillation'.\n\nCould you help me with this?\"",
        "expert_instruction": "Could you assist me in creating a Python script that accomplishes the following tasks?\n\n1. First, we need to import some libraries. We'll need one for plotting graphs, one for numerical operations, one for handling collections in our plot, one for managing the legend in our plot, and one for dealing with lines in our plot.\n\n2. Next, we need to create two numerical sequences. Let's call them 'x1' and 'x2'. 'x1' should range from 0.0 to 3.0 in increments of 0.2, and 'x2' should range from 0.0 to 3.0 in increments of 0.02.\n\n3. We'll need to set up a figure and a set of axes for our plot. There's a function in our plotting library that can create a subplot for us.\n\n4. Now, let's plot four lines on our axes. The first line should plot 'x2' against the square of 'x2'. The second line should plot 'x2' against the cosine of '3*pi*x2' with a dashed line and circle markers. The third line should plot 'x1' against the square root of '1+x1' with dot markers. The fourth line should plot 'x2' against the product of the square of 'x2' and the cosine of '3*pi*x2', with a line style of 's-.'.\n\n5. We should add a legend to the upper left of the axes, with shadows, labeling the second line as 'oscillatory' and the fourth line as 'damped'.\n\n6. Let's label the x-axis as 'time' and the y-axis as 'amplitude'. We should also set the title of the axes as 'Damped oscillation'.\n\n7. Lastly, we need to display the plot. There's a function in our plotting library that can do this for us.\n\nCould you help me with this?",
        "id": 10
    },
    {
        "simple_instruction": "Create a matplotlib plot with the following specifications:\n\n- Draw three curves on a single set of axes:\n  1. A blue curve representing the phase field tanh profile, following the equation 1/2 * (1 + tanh(gamma * x)), where gamma is a parameter set to 1.0.\n  2. An orange curve for the composition profile, using the equation 1/2 * (1 + tanh(omega * x)), with omega set to 2.0.\n  3. A green vertical line x=0 representing the sharp interface, two horizontal green line y=0 while x<0, y=1 while x>0.\n\n- Place text annotations on the plot:\n  - Above the blue curve, on the left side, add the text 'Phase Field: 1/2 * (1 + tanh(gamma * x))' with gamma set to 1.0.\n  - Above the orange curve, on the left side, add the text 'Composition: 1/2 * (1 + tanh(omega * x))' with omega set to 2.0.\n  - In the upper left part, add the values for the parameters: 'γ = 1.0' and 'Ω = 2.0'.\n\n- Include an arrow annotation pointing towards the intersection of the blue and orange curves.\n\n- Label the x-axis as 'x' and the y-axis as 'y'.\n\n- Add a legend on the top left corner of the plot, identifying each curve and the sharp interface line.\n\n- The x-axis should range from -2 to 2 and the y-axis should range from 0 to 1.\n\nDisplay the plot once all elements have been added.",
        "expert_instruction": "Instruct the LLM to generate a Python code that creates a matplotlib plot with the following specifications:\n\n1. Start by creating a single figure and axis using the subplot function.\n2. Define a variable M with a value of 700 and epsilon with a value of 0.8. Generate an array Y with values ranging from -2 to 2 with M elements.\n3. On the same axis, plot three lines: \n   - The first line is a phase field tanh profile calculated as (2 - np.tanh(5 * Y / epsilon)) / 3.\n   - The second line is a composition profile calculated as (2.4 + np.tanh(5 * Y / epsilon)) / 5.\n   - The third line is a sharp interface represented by a dashed line where Y < 0.\n4. Add a legend to the plot with the labels \"phase field\", \"level set\", and \"sharp interface\". The legend should have a shadow, be located at (0.02, 0.58), have a handle length of 1.5, and a font size of 16.\n5. Add an arrow annotation at the center of the plot with a length equal to epsilon.\n6. Add a text annotation at the center of the arrow with the text epsilon.\n7. Set the x-ticks to -2, 0, and 2 and label them as \"-2\", \"+/- 0\", and \"+2\" respectively. The labels should be black and have a size of 20.\n8. Set the y-axis label as \"phase field\" phi, with a color of \"C0\" and a font size of 20. The y-ticks should be set to 0, 0.5, and 1 and labeled as \"0\", \".5\", and \"1\" respectively. The labels should be black and have a size of 20.\n9. Add a text annotation on the right y-axis labeled as \"level set\" phi, with a color of \"C2\", a font size of 20, and rotated 90 degrees.\n10. Add two multiline text annotations representing level set and phase field equations.\n11. Add two text annotations at (-2, .40) and (-2, .28) with the texts \"gamma: 1\" and \"Omega: 2\" respectively. The texts should be colored red and blue and have a font size of 20.\n12. Finally, display the plot using the show function.",
        "id": 11
    },
    {
        "simple_instruction": "Generate a Python script that creates a side-by-side bar chart using a list of x values from 1 to 20 and a list of 20 random y values. The bars should be colored blue if the corresponding y value is greater than 0, otherwise orange. The first chart should have a uniform transparency value for all bars and edges, while the second chart, normalize the absolute of y values to get distinct face alpha values and edge alpha values. The sum of one bar's alpha value and edge alpha value should be 1. The random number generator should have a fixed seed to ensure reproducibility. The titles for the first and second sections should be \"Uniform transparency value for all bars and edges\" and \"Adjusted transparencies for each bar and each edge\" respectively.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries that are used for data visualization and numerical computations.\n2. Set a fixed seed for the random number generator in the numerical computation library to ensure the results can be reproduced.\n3. Create a visual space with two sections arranged side by side and set the size of this visual space to 8x4.\n4. Generate a list of x values from 1 to 20.\n5. Generate a list of 20 random y values using the random number generator function from the numerical computation library.\n6. Create a list of colors for the bars, where each color is 'blue' if the corresponding y value is greater than 0, otherwise 'orange'. Use the same list for the edges of the bars.\n7. On the first section of the visual space, create a bar chart using the x and y values, colors for the bars, and colors for the edges. Set the transparency value to 0.6 for all bars and edges. Set the title of this section to \"Uniform transparency value for all bars and edges\".\n8. Adjust the y values to get distinct transparency values for each bar. Also, generate edge transparency values by subtracting each bar transparency from 1.\n9. Combine each bar color with its corresponding bar transparency, and each edge color with its corresponding edge transparency, into two separate lists.\n10. On the second section of the visual space, create a bar chart using the x and y values, and the lists of colors with transparencies. Set the title of this section to 'Adjusted transparencies for each bar and each edge'.\n11. Finally, display the visual space with the two sections.",
        "id": 12
    },
    {
        "simple_instruction": "Generate a Python script that creates a subplot mosaic with six sections. The first row should contain two bar plots with the same data but different hatch patterns. The second row should also contain two bar plots with the same data but different hatch patterns from the first row. The final section should span the entire third row and contain a filled area between the x-axis and a cosine curve with a hatch pattern and a magenta color. Additionally, add an Ellipse and a Polygon to the center of this section with appropriate sizes, hatch patterns, and colors. Adjust the aspect ratio and set the x and y limits of this section. Finally, display the plot.",
        "expert_instruction": "\nTo generate the provided code using an LLM, you would instruct it to create a Python script using the Matplotlib library that accomplishes the following tasks:\n\nDefine a list of categories labeled 'A' through 'E' and a corresponding list of numerical values [3, 7, 2, 5, 6].\nCreate a subplot mosaic with a layout of 2x2 bar plots at the top two rows and a larger plot spanning the entire bottom row for a cosine curve.\nFor the first row of bar plots, create two bar plots (bar1, bar2) using the defined categories and values. Apply different hatch patterns ('/' and '\\') to each plot.\nFor the second row, create two more bar plots (bar3, bar4) with the same data, but use different hatch patterns ('x' and '-').\nIn the larger bottom plot (cosine), plot a cosine curve over a range of 0 to 10. Fill the area under the curve with a magenta color and use a '*' hatch pattern.\nOn the same cosine plot, add an Ellipse at coordinates (5, 0) with width 4, height 1, colored yellow, and a '//' hatch pattern.\nAlso add a blue Polygon to the cosine plot, defined by the vertices [(2, -1), (8, -1), (5, -0.5)], closed, with an 'o' hatch pattern.\nAdjust the aspect ratio of the cosine plot to 'equal' and set x and y limits to 0-10 and -1.5 to 1.5, respectively.\nEnsure that the entire layout is neatly organized.\nFinally, display the plot.",
        "id": 13
    },
    {
        "simple_instruction": "Generate a Python script to create a plot with these features:\n\nEnsure random number generation is consistent in the script.\nEmploy the 'bmh' style for the plot.\nDevelop a function to create histograms based on beta distributions, which takes the plot's axes and two shape parameters as input.\nUse this function to produce a subplot with four histograms, each representing a beta distribution with different shape parameters.\nTitle the plot appropriately.\nDisplay the completed plot.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you please help me generate a Python code that accomplishes the following tasks:\n\n1. We need to bring in two libraries that are commonly used for data visualization and numerical operations. The first one is often used for creating static, animated, and interactive visualizations in Python. The second one is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.\n\n2. To ensure the consistency of our results, we need to set a fixed state for our random number generator. Use the function from the numerical operations library that allows us to set the seed for the random number generator. Let's use 123456 as our seed value.\n\n3. For our plot, let's use a style that is known for its minimalist and clear aesthetics. This style is named after the initials of the creator of a famous statistical programming language.\n\n4. We need to define a function that will create a histogram based on a beta distribution. This function should take three parameters: the axes for the plot, and two shape parameters for the beta distribution. Inside this function, use the first parameter to call the function that creates a histogram. The histogram should be based on a beta distribution generated by a function from the numerical operations library. The size of the distribution should be 10000. The histogram should be filled with steps, have 30 bins, a transparency of 0.7, and should be normalized.\n\n5. Create a subplot and assign its axes to a variable.\n\n6. Use the function we defined earlier four times, each time with different pairs of shape parameters for the beta distribution.\n\n7. Set the title of the plot to \"'Minimalist' style sheet\".\n\n8. Lastly, we need to display the plot. Use the function from the data visualization library that allows us to do this.\"",
        "id": 14
    },
    {
        "simple_instruction": "Could you help me create a Python script that generates a plot for the equation (z - 4) * (z - 6) * (z - 8) + 90? The plot should range from 0 to 11 on the x-axis, with a shaded region between 3 and 10. The y-axis should start from 0. The plot line should be blue with a thickness of 2. The shaded region should be a light blue color. The plot should also include a text at the center of the shaded region with the integral formula, labels for the x and y axes, and x-ticks at 3 and 10 with corresponding labels. The y-ticks should be removed and the top and right borders of the subplot should be hidden.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you help me create a Python script that does the following?\n\n1. First, we need to bring in some libraries. We'll need one for creating plots, one for numerical operations, and one for creating shapes in our plot.\n\n2. Next, let's define a function. Let's call it 'calculation'. This function should take a single input 'z'. The function should return the result of the equation (z - 4) * (z - 6) * (z - 8) + 90.\n\n3. Now, we need to set some limits for an integral. Let's call these 'start' and 'end'. Set 'start' to 3 and 'end' to 10.\n\n4. We need to create a linear space. Let's call it 'z_values'. It should go from 0 to 11. Then, calculate 'result_values' by passing 'z_values' to our 'calculation' function.\n\n5. Now, let's create a subplot and plot 'z_values' and 'result_values' with a line. The line should be blue and have a thickness of 2. Also, set the lower limit of the y-axis to 0.\n\n6. Let's create a shaded region. Generate a linear space between 'start' and 'end'. Calculate the corresponding y-values by passing this linear space to our 'calculation' function. Then, create a list of points by combining the x and y values. Add (start, 0) at the beginning and (end, 0) at the end. Create a shape with these points, give it a light color, and add it to our subplot.\n\n7. Add a text at the center of the shaded region with the integral formula.\n\n8. Add labels to the figure. The x-label should be at position (0.9, 0.05) and the y-label at position (0.1, 0.9).\n\n9. Hide the top and right borders of the subplot.\n\n10. Set the x-ticks to 'start' and 'end' and label them accordingly. Also, remove the y-ticks.\n\n11. Finally, display the plot.\"",
        "id": 15
    },
    {
        "simple_instruction": "Create a Python script using matplotlib to generate a specific plot with the following detailed parameters:\nInitialize a figure with a custom size of 7.5 by 7.5 inches.\nAdd a single axis to the figure with a custom aspect ratio and specified position.\nDefine X as a linear space from 0.5 to 3.5 with 100 elements.\nCalculate Y1 as 3 plus the cosine of X, Y2 as 1 plus the cosine of 1+X/0.75\u200b divided by 2, and Y3 as random values uniformly distributed between Y1 and Y2.\nSet major and minor locators for both x and y axes with major intervals of 1 and minor intervals of 4.\nSet minor formatter for x-axis to display values with two decimal places.\nLimit the x and y axes to a range from 0 to 4.\nFor major ticks, set the width to 1.0, length to 10, and label size to 14.\nFor minor ticks, set the width to 1.0, length to 5, label size to 10, and label color to '0.25'.\nAdd a grid with these specific attributes:\nLinestyle set to \"--\" (dashed).\nLinewidth of 0.5.\nColor set to '.25' (a shade of gray).\nZ-order set to -10.\nPlot three lines with distinct characteristics:\nThe first line (Blue signal) should use color 'C0', linewidth of 2.5, and be placed at z-order 10.\nThe second line (Orange signal) should use color 'C1' and linewidth of 2.5.\nThe third line should consist of scatter markers at every third point, with no linewidth, markersize of 9, marker style 's' (square), marker face color 'none', marker edge color 'C4', and marker edge width of 2.5.\nSet the title \"Anatomy of a figure\" and axis labels \"x Axis label\" and \"y Axis label\" with specific font sizes:\nTitle font size should be 20.\nAxis label font sizes should be 14.\nAdd a legend with these specifications:\nPositioned at the \"upper right\".\nFont size set to 14.\nAnnotate the figure such as tick labels, axes labels, grid, etc., using circles, text, and code snippets at specified coordinates.\nThe circles should have a radius of 0.15, a border color defined by the royal_blue variable with an alpha of 0.6, and a white, non-filled center.\nText annotations should be in both royal blue and black colors, with bold and italic styles",
        "expert_instruction": "Begin by importing the necessary libraries for data visualization and numerical operations. Then, import the Circle class from a library that deals with shapes and patches, and a function that deals with stroke effects from a library that handles path effects. Also, import two classes that deal with minor and major locators from a library that handles tickers. Define a variable that represents the color royal blue as a list with the values 65/255, 105/255, and 225/255.\n\nNext, set the seed of the numerical library to 12345678. Define X as an array with 100 numbers evenly spaced between 0.5 and 3.5. Define Y1 as 3 plus the cosine of X, Y2 as 1 plus the cosine of 1 plus X divided by 0.75, all divided by 2. Define Y3 as an array with randomly distributed numbers between Y1 and Y2.\n\nCreate a figure with a size of 7.5 by 7.5 and add axes to it. Set the major and minor locators of both x and y axes using the classes you imported earlier. Set the minor formatter of the x axis to display two decimal places. Set the limits of x and y axes to 0 and 4. Set the parameters of the major and minor ticks. Add a grid to the axes with a linestyle of \"--\", linewidth of 0.5, color of '.25', and zorder of -10.\n\nPlot Y1, Y2, and Y3 against X with different styles and labels. Set the title of the axes to \"Anatomy of a figure\" with a fontsize of 20 and vertical alignment at the bottom. Set the labels of x and y axes to \"x Axis label\" and \"y Axis label\" respectively with a fontsize of 14. Add a legend to the upper right of the axes with a fontsize of 14.\n\nDefine a function named annotate that takes four parameters: x, y, text, and code. Inside the function, create a circle marker and add it to the axes. Then, create two texts with different path_effects and add them to the axes. Call this function multiple times with different parameters to annotate different parts of the figure, such as tick labels, axes labels, grid, etc., using circles and text with specific styling and path effects.\n\nFinally, set the linewidth and edgecolor of the figure patch to 4 and '0.5' respectively. Display the figure.",
        "id": 16
    },
    {
        "simple_instruction": "Generate a packed bubble chart in Python to represent the popularity of different programming languages. The programming languages to be included are 'Python', 'Java', 'C', 'C++', 'JavaScript', 'R', and 'Swift', with corresponding popularity percentages of 29.72, 19.03, 16.76, 6.91, 8.41, 5.59, and 3.47 respectively. Use the area of the bubble to indicate the popularity. Each bubble should be adjacent to one another. Each language should be represented by a different color. The chart should be titled 'Programming Languages Popularity'.",
        "expert_instruction": "Instruct the LLM to generate a Python code that creates a packed bubble chart representing the popularity of different programming languages. The code should start by importing the necessary libraries for data visualization and numerical computations. Then, define a dictionary named 'programming_languages_popularity' that contains three lists: 'languages', 'popularity', and 'color'. The 'languages' list should contain the names of the languages: 'Python', 'Java', 'C', 'C++', 'JavaScript', 'R', and 'Swift'. The 'popularity' list should contain the corresponding popularity percentages of these languages: 29.72, 19.03, 16.76, 6.91, 8.41, 5.59, and 3.47. The 'color' list should contain the colors to be used for each language in the chart.\n\nNext, use the matplotlib library to create a bubble chart. The size of each bubble should be proportional to the popularity of the programming language it represents. Each bubble should be colored according to the 'color' list in the 'programming_languages_popularity' dictionary.\n\nFinally, set the title of the chart to 'Programming Languages Popularity' and display the chart using the show() function from matplotlib.",
        "id": 17
    },
    {
        "simple_instruction": "Create a Python script that generates a custom geographic projection using a plotting library. The script should include a class for geographic projections and a class for the Aitoff-Hammer projection, an equal-area map projection. The geographic projection class should have methods for setting up and clearing axes, setting limits and transforms, formatting coordinates, and setting longitude and latitude grids. The Aitoff-Hammer projection class should include transformations for the projection. Finally, the script should create a plot displaying a square with four edges on 60 and -60 degrees latitude and 60 and -60 degrees longitude on a globe-like plot using the custom projection.",
        "expert_instruction": "Create a Python script that generates a custom geographic projection using a plotting library. Begin by importing the necessary modules, which include a mathematical module and several components from the plotting library.\n\nCreate a class named `GeoAxes` that inherits from the `Axes` class in the plotting library. This class will act as an abstract base class for geographic projections. \n\nWithin this class, define a nested class `ThetaFormatter` that inherits from the `Formatter` class in the plotting library. This class will be used to format the theta tick labels, converting the native unit of radians into degrees and adding a degree symbol. \n\nIn the `GeoAxes` class, define several methods to set up the axes, clear them, set the limits and transforms, format the coordinates, set the longitude and latitude grids, set the longitude grid ends, and get the data ratio. Also, override several methods to disable interactive panning and zooming.\n\nNext, define a class called `HammerAxes` that inherits from the `GeoAxes` class. This class will be used for the Aitoff-Hammer projection, an equal-area map projection. Inside this class, define two nested classes `HammerTransform` and `InvertedHammerTransform` that inherit from the `Transform` class in the plotting library. These classes will be used to perform the actual transformations for the projection.\n\nFinally, register the `HammerAxes` projection with the plotting library using the `register_projection` function. Then, create a simple example plot using the custom projection. This plot should display a square on a globe-like plot.",
        "id": 18
    },
    {
        "simple_instruction": "Create a Python program to visualize fruit sales data across different regions with these specifications:\n\nConstruct a stacked bar chart representing sales of 'Apples', 'Oranges', 'Bananas', 'Grapes', and 'Berries' for 'North', 'South', 'East', 'West', and 'Central' regions. Use the following sales data: sales_data = [\n    [120, 95, 130, 85, 100],  # Apples\n    [90, 115, 80, 105, 95],   # Oranges\n    [75, 80, 85, 70, 90],     # Bananas\n    [65, 70, 60, 75, 80],     # Grapes\n    [55, 60, 65, 50, 55]      # Berries\n]\nThe y-axis should indicate sales in hundreds, and the x-axis should remain unlabeled.\nTitle the chart 'Sales by Region' and choose soft shades for the bar colors.\nDisplay the cumulative sales value for each region at the top of its stacked bar.\nAdd a table below the chart that corresponds to the data in the bars, with rows colored to match the bar segments. Format the sales numbers in the table to two decimal place, representing the actual value divided by 100.\nThe layout should be adjusted so that both the chart and the table are clearly visible.\nShow the completed chart with the table included.",
        "expert_instruction": "Create a Python program that utilizes two libraries, one for data manipulation and the other for data visualization, to generate a stacked bar chart. The data for the chart should be a two-dimensional list where each sublist signifies a different type of fruit and contains the sales for different regions. The fruit types are 'Apples', 'Oranges', 'Bananas', 'Grapes', and 'Berries'. The regions are 'North', 'South', 'East', 'West', and 'Central', represented as strings. Use the following sales data: sales_data = [\n    [120, 95, 130, 85, 100],  # Apples\n    [90, 115, 80, 105, 95],   # Oranges\n    [75, 80, 85, 70, 90],     # Bananas\n    [65, 70, 60, 75, 80],     # Grapes\n    [55, 60, 65, 50, 55]      # Berries\n]\n\nThe y-axis should represent the sales in hundreds and the x-axis should not have any ticks. The chart should be titled 'Sales by Region'. \n\nUse soft shades for the colors of the bars and make sure that the last value is displayed at the top. \n\nBelow the chart, include a table that shows the same data. The table should have the same row and column labels as the chart, and the cell text should be the sales values divided by 100, formatted to two decimal places. The row colors should match the corresponding bars in the chart. \n\nFinally, adjust the layout to make room for the table and display the chart.",
        "id": 19
    },
    {
        "simple_instruction": "Create a 3D bar plot using Python. The plot should have a fixed random state for reproducibility. The plot should incorporate a 3D subplot and use the colors 'purple', 'orange', 'grey', and 'pink'. Each color should correspond to a unique set of data for the y=k 'layer'. The x values should range from 0 to 29, and the y values should be an array of 30 random numbers. The last bar of each set should be colored 'black' to demonstrate the flexibility of the color parameter. The bars should be plotted on the plane y=k with 80% opacity. The x, y, and z axes should be labeled appropriately, with the y-axis only labeling the discrete values that data is available for.",
        "expert_instruction": "Create a 3D bar plot using a Python-based data visualization library and a numerical computation library. Begin by importing the necessary modules. Establish a fixed random state to ensure the results are reproducible.\n\nNext, construct a figure and incorporate a 3D subplot into it. Define a list of colors and yticks. The colors should be 'purple', 'orange', 'grey', and 'pink', and the yticks should be [4, 3, 2, 1]. For each color and ytick, generate a unique set of data for the y=k 'layer'. The x values should be an array of numbers from 0 to 29, and the y values should be an array of 30 random numbers. \n\nTo demonstrate the flexibility of the color parameter, color the last bar of each set 'black'. Plot the bar graph on the plane y=k with 80% opacity. \n\nSet the labels for the x, y, and z axes. On the y-axis, only label the discrete values that you have data for. Lastly, display the plot.",
        "id": 20
    },
    {
        "simple_instruction": "Generate a 3D plot of a parametric curve, where the curve is defined by the cosine, sine of 2 times, and cosine of 4 times an array ranging from 0 to 4*pi+0.1. Use error bars with a frequency of 20 and limits defined by two boolean conditions: the array's index modulo 20 equals 0 and the array's index integer divided by 20 modulo 3 equals 0 or 2. The error should be 0.3. Label the x, y, and z axes as \"X label\", \"Y label\", and \"Z label\" respectively. Display the plot.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for creating plots and handling numerical computations.\n2. Create a 3D subplot from a newly created figure object and assign it to a variable.\n3. Set up a parametric curve by creating an array that starts from 0, ends at 4*pi+0.1, and has a step of 0.02. Then, calculate three variables as the cosine of the array, sine of 2 times the array, and cosine of 4 times the array respectively.\n4. Define a variable with a value of 20 and an array that contains the size of the previously mentioned array.\n5. Create two boolean arrays that are true when the array's index modulo the defined variable equals 0 and the array's index integer divided by the defined variable modulo 3 equals 0 or 2 respectively.\n6. Plot an error bar with the three calculated variables as the data, 0.3 as the error, the two boolean arrays as the up and low limits of the error bars, and the defined variable as the frequency of the error bars.\n7. Set the labels of the x, y, and z axes to \"X label\", \"Y label\", and \"Z label\" respectively.\n8. Finally, display the plot.",
        "id": 21
    },
    {
        "simple_instruction": "\nDevelop a Python script that:\n\nInitializes random number generation with a fixed seed of 1234567 to ensure reproducibility.\nGenerates two sets of 200 random values within the range of -5 to 5.\nCreates a 2D histogram of these values with 10 bins across the specified range.\nConstructs a 3D bar plot from the histogram data.\nDisplays the resulting 3D plot.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Start by importing two libraries that are commonly used for data visualization and numerical operations.\n2. To ensure the consistency of the results, set a fixed state for random number generation. Use the same seed value as 1234567.\n3. Create a new visual space where you can plot your data.\n4. Add a 3D area to the visual space you just created.\n5. Generate two sets of data, let's call them 'a' and 'b'. Each set should contain 200 random values between -5 and 5.\n6. From these two sets of data, create a 2D histogram. Set the number of divisions to 10 and the range for both axes to [-5, 5]. Keep the output in three separate variables.\n7. Construct arrays for the anchor positions of the 100 bars. Use the edges of the histogram bins, shifted by 0.5, as inputs. Flatten the resulting arrays and store them in two new variables. Set the third dimension position to 0.\n8. Construct arrays with the dimensions for the 100 bars. Set the length and width to half of an array of ones with the same shape as the third dimension position. Set the height to the flattened histogram array.\n9. Create a 3D bar plot using the position and dimension arrays as inputs. Sort the bars based on their average height.\n10. Finally, display the plot.",
        "id": 22
    },
    {
        "simple_instruction": "Generate a 3D plot of a parametric curve using Python. The curve should be defined by three arrays: 'alpha', 'w', and 'p'. 'alpha' should range from -6\u03c0 to 6\u03c0, 'w' should range from -3 to 3, and 'p' should be the cube of 'w' plus 2. The curve should be plotted in terms of 'a', 'b', and 'w', where 'a' is the product of 'p' and the sine of 'alpha', and 'b' is the product of 'p' and the cosine of 'alpha'. The plot should be labeled as 'parametric curve' and include a legend.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Bring in a library in Python that is commonly used for creating static, animated, and interactive visualizations and another one that is used for working with arrays. Use 'plt' and 'np' as their respective aliases.\n2. Generate a new instance of a figure and add a 3D subplot to it. Assign this subplot to a variable named 'ax'.\n3. Create three arrays named 'alpha', 'w', and 'p'. 'alpha' should be an array with evenly spaced numbers over a specified range from -6\u03c0 to 6\u03c0 with 150 points. 'w' should be an array with evenly spaced numbers over a specified range from -3 to 3 with 150 points. 'p' should be an array where each element is the cube of the corresponding 'w' element plus 2.\n4. Compute 'a' and 'b' arrays using the 'p' and 'alpha' arrays. Each 'a' element should be the product of the corresponding 'p' element and the sine of the corresponding 'alpha' element. Each 'b' element should be the product of the corresponding 'p' element and the cosine of the corresponding 'alpha' element.\n5. Draw 'a', 'b', and 'w' on the 3D subplot using the plot method of 'ax'. Label the plot as 'parametric curve'.\n6. Incorporate a legend to the plot using the legend method of 'ax'.\n7. Render the plot using the show method from the 'plt' module.",
        "id": 23
    },
    {
        "simple_instruction": "Generate a Python code that uses the Rossler attractor equations to create a 3D plot. The plot should have 'u', 'v', and 'w' as axes, a line width of 0.5, and the title \"Rossler Attractor\". The initial values for the Rossler attractor should be (1., 1., 1.).",
        "expert_instruction": "Instruct the LLM to generate a Python code that starts by importing the necessary libraries for data visualization and numerical operations. Then, define a function named 'rossler' that accepts an array-like parameter 'uvw' and three float parameters 'a', 'b', and 'c'. This function should unpack 'uvw' into 'u', 'v', and 'w', then calculate 'u_dot', 'v_dot', and 'w_dot' using the Rossler attractor equations. The function should return these values as a numerical array.\n\nNext, set a small time increment and a large number of steps. Create an empty numerical array 'uvws' with shape (number of steps + 1, 3) and set the initial values to (1., 1., 1.). Then, create a loop that iterates over the range of the number of steps. In each iteration, calculate the next point in the Rossler attractor by adding the product of the 'rossler' function and the small time increment to the current point.\n\nFinally, create a 3D plot using the data visualization library. Plot 'uvws' with a line width of 0.5, set the labels for the u, v, and w axes, and set the title to \"Rossler Attractor\". Display the plot using the appropriate function from the data visualization library.",
        "id": 24
    },
    {
        "simple_instruction": "Create a Python script that uses data visualization and numerical computation libraries to generate a figure with two subplots. The first subplot should be a 2D plot of a function, g(s), which is the sine of 3*pi*s multiplied by the exponential of -s, with three different sets of data g(s), g(s + 0.1) and g(s + 0.2). The second subplot should be a 3D plot of a surface generated from two arrays, P and Q, and a function, E, which is the cosine of the square root of the sum of squares of P and Q. The figure should have a title 'A Story of 2 Subplots'.",
        "expert_instruction": "Create a Python script that uses data visualization and numerical computation libraries to generate a figure with two subplots. Begin by bringing in the necessary libraries. Define a function, g(s), that gives the sine of 3*pi*s multiplied by the exponential of -s.\n\nConstruct a figure with a height twice its width and assign it a title 'A Story of 2 Subplots'. \n\nFor the first subplot, create three sets of data: s1, s2, and s3, using a function that generates evenly spaced values within a given interval. The intervals for s1, s2, and s3 should be different. Plot s1 and g(s1) as red triangles, and s2 and g(s2) as a grey dotted line with yellow marker face color. Enable grid and set the y-label as 'Damped wave'.\n\nFor the second subplot, create a 3D projection. Generate two arrays, P and Q, using a function that generates evenly spaced values within an interval of 0.5 from -10 to 10. Create a meshgrid from P and Q. Calculate D as the square root of the sum of squares of P and Q, and E as the cosine of D. Plot a surface using P, Q, and E with a stride of 1, no linewidth, and disable antialiasing. Set the z-limit from -1 to 1.\n\nLastly, display the plot using a function that shows the plot.",
        "id": 25
    },
    {
        "simple_instruction": "Create a 3D plot in Python that generates multiple polygons to fill under a series of 3D line graphs\n\n- The x-axis should have values from 0 to 20, evenly spaced.\n- The y-axis should range from 2 to 10.\n- For the z-axis, calculate probabilities using a Gaussian distribution function.\n- Include a series of polygons along the y-axis, each representing a different y-value for the mean of the Gaussian distribution and set the standard deviation to half of the y-value.\n- Color the polygons using a reversed plasma color map.\n- Ensure all axes and the plot itself are properly labeled. \n- Set appropriate x-axis, y-axis and z-axis limits. \n\nDisplay the final 3D plot.",
        "expert_instruction": "Import Necessary Libraries: Begin by importing the essential Python libraries: numpy, matplotlib.pyplot, and specific modules from mpl_toolkits.mplot3d and scipy.stats. Highlight that numpy is for numerical operations, matplotlib.pyplot for plotting, and mpl_toolkits.mplot3d and scipy.stats for 3D plotting and statistical functions, respectively.\n\nDefine a Function for Creating Gaussian Polygons: Request to create a function named create_gaussian_polygons that takes parameters x, mean, and std_dev. This function should compute the Gaussian distribution values using norm.pdf from scipy.stats and return vertices for polygons formed by these values.\n\nSet Up X-axis Values and Y-axis Range: Ask to create a linearly spaced array x using numpy.linspace for the x-axis, spanning from -10 to 20 with 100 points. Then, define a range y using numpy.arange for the y-axis, representing mean values from 2 to 10.\n\nInitialize a 3D Plot: Instruct to create a 3D plot using matplotlib.pyplot. This involves initializing a figure and adding a subplot with 3D projection.\n\nGenerate and Plot Polygons: Indicate the need to loop over each value in the y array. In each iteration, calculate the standard deviation as half of the mean (yi). Then, call the create_gaussian_polygons function with x, the current mean (yi), and the calculated standard deviation. Create a Poly3DCollection for these polygons, setting its facecolors with a colormap (cm.plasma_r) and add this collection to the 3D axis.\n\nLabel Axes and Set Limits: Request to set labels for the x-axis, y-axis (as \"Mean\"), and z-axis (as \"Probability (Gaussian Distribution)\"). Also, instruct to set the limits for each axis, with specific ranges for x, y, and z axes.\n\nDisplay the Plot: Finally, ask to show the plot using plt.show().",
        "id": 26
    },
    {
        "simple_instruction": "\"Generate a 3D stem plot using Python. The plot should be based on an array of evenly spaced numbers from 0 to 4 times the mathematical constant pi. Create two sets of data based on the sine and cosine of these values, each subtracted by pi divided by 4. Use these two sets of data along with the original array to create the stem plot. The plot should be a discrete series plot, useful for plotting non-continuous or discrete data points.\"",
        "expert_instruction": "As an expert in LLMs and prompt engineering, I would like you to assist me in generating a code that accomplishes the following tasks:\n\n1. Start by importing two necessary libraries. One is widely used for creating static, animated, and interactive visualizations in Python. The other one is a library used for working with arrays in Python.\n\n2. Next, create a variable, let's call it 'alpha'. This variable should hold an array of evenly spaced numbers over a specified range. This time, let's make the range from 0 to 4 times the mathematical constant that represents the ratio of the circumference of a circle to its diameter.\n\n3. Now, create two more variables, let's name them 'p' and 'q'. Assign to 'p' the sine of the 'alpha' values subtracted by the mathematical constant divided by 4. Similarly, assign to 'q' the cosine of the 'alpha' values subtracted by the mathematical constant divided by 4.\n\n4. Create another variable, let's call it 'r'. This variable should hold the 'alpha' values.\n\n5. Now, let's create a 3D subplot. Use the function from the visualization library that creates a figure and a set of subplots. This function should take a dictionary as an argument, specifying a 'projection' of '3d'.\n\n6. On the created subplot, create a stem plot using 'p', 'q', and 'r'. The stem plot is a discrete series plot, which is useful for plotting non-continuous or discrete data points.\n\n7. Finally, display the plot using the function from the visualization library that shows the figure.\n\nRemember, the goal here is to change how the data points are produced while keeping the plot type the same. All other aspects of the plot should remain unchanged.",
        "id": 27
    },
    {
        "simple_instruction": "Generate a Python script that creates a 3D plot using a range of numbers from -10 to 10 with a step of 0.5 for both the horizontal and vertical axes. The third dimension should be calculated as the cosine of the square root of the sum of squares of the horizontal and vertical grid values. The plot should use the 'coolwarm' color map, have a line width of 0, and disable antialiasing. The third dimension axis should have limits of -1.01 and 1.01, with 10 ticks and numbers formatted to 2 decimal places. A color bar should be added to the figure with a shrink parameter of 0.5 and an aspect parameter of 5.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries that will allow for data manipulation, plotting, and customization of plots.\n\n2. Set up a 3D subplot using a function from the plotting library, ensuring the projection parameter is set to \"3d\".\n\n3. Generate a range of numbers from -10 to 10 with a step of 0.5 for both the horizontal and vertical axes using a function from the data manipulation library. Then, create a 2D grid of these numbers using a function from the same library.\n\n4. Calculate the square root of the sum of squares of the horizontal and vertical grid values for each point in the grid. Then, compute the cosine of these values to create the third dimension values.\n\n5. Plot the surface using a function from the plotting library with the horizontal, vertical, and third dimension values as inputs. Set the color map to 'coolwarm', line width to 0, and disable antialiasing.\n\n6. Set the limits of the third dimension axis to -1.01 and 1.01 using a function from the plotting library. Then, set the major locator of the third dimension axis to a locator with 10 ticks using a function from the plotting library. Also, set the major formatter of the third dimension axis to format the numbers to 2 decimal places.\n\n7. Add a color bar to the figure that maps the values to colors using a function from the plotting library. Set the shrink parameter to 0.5 and the aspect parameter to 5.\n\n8. Finally, display the plot using a function from the plotting library.",
        "id": 28
    },
    {
        "simple_instruction": "Write a Python script to create a filled 3D tricontour plot with these characteristics:\n- Set the range of radii from a minimum value up to 1.2, and ensure the points span a full circle.\n- Apply the CMRmap colormap to the plot.\n- Adjust the plot's viewing angle to enhance the visual representation of the data.",
        "expert_instruction": "Generate a Python script that performs the following tasks:\n\n1. Bring in the necessary libraries that will allow for data manipulation, plotting, and mathematical operations.\n2. Establish variables for the quantity of points, number of circles, and the smallest circle radius.\n3. Construct a mesh in polar coordinates and compute x, y, z. The radii should be a linear space from the smallest circle radius to 1.2, and the points should be a linear space from 0 to 2*pi. The points should be repeated for each radius, and every third point should be incremented by pi divided by the number of points.\n4. Transform the polar coordinates to Cartesian coordinates by multiplying the radii by the cosine and sine of the points, respectively. The z values should be the sine of the radii times the sine of two times the points.\n5. Create a custom triangulation using the x and y values.\n6. Exclude unwanted triangles by setting a mask on the triangulation. The mask should be a boolean array where each value indicates whether the mean hypotenuse of the x and y values of the triangles is less than the smallest circle radius.\n7. Add a subplot to a new figure with a 3D projection.\n8. Plot a tricontour plot on the subplot using the triangulation and z values, with a colormap of CMRmap.\n9. Adjust the view angle of the subplot to 50 degrees elevation for better understanding of the plot.\n10. Display the plot.",
        "id": 29
    },
    {
        "simple_instruction": "Generate a unfilled 3D tricontour plot in Python that visualizes data in polar coordinates with the following details:\n\nUse 36 angles and 10 radii, with the radii starting at 0.15 and extending to 0.85.\nThe angles should be within a range of 0 to 1.5 times pi.\nCalculate the x, y, and z coordinates from these polar coordinates, with the z-values determined by the sine of twice the angle values.\nMask out any triangles in the mesh that have an average hypotenuse shorter than the minimum radius.\nApply an appropriate colormap to the plot.\nSet the view angle of the plot to 60 degrees for optimal viewing.",
        "expert_instruction": "Create a 3D contour plot using Python, utilizing the necessary libraries for data manipulation and visualization.\n\nFirst, you'll need to define the parameters for the plot. Instead of 48 angles and 8 radii, let's use 36 angles and 10 radii. Set the minimum radius to 0.15 instead of 0.25.\n\nNext, create a mesh in polar coordinates. Generate an array of radii that ranges from the minimum radius to 0.85, and an array of angles that ranges from 0 to 1.5 times pi. Repeat the angles for each radius and shift every second angle by pi divided by the number of angles.\n\nNow, calculate the x, y, and z coordinates. For x and y, multiply the radii with the cosine and sine of the angles respectively. For z, instead of multiplying the cosine of the radii with the cosine of 3 times the angles, use the sine of twice the angles. Flatten these arrays afterwards.\n\nNext, create a custom triangulation using the x and y coordinates. Exclude triangles that are not needed by masking off those whose average hypotenuse is less than the minimum radius.\n\nAfterwards, create a 3D subplot and plot the triangulation and z coordinates. Use a tricontourf plot with the same color map as before. Adjust the view angle to 60 degrees for better visualization.\n\nFinally, display the plot.",
        "id": 30
    },
    {
        "simple_instruction": "Generate a Python code that creates a 3D plot of a 10x10x10 grid with three cuboids and two link cuboids between them. The cuboids should be 3D volumetric objects plotted with voxels. The three cuboids should have a side length of 3. The first cuboid should be located in the bottom left corner, the second in the center, and the third in the top right corner. The link should be defined as all points where the sum of the absolute differences between x, y, and z is less than or equal to 3. Each object should have a distinct color: 'yellow' for the first cuboid, 'blue' for the second, 'green' for the third, and 'purple' for the link. The plot should have black edge colors.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries that will allow you to create plots and handle numerical operations.\n2. Generate coordinates for a 10x10x10 grid using a function from the numerical library that can create an evenly spaced grid of indices.\n3. Create three cuboids within this grid. The first cuboid should be located in the top left corner and defined by all points where x, y, and z are less than 4. The second cuboid should be in the center of the grid, defined by all points where x, y, and z are between 4 and 6. The third cuboid should be in the bottom right corner, defined by all points where x, y, and z are greater than or equal to 6.\n4. Define a link between the three cuboids. This link should be defined as all points where the sum of the absolute differences between x, y, and z is less than or equal to 3.\n5. Combine these four objects into a single boolean array using a logical operator that returns True if either of the conditions is met.\n6. Assign colors to each object by creating an empty array of the same shape as the boolean array. Assign the color 'purple' to the link, 'yellow' to the first cuboid, 'blue' to the second cuboid, and 'green' to the third cuboid.\n7. Plot everything using a function from the plotting library that allows 3D projection. Use a function that can plot the boolean array, with the facecolors set to the colors array and the edgecolor set to black.\n8. Lastly, display the plot using a function from the plotting library that shows the final figure.",
        "id": 31
    },
    {
        "simple_instruction": "Create a Python script to produce a 3D voxel plot with the following details:\n\nThe plot should feature a cube centered at the coordinates [0.5, 0.5, 0.5] with a side length of 0.5.\nConstruct a boolean array to represent the presence of the cube in the 3D space.\nGenerate three normalized 3D arrays of size (20, 20, 20) to represent the RGB color channels.\nUse the midpoint values of these arrays to color the voxels inside the cube.\nThe voxel edge colors should be a brighter variant of their face colors.\nLabel the axes with corresponding names to the three RGB arrays.\nEnsure the aspect ratio of the plot is equal.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Import the necessary libraries for plotting and numerical computations.\n2. Define a function that takes a single argument, a multi-dimensional array. This function should calculate the midpoints of the array by iterating over its dimensions and averaging adjacent elements. The result should be returned.\n3. Create three multi-dimensional arrays with dimensions (20, 20, 20), and normalize their values by dividing them by 19.0.\n4. Use the previously defined function to calculate the midpoints of these three arrays and assign the results to three new variables.\n5. Define a cube in 3D space centered at [0.5, 0.5, 0.5] with a side length of 0.5. The cube should be represented as a boolean array where True values indicate points inside the cube.\n6. Create a 4D array with the same shape as the cube and an additional last dimension of size 3. Assign the three midpoint arrays to the red, green, and blue channels of this 4D array respectively.\n7. Create a 3D plot using a function that can plot voxels. The voxel grid should be defined by the three original arrays, and the voxels inside the cube should be colored according to the 4D array. The edge colors of the voxels should be a brighter version of the face colors, and the linewidth should be set to a small value.\n8. Label the x, y, and z axes with the names of the three original arrays respectively, and set the aspect ratio of the plot to 'equal'.\n9. Finally, display the plot.",
        "id": 32
    },
    {
        "simple_instruction": "Create a script in Python that:\n\n- Produces a 3D plot displaying a donut shape.\n- Uses three 3D grids to define the geometry: one grid ranging from 0 to 2, another from 0 to 2*pi, and the third from -1 to 1.\n- Generates a 4D array to derive RGB colors for the donut.\n- Applies the RGB colors to the faces of the donut and uses a brighter version for the edges.\n\nThe output should be a visually appealing 3D donut plot with the specified color attributes.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries that are used for data manipulation, mathematical operations, and data visualization.\n\n2. Define a function that takes a multi-dimensional array as input and calculates the midpoints of the array. This function should iterate over the dimensions of the array and for each dimension, calculate the average of the current and next element, then return the updated array.\n\n3. Generate three 3D grids. The first grid should range from 0 to 2 with 15 points, the second grid should range from 0 to 2*pi with 30 points, and the third grid should range from -1 to 1 with 15 points.\n\n4. Calculate two new arrays by multiplying the first grid with the cosine and sine of the second grid respectively.\n\n5. Calculate the midpoints of the three grids using the function defined in step 2 and assign the results to three new variables respectively.\n\n6. Define a 3D boolean array that represents a donut shape in the 3D grid.\n\n7. Create a 4D array with the same shape as the boolean array and an additional dimension of size 3. Assign the normalized second grid to the first color component, the first grid to the second, and the third grid offset by 0.5 to the third.\n\n8. Convert the 4D array colors to RGB format using a function from the imported libraries and assign the result to a new variable.\n\n9. Create a 3D plot by adding a subplot to a new figure. Use a function to plot the boolean array in 3D space, using the RGB colors for the facecolors and a brighter version of the RGB colors for the edgecolors. Set the linewidth to 0.5.\n\n10. Finally, display the plot using a function from the imported libraries.",
        "id": 33
    },
    {
        "simple_instruction": "Generate a Python script that plots a straight line y=x with longitude values ranging from -180 to 180 using the Mercator projection for scaling latitudes. The x-axis should be labeled 'Longitude' and the y-axis should be labeled 'Latitude'. The title of the plot should be 'Mercator projection'. The plot should also include a grid for better visualization.",
        "expert_instruction": "1. Import the necessary libraries. You'll need a library for numerical operations, a library for plotting, and some specific modules from the plotting library for scaling and transforming data.\n\n2. Create a class named `MercatorLatitudeScale` that inherits from the base scale class in the plotting library. This class will be used to scale data in the range -pi to pi (-180 to 180 degrees) using the system used to scale latitudes in a Mercator projection.\n\n3. In the `MercatorLatitudeScale` class, define an initialization method that accepts an `axis` and a `thresh` parameter. The `thresh` parameter should default to the radian equivalent of 180 degrees.\n\n4. Within the `MercatorLatitudeScale` class, define a method that returns an instance of a nested class `MercatorLatitudeTransform`.\n\n5. Define a method in the `MercatorLatitudeScale` class that sets up the locators and formatters to use with the scale.\n\n6. Define a method in the `MercatorLatitudeScale` class that limits the bounds of the axis to the domain of the transform.\n\n7. Define two nested classes within the `MercatorLatitudeScale` class: `MercatorLatitudeTransform` and `InvertedMercatorLatitudeTransform`. Both of these classes should inherit from the transform class in the plotting library.\n\n8. Register the `MercatorLatitudeScale` class using the register function in the scale module of the plotting library.\n\n9. In the main section of the script, create an array `t` with values ranging from -180.0 to 180.0 with a step of 0.1. Create another array `s` which is equal to `t`.\n\n10. Plot `t` against `s` using the plotting function in the plotting library. Set the y-scale to 'mercator' using the yscale function in the plotting library.\n\n11. Label the x-axis as 'Longitude', the y-axis as 'Latitude', and the title as 'Mercator projection'. Enable the grid and display the plot.",
        "id": 34
    },
    {
        "simple_instruction": "Generate a Python script that visualizes four different mathematical functions using a 2x2 grid of subplots. The first subplot should show the exponential decay of a range of data with a decay factor of 7.0, the second subplot should display the cosine of the data multiplied by 3\u03c0, the third subplot should plot 25 times the exponential decay of the data with a decay factor of 15.0 with a base 3 logarithmic scale on the x-axis, and the fourth subplot should plot cubed data generated by raising 15 to the power of a linearly spaced array, with error bars. The range of data for the first three subplots should be evenly spaced from 0.02 to 25.0 with a step of 0.02. The y-axis of the first subplot, the x-axis of the second subplot, and both axes of the third and fourth subplots should be on a logarithmic scale. The fourth subplot should have error bars, with the x error being 15% of x and the y error being 7.0 plus 80% of y, and its y-axis should have a lower limit of 0.15. The figure should be neatly laid out and displayed.",
        "expert_instruction": "Instruct the language model to generate a Python script that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computations.\n2. Generate a range of data for plotting using a function that creates evenly spaced values within a given interval. Start from 0.02 up to 25.0 with a step of 0.02.\n3. Create a figure with 4 subplots arranged in a 2x2 grid.\n4. For the first subplot, plot the exponential decay of the data with a decay factor of 7.0 using a logarithmic scale on the y-axis. Title this subplot 'semilogy' and add a grid.\n5. For the second subplot, plot the cosine of the data multiplied by 3\u03c0 using a logarithmic scale on the x-axis. Title this subplot 'semilogx' and add a grid.\n6. For the third subplot, plot 25 times the exponential decay of the data with a decay factor of 15.0 using a logarithmic scale on both the x and y axes. Set the base of the x-axis logarithmic scale to 3. Title this subplot 'loglog base 3 on x' and add a grid.\n7. For the fourth subplot, generate new data by raising 15 to the power of a linearly spaced array from 0.0 to 3.0 with 25 points, and cube this data. Plot this data with error bars, setting the x error to 15% of x and the y error to 7.0 plus 80% of y. Use a logarithmic scale on both the x and y axes, clipping non-positive values. Title this subplot 'Errorbars go negative'. Set the lower limit of the y-axis to 0.15 after plotting the error bars to allow the error bars to autoscale the limits.\n8. Adjust the layout of the figure to fit the subplots neatly.\n9. Finally, display the figure using the function that shows the plot.",
        "id": 35
    },
    {
        "simple_instruction": "Generate a Python script to create a plot comparing the cumulative distribution functions (CDFs) of normal, Laplacian, and Cauchy distributions, with these specifics:\n\nUse a range of values from -20 to 20, with a high resolution.\nCalculate and plot the CDFs for each distribution.\nOrganize the plots into a grid with three rows and two columns, each subplot demonstrating all three distribution type.\nImplement logit scaling for the y-axis in the first two rows, with appropriate y-limits, and linear scaling for the y-axis in the third row.\nFor certain subplots, adjust the x and y limits to focus on specific areas of the distribution.\nLabel each subplot with the corresponding distribution type and include legends and grids for clarity.\nMake layout adjustments to ensure all subplots are displayed neatly.\nShow the complete figure with these comparisons.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you help me generate a Python code that completes the following tasks?\n\n1. First, we need to import some libraries. We'll need one for mathematical functions, one for creating plots, and one for numerical operations.\n\n2. Now, let's define a variable that we'll call `ymax` and assign it a value of 20. We also need to create an array, let's call it `y`, using a function from our numerical operations library that generates evenly spaced numbers over a specified range. The range should be from `-ymax` to `ymax`, and we want 20000 numbers.\n\n3. We need to calculate the cumulative distribution function (CDF) for three different distributions: a normal distribution, a Laplacian distribution, and a Cauchy distribution. We'll use our array `y` for these calculations. Let's store the results in `cdf_norm`, `cdf_laplacian`, and `cdf_cauchy` respectively.\n\n4. Next, we need to create a figure with 3 rows and 2 columns of subplots using a function from our plotting library. The figure size should be `(6.4, 8.5)`.\n\n5. For each subplot, we should plot the CDFs we calculated earlier. Let's label them as `r\"$\\mathcal{N}$\"`, `r\"$\\mathcal{L}$\"`, and `\"Cauchy\"`. We should also add a legend and grid to each subplot.\n\n6. For the first row of subplots, let's set the y-scale to `\"logit\"` and the y-limit to `(1e-5, 1 - 1e-5)`. For the second subplot in the first row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1 - 5e-3)`.\n\n7. For the second row of subplots, we should also set the y-scale to `\"logit\"` with `one_half=\"1/2\"` and `use_overline=True`. We should set the y-limit to `(1e-5, 1 - 1e-5)`. For the second subplot in the second row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1 - 5e-3)`.\n\n8. For the third row of subplots, let's set the y-scale to `\"linear\"` and the y-limit to `(0, 1)`. For the second subplot in the third row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1)`.\n\n9. We should adjust the layout of the figure to fit the subplots neatly using a function from our plotting library.\n\n10. Finally, we need to display the figure. There should be a function in our plotting library that can do this.\"",
        "id": 36
    },
    {
        "simple_instruction": "Create a Python script to generate a Hinton Diagram with the following features:\n\nVisualize a 15x15 matrix of random values ranging from -2 to 1. Use a fixed random seed (123456) for reproducibility.\nRepresent positive values with white rectangles and negative values with black rectangles.\nThe size of each rectangle should correspond to the magnitude of the matrix value it represents.\nPosition the rectangles such that they are centered on their corresponding matrix elements.\nUse gray as the background color for the plot.",
        "expert_instruction": "Could you help me create a Python script that performs the following tasks?\n\n1. First, we need to import two libraries. One is commonly used for creating static, animated, and interactive visualizations in Python. The other one is a library used for working with arrays.\n\n2. We need to define a function that will be used to visualize a weight matrix. Let's call this function 'visualize_weights'. This function should take three parameters: a matrix, a maximum weight which is optional, and an axis which is also optional.\n\n3. Inside the function, if the axis is not provided, we should use the current axis.\n\n4. If the maximum weight is not provided, we should calculate it. To do this, find the maximum absolute value in the matrix, take the base 2 logarithm of this value, round it up to the nearest integer, and then raise 2 to the power of this value.\n\n5. We should set the face color of the axis patch to gray and set the aspect of the axis to 'equal' and 'box'.\n\n6. We should remove the major ticks from the x and y axes.\n\n7. We need to iterate over the matrix. For each element, we should determine its color (white if it's positive, black if it's negative) and size (the square root of its absolute value divided by the maximum weight).\n\n8. We should create a rectangle patch with the calculated size and color, centered at the current position, and add it to the axis.\n\n9. After iterating over all elements, we should adjust the axis to fit the patches and invert the y-axis.\n\n10. In the main part of the script, we should set the random seed of our array library to 123456 for reproducibility.\n\n11. We should call the 'visualize_weights' function with a 15x15 matrix filled with random values between -2 and 1.\n\n12. Finally, we should display the plot.",
        "id": 37
    },
    {
        "simple_instruction": "Create a Python script to generate a fishbone diagram that visualizes the potential causes of \"Decreased Sales Performance\" in a business context. The diagram should include the following elements:\n\nMain Problem: \"Problem\" at the head of the diagram.\n\nSix Key Categories branching off from the main spine, each with its own specific causes:\n\nProduct Issues: Poor Quality, Limited Range, Obsolete Features.\nMarketing and Sales Strategy: Ineffective Advertising, Poor Online Presence, Inadequate Sales Training.\nCustomer Service: Slow Response Time, Lack of Personalization, Poor After-Sales Support.\nPricing Strategy: High Prices, Inflexible Payment Options.\nMarket Conditions: Increased Competition, Changing Preferences, Economic Downturn.\nInternal Processes: Inefficient Supply Chain, Poor Communication, Limited R&D.\nArrange these categories and their causes at specific locations and angles on the diagram, emanating from the central spine.\n\nThe diagram should have a clear and organized layout, reflecting the relationship between the main problem and its potential causes.",
        "expert_instruction": "Create a Python script that generates a fishbone diagram to visualize the potential causes of \"Decreased Sales Performance\". Use a plotting library, such as matplotlib, and some specific classes from it for creating shapes like polygons and wedges.\n\nStart by setting up your plot. Create a figure and axes, and set the limits for the x and y axes. Turn off the axis lines.\n\nDefine a function to add problem categories to the diagram. This function should take as input a string for the category name, two numbers for the x and y positions of the problem arrows, and two more numbers for the angle of the problem annotations. It should then add an annotation to the diagram at the specified position and angle, with the category name as the text.\n\nCreate a second function to add causes to the diagram. This function should take a list of causes, two numbers for the x and y positions of the cause annotations, an optional pair of numbers to adjust the distance of the cause text from the problem arrow, and a boolean to indicate whether the cause is at the top or bottom of the diagram. It should then add an annotation for each cause at the specified position.\n\nThen, create a third function that will draw the main body of the fishbone diagram. This function should take a dictionary where the keys are problem categories and the values are lists of causes. It should draw the main spine of the fishbone diagram, the head, and the tail, and call the previous two functions to add the problem categories and causes to the diagram.\n\nFinally, create a dictionary of problem categories and their causes. The categories should be 'Product Issues', 'Marketing and Sales Strategy', 'Customer Service', 'Pricing Strategy', 'Market Conditions', and 'Internal Processes'. The causes should be as specified as follows: Product Issues: Poor Quality, Limited Range, Obsolete Features.\nMarketing and Sales Strategy: Ineffective Advertising, Poor Online Presence, Inadequate Sales Training.\nCustomer Service: Slow Response Time, Lack of Personalization, Poor After-Sales Support.\nPricing Strategy: High Prices, Inflexible Payment Options.\nMarket Conditions: Increased Competition, Changing Preferences, Economic Downturn.\nInternal Processes: Inefficient Supply Chain, Poor Communication, Limited R&D.. Call the function to draw the main body of the diagram with this dictionary as an argument, and then display the plot.\n\nThe goal is to create a fishbone diagram that visually represents potential causes of \"Decreased Sales Performance\", categorized by type.",
        "id": 38
    },
    {
        "simple_instruction": "Create a Python script using matplotlib and numpy to visualize the left ventricle's 17 segments in a 'bullseye plot', a polar representation. \nDefine a function, 'bullseye_plot', designed to plot each segment's intensity values. The function should:\nAccept parameters for the axes object, intensity values of the 17 segments, an optional list to highlight specific segments, a colormap (with a default setting), and an optional data normalizer.\nAutomatically handle the flattening of data and setting defaults for unspecified parameters.\nUtilize radii to differentiate between segment layers and ensure the plot is free from gridlines and labels.\nApply a color scheme to represent intensity values and indicate segment borders, with emphasized borders for highlighted segments.\nThe script must then create a representative dataset ranging from 1 to 17 to simulate intensity values.\nConstruct a layout with three polar subplots, each demonstrating a unique aspect of the 'bullseye_plot' function:\nThe first subplot should display the standard visualization.\nThe second should incorporate a different color scheme.\nThe third should emphasize segments [3, 5, 6, 11, 12, 16] in bold, showcasing the function's ability to highlight specific areas, and have a discrete intervals in color coding.\nInclude horizontal colorbars beneath each corresponding bullseye plot, with clear indications of the represented values.\nConclude with a command to display the final plot.",
        "expert_instruction": "Create a Python script that employs the necessary libraries to generate a bullseye plot that represents the left ventricle's 17 segments. Start by importing the required libraries and defining a function that will create the bullseye plot. This function should accept parameters for the axes, data, segments to emphasize, colormap, and normalizer.\n\nThe function should first flatten the data and set default values for the segments to emphasize and the normalizer if they are not provided. Then, it should set the radii to differentiate between segment layers, remove x and y tick labels, and remove the grid. \n\nNext, it should fill in the segments using a loop and the appropriate method, applying a color scheme to represent intensity values. After that, it should draw the segment borders, with emphasized borders for highlighted segments. \n\nOutside the function, create synthetic data using a method that generates a sequence of numbers from 1 to 17 to simulate intensity values. Then, create a figure and axes with desired dimensions using methods from the plotting library. Set the colormap and norm to correspond to the data for which the colorbar will be used. \n\nCreate three subplots, each demonstrating a unique aspect of the 'bullseye_plot' function. The first subplot should display the standard visualization. The second should incorporate a different color scheme. The third should emphasize certain segments, showcasing the function's ability to highlight specific areas. Include colorbars corresponding to the data on each subplot, with clear indications of the represented values.\n\nFinally, create the 17 segment model using the bullseye plot function and display the plot using a method from the plotting library.",
        "id": 39
    },
    {
        "simple_instruction": "Create a Python script to generate a radar chart displaying average temperature profiles for five cities - New York, London, Tokyo, Sydney, and Cairo - across all months. Use the following dataset and guidelines:\nDataset:\naverage_temperatures = [\n    [0, 1, 5, 11, 16, 21, 24, 23, 19, 14, 8, 3],  # New York\n    [4, 5, 7, 9, 13, 16, 19, 18, 15, 11, 7, 5],   # London\n    [5, 6, 9, 14, 19, 22, 26, 27, 23, 18, 12, 8], # Tokyo\n    [23, 23, 22, 20, 17, 14, 13, 15, 17, 19, 21, 22], # Sydney\n    [13, 14, 17, 20, 24, 27, 28, 28, 26, 22, 18, 15]  # Cairo\n]\nFill each plot with a different color to represent each city's temperature profile.\nInclude a legend in the top-right to identify the cities.\nTitle the chart to reflect its content, such as \"Average Monthly Temperatures of Five Cities.\"\nUse the months as labels for the spokes of the radar chart.\nThe script should result in a radar chart that compares the average monthly temperatures of New York, London, Tokyo, Sydney, and Cairo, making it easy to visualize and compare the climate patterns of these cities.",
        "expert_instruction": "Data Description: Begin by instructing the LLM to define a dataset representing average monthly temperatures for several cities throughout the year. Specifically, ask for:\n\nA list named average_temperatures containing sub-lists for each city. Each sub-list should have 12 values representing the average temperature for each month. For example, include the following data:\nNew York: [0, 1, 5, 11, 16, 21, 24, 23, 19, 14, 8, 3]\nLondon: [4, 5, 7, 9, 13, 16, 19, 18, 15, 11, 7, 5]\nTokyo: [5, 6, 9, 14, 19, 22, 26, 27, 23, 18, 12, 8]\nSydney: [23, 23, 22, 20, 17, 14, 13, 15, 17, 19, 21, 22]\nCairo: [13, 14, 17, 20, 24, 27, 28, 28, 26, 22, 18, 15]\nA list named cities containing the names of the cities: [\"New York\", \"London\", \"Tokyo\", \"Sydney\", \"Cairo\"].\nA list named months for the months of the year: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"].\nRadar Chart Initialization: Instruct to import numpy and matplotlib.pyplot, and set up a radar chart using a polar subplot. Mention calculating angles for each axis to form a full circle.\n\nPlotting Helper Function: Ask for a function that takes a city name, its temperature values, and a color to plot these values on the radar chart with some transparency.\n\nPlot Data for Each City: Guide the LLM to use the plotting function to add each city's data to the radar chart. Each city should be represented with a different color.\n\nChart Customization: Request adding a legend with city names and a descriptive title like 'Average Monthly Temperatures of Five Cities'.\n\nAxis Configuration: Instruct on setting the theta offset and direction for proper orientation.\n\nAxes Labeling: Guide to set the x-tick labels to the month names, aligning them with the respective axes.\n\nSaving and Displaying the Figure: Conclude by asking to include code for saving the figure as a PNG file and displaying the chart.",
        "id": 40
    },
    {
        "simple_instruction": "Create a Python script to generate a Sankey diagram titled \"Flow Diagram of a Gadget.\" The diagram should visually represent the operation of a gadget through several phases with the following specifications:\n\nThe diagram must have sequential phases labeled 'Phase 1', 'Phase 2', 'Phase 3', 'Phase 4', 'Phase 5', and 'Hurray!'.\nEach phase should have flow values indicating the transition magnitude between phases. For instance, the flow could be represented by hypothetical values like 100%, 20%, 20%, 20%, 20%, and 10% for each respective phase, showing a decrease in magnitude as the gadget progresses through each phase.\nThe orientation and path lengths of the flows should accurately represent the transition from one phase to the next.\nThe final phase, 'Success!', must be distinctively highlighted with a blue color and bold font.\nThis script should result in a clear Sankey diagram that effectively illustrates the different operational phases of the gadget and culminates in the 'Hurray!' phase",
        "expert_instruction": "\nTo create a Python code snippet using Matplotlib for generating a flow diagram of a gadget with specific features, follow these instructions:\n\nImport Required Libraries: Start by importing matplotlib.pyplot and the Sankey class from matplotlib.sankey.\n\nCreate a Figure and Axis: Initialize a Matplotlib figure and add an axis to it. Ensure that the axis has no x or y ticks and assign a title like \"Flow Diagram of a Gadget\".\n\nInitialize Sankey Diagram: Create a Sankey diagram instance. Set the following parameters: scale to a small value like 0.01, offset to 0.2, head_angle to a high value such as 120, and specify a format for numbers and a unit.\n\nAdd Flows and Labels: Add flows to the Sankey diagram. The flows should sum to zero and can include both positive and negative values, such as [100, -20, -20, -20, -20, -10]. Corresponding labels for each flow, like 'Phase 1', 'Phase 2', etc., should also be added. Set orientations for the flows and path lengths.\n\nCustomize Patch Label: Assign a patch label with a text like \"Widget A\" and customize it if needed.\n\nFinalize and Customize Diagram: Call the finish() method on the Sankey object. Customize the last text element of the first diagram to change its color to blue and make it bold. Also, make the main text of the diagram bold.\n\nDisplay the Diagram: Finally, use plt.show() to display the created Sankey diagram.",
        "id": 41
    },
    {
        "simple_instruction": "Create a Python script to generate a Sankey diagram that produces a long chain of connections with the following requirements:\n\nThe script should use a suitable library for creating visualizations.\nImplement a function named 'branch' that creates a side chain on the diagram. This function should:\nProduce side chains with alternating orientations and patch labels.\nImplement another function named 'turn' to generate a corner link in the diagram. This function should specify:\nOrientations, patch label, face color, previous value, connection, and alpha value for the corner link.\nThe diagram should have 8 chains on each side, created using the 'branch' function.\nThe overall plot should have the title \"This might seem unnecessary, but it's possible!\".\nThe initial flow in the flowchart should be set up with orientations [0, 1], patch label '0', face color red, and rotation 60 degrees.\nUse the 'branch' and 'turn' functions in a specified sequence to construct the final flowchart diagram.\nDisplay the completed Sankey diagram as the output.\nThis script should result in a detailed and structured Sankey diagram showcasing the intricate flow and connections as specified.",
        "expert_instruction": "Create a Python script that starts by importing a library that is commonly used for creating static, animated, and interactive visualizations in Python and a module from this library that is used for creating Sankey diagrams. Define a variable named 'chains_per_side' and set it to 4.\n\nCreate a function named 'branch' that takes two parameters: 'flowchart' and 'm' with a default value of 2. This function should generate a side chain. Inside this function, define a variable 'previous' that is equal to the number of diagrams in 'flowchart'. Then, create a loop that iterates over a range from 0 to 2*m with a step of 2. In each iteration, add a flow to the flowchart diagram with orientations [-1, -1], a patch label equal to the string representation of 'previous + i', a previous value of 'previous + i - 1', a connection of (1, 0), and an alpha value of 0.5. Repeat this process but with orientations [1, 1] and a patch label of 'previous + i + 1'.\n\nNext, create another function named 'turn' that takes 'flowchart' as a parameter. This function should generate a corner link. Inside this function, define 'previous' as before and add a flow to the flowchart diagram with orientations [0, 1], a patch label equal to the string representation of 'previous', a face color of 'k', a previous value of 'previous - 1', a connection of (1, 0), and an alpha value of 0.5.\n\nAfter defining these functions, create a figure and add a subplot to it with no xticks or yticks and a title of \"This might seem unnecessary, but it's possible!\". Create a flowchart diagram on this subplot with no unit. Add a flow to this diagram with orientations [0, 1], a patch label of \"0\", a face color of 'r', and a rotation of 60 degrees.\n\nThen, call the 'branch' function with 'flowchart' and 'chains_per_side' as arguments, followed by the 'turn' function with 'flowchart' as the argument. Repeat this process three more times. Finally, finish the flowchart diagram and display the plot.",
        "id": 42
    },
    {
        "simple_instruction": "Create a Python code that generates a matplotlib plot with four subplots arranged in a 2x2 mosaic. The plot should be based on a numpy array of 200 points between 0 and 4\u03c0, and its cosine multiplied by 3. The subplots should be titled 'center', 'zero', 'axes', and 'data', and the overall title of the figure should be 'Spine positions'. \n\nIn the 'center' subplot, the left and bottom spines should be positioned at the center, with the top and right spines invisible. In the 'zero' subplot, the left and bottom spines should be positioned at zero, with the top and right spines invisible. In the 'axes' subplot, the left spine should be positioned at 0.3 on the axes and the bottom spine at 0.3 on the axes, with the top and right spines invisible. In the 'data' subplot, the left spine should be positioned at 2 on the data and the bottom spine at 2 on the data, with the top and right spines invisible.",
        "expert_instruction": "Create a Python code that generates a matplotlib plot with the following characteristics:\n\n1. Start by defining a variable, let's call it `a`, which should be a numpy array of 200 points between 0 and 4\u03c0.\n2. Next, define another variable, `b`, which is the cosine of `a` multiplied by 3.\n\n3. Now, we need to create a 2x2 subplot mosaic. The keys for these subplots should be 'center', 'zero', 'axes', and 'data'. The overall title of the figure should be 'Spine positions'.\n\n4. For the 'center' subplot:\n   - Give it the title 'center'.\n   - Plot `b` against `a`.\n   - Position the left and bottom spines at the center.\n   - The top and right spines should be invisible.\n\n5. For the 'zero' subplot:\n   - Give it the title 'zero'.\n   - Plot `b` against `a`.\n   - Position the left and bottom spines at zero.\n   - The top and right spines should be invisible.\n\n6. For the 'axes' subplot:\n   - Give it the title 'axes' (0.3, 0.3).\n   - Plot `b` against `a`.\n   - Position the left spine at 0.3 on the axes.\n   - Position the bottom spine at 0.3 on the axes.\n   - The top and right spines should be invisible.\n\n7. For the 'data' subplot:\n   - Give it the title 'data' (2, 3).\n   - Plot `b` against `a`.\n   - Position the left spine at 2 on the data.\n   - Position the bottom spine at 3 on the data.\n   - The top and right spines should be invisible.\n\n8. Lastly, display the plot.",
        "id": 43
    },
    {
        "simple_instruction": "Generate a Python plot using a suitable library that includes three lines representing \"Pressure\", \"Humidity\", and \"Wind Speed\" over time. The \"Pressure\" line should be plotted with the points (0,0), (1,2), and (2,4), the \"Humidity\" line with the points (0,0), (1,4), and (2,3), and the \"Wind Speed\" line with the points (0,70), (1,40), and (2,20). Each line should be plotted on three separate y-axis with a shared x-axis representing \"Time\". The y-axis for \"Pressure\" should be limited to (0,4), for \"Humidity\" to (0,5), and for \"Wind Speed\" to (1,90). The colors of the y-axis labels and ticks should match the color of the corresponding line plots, which are blue, yellow and green. Include a legend for the three line plots and display the plot.",
        "expert_instruction": "1. Import a library in Python that is commonly used for creating static, animated, and interactive visualizations in Python.\n2. Generate a figure and a single subplot, assigning them to two variables. Adjust the right margin of the subplot to 0.75 using an appropriate method.\n3. Create two additional y-axes on the same x-axis by calling a suitable method on the variable that holds the subplot and assign them to two new variables.\n4. Adjust the position of the right spine of the second y-axis to 1.2 axes units to the right.\n5. Plot three lines on the three y-axes. The first line should be plotted on the first y-axis with the points (0,0), (1,2), and (2,4) and labeled as \"Pressure\" with color blue. The second line should be plotted on the second y-axis with the points (0,0), (1,4), and (2,3) and labeled as \"Humidity\" with color yellow. The third line should be plotted on the third y-axis with the points (0,70), (1,40), and (2,20) and labeled as \"Wind Speed\" with color green.\n6. Set the x-axis limit to (0,2) and the y-axis limit to (0,4) for the first y-axis. Label the x-axis as \"Time\" and the y-axis as \"Pressure\". For the second y-axis, set the y-axis limit to (0,5) and label it as \"Humidity\". For the third y-axis, set the y-axis limit to (1,90) and label it as \"Wind Speed\".\n7. Adjust the color of the y-axis labels to match the color of the corresponding line plots.\n8. Adjust the color of the y-axis ticks to match the color of the corresponding line plots.\n9. Add a legend to the subplot that includes the three line plots.\n10. Display the plot using an appropriate method.",
        "id": 44
    },
    {
        "simple_instruction": "Create a scatter plot of two distinct sets of random data, each containing 150 points. The first set (Group X) should be centered around (-2,-2) and visualized in blue, and the second set (Group Y) should be centered around (2,2) and visualized in orange. Label each group at their respective centers with a round white box around the text. Add a text label at the center of the plot (0,0) with the text \"Orientation\", rotated at 60 degrees, and with a purple arrow-shaped box around it. The plot should be of size 5x5 with an aspect ratio of 1, and the x and y limits should be between -5 and 5.",
        "expert_instruction": "Create a Python script that produces a scatter plot using necessary libraries. To ensure the results are consistent, set a random seed.\n\nConstruct a figure and an axes of size 5x5 and adjust the aspect ratio to 1. Generate two distinct sets of random data, each containing 150 points. The first set (Group X) should be centered around (-2,-2) and the second set (Group Y) should be centered around (2,2). \n\nVisualize these two sets of data on the axes, using blue color for Group X and orange color for Group Y. Add labels for each group at their respective centers, with a round white box around the text. \n\nNext, add a text label at the center of the plot (0,0) with the text \"Orientation\", rotated at 60 degrees, and with a purple arrow-shaped box around it. Adjust the padding of the box to 0.7. \n\nLastly, set the x and y limits of the plot to be between -5 and 5, and display the plot.",
        "id": 45
    },
    {
        "simple_instruction": "Generate a Python code that creates a subplot figure with six different streamplots. The first streamplot should have varying density along a streamline, the second should have varying color along a streamline using the 'summer' colormap, the third should have varying line width along a streamline, the fourth should control the starting points of the streamlines and display these points with blue symbols, the fifth should have a mask and display the mask using imshow, and the last should have unbroken streamlines. The figure should be 8x10 with 3 rows and 2 columns, and the height ratios should be 1, 1, and 2. The streamplots should be based on a meshgrid with a range from -4 to 4 with 150 complex numbers, and the velocity should be calculated as the square root of the sum of squares of two given mathematical expressions:\nU = -1 - X**2 + Y\nV = 1 + X - Y**2.",
        "expert_instruction": "Instruct the LLM to generate a Python code that begins by importing necessary libraries for plotting and numerical computations. Define a variable 'z' as 4 and create a meshgrid 'P' and 'Q' using a numerical computation library with a range from negative 'z' to 'z' with 150 complex numbers. Define 'A' and 'B' as given mathematical expressions and calculate the velocity as the square root of the sum of squares of 'A' and 'B'.\n\nNext, create a subplot figure with 3 rows and 2 columns, with a size of 8x10 and height ratios of 1, 1, and 2. Flatten the axes for easier manipulation. \n\nOn the first subplot, create a streamplot with varying density along a streamline and set its title as 'Varying Density'. On the second subplot, create a streamplot with varying color along a streamline using the 'summer' colormap and set its title as 'Varying Color'. Add a colorbar to this subplot. \n\nOn the third subplot, create a streamplot with varying line width along a streamline and set its title as 'Varying Line Width'. \n\nOn the fourth subplot, control the starting points of the streamlines and display these points with red symbols. Set its title as 'Controlling Starting Points' and add a colorbar. \n\nOn the fifth subplot, create a streamplot with a mask and display the mask using imshow. Set its title as 'Streamplot with Masking' and set the aspect ratio as 'equal'. \n\nOn the last subplot, create a streamplot with unbroken streamlines and set its title as 'Streamplot with unbroken streamlines'. \n\nFinally, adjust the layout for a tight fit and display the plot.",
        "id": 46
    },
    {
        "simple_instruction": "Create a Python script using Matplotlib and NumPy to visualize a comparison between two methods of contour plotting for irregularly spaced data. The first method should involve interpolating the data onto a regular grid and then creating a contour plot. The second method should directly use triangular contour plotting for an unstructured grid.\n\nIn the script, start by using NumPy to create 300 points with x and y coordinates randomly distributed within a range of -3 to 3. For the z-values, apply a function, x times the exponential of the negative square of x and y, to these points to simulate real-world data. Use these points to simulate a scenario of irregularly spaced data. Then, for the first method, interpolate these data points onto a regular grid with 100 * 200 grid points and create a contour plot from this grid. For the second method, apply triangular contour plotting directly to the irregular data.\n\nEnsure the script includes two plots in a single figure of two rows, one row for each method. Use cmap=\"RdBu_r\" and display a filled contour plot with 14 levels. Also display contour lines with 14 levels with linewidth of 0.5 and line color of black. Add colorbars for clarity and mark the original data points on both plots. Also, include titles that clearly distinguish between the two methods and mention the number of data points and grid points used. The plots should be visually appealing and easy to compare.",
        "expert_instruction": "Generate a Python script that begins by importing the necessary libraries for data visualization and numerical computations. Also, import a specific module from the data visualization library that is used for triangular grid functions. Set the random seed of the numerical computation library to 12345678 and define three variables, let's call them total_points, grid_points_x, and grid_points_y, and assign them the values 300, 150, and 300 respectively.\n\nCreate two arrays, let's name them array_x and array_y, each with 300 random values ranging from -3 to 3. Then, create a third array, let's call it array_z, which is the product of array_x and the exponential of the negative of the square of array_x and array_y.\n\nNext, create a figure with two subplots and assign them to three variables, let's call them figure, subplot1, and subplot2. For the first subplot, interpolate the data (array_x, array_y) on a grid defined by grid_x and grid_y, which are linearly spaced arrays from -3.1 to 3.1 with grid_points_x and grid_points_y points respectively. Use the triangular grid functions to perform the interpolation. Then, plot a contour and filled contour plot on subplot1 using the interpolated data. Add a colorbar, scatter plot of the original data points, set the x and y limits to -3 and 3, and add a title.\n\nFor the second subplot, directly supply the unordered, irregularly spaced coordinates to the functions to create a contour and filled contour plot. Add a colorbar, scatter plot of the original data points, set the x and y limits to -3 and 3, and add a title. Finally, adjust the space between the subplots to 0.5 and display the plot.",
        "id": 47
    },
    {
        "simple_instruction": "Create a Python script that generates a 1D random walk with a small fraction of cosine waves. The script should plot the series, convert the series into a histogram, and then plot the histogram with both a log and linear color scale. The plot should reveal the hidden signal in the data, and the color scales should be adjusted to make the signal more visible. The plots should be arranged in three rows and one column.",
        "expert_instruction": "Sure, here is the modified instruction:\n\n\"Let's create a Python script that starts by bringing in the necessary modules. We'll need one for timing our operations, one for creating plots, and one for numerical operations.\n\nNext, we'll create a subplot with three rows and a figure size of 6x8 using a layout that is constrained.\n\nTo ensure our results are consistent, we'll set a random seed. Now, we're going to generate some data for a 1D random walk with a small fraction of cosine waves. We'll create 500 series with 200 points each and a Signal to Noise Ratio of 0.15. We'll use a function to generate evenly spaced numbers over the range of 0 to 6*pi.\n\nWe'll generate unbiased Gaussian random walks and cosine signals with a small random offset. \n\nWe'll then plot the series using a function that allows us to set a small value of alpha. This will make it difficult to observe the cosine behavior due to the number of overlapping series. Also, we'll note the time it takes to run this because of the number of individual artists that need to be generated. \n\nNext, we'll convert the multiple time series into a histogram. This will make the hidden signal more visible and is also a quicker procedure. We'll interpolate between the points in each time series. \n\nWe'll plot the points in a 2D histogram with a log color scale. It should be evident that there is some kind of structure under the noise. We can tune vmax to make the signal more visible. We'll use the 'plasma' colormap and adjust the extremes. \n\nFinally, we'll plot the same data but on a linear color scale. We'll note the time it takes to run this. We'll display the plot using a function that shows the plot.\n\nRemember, the goal is to create a Python script that generates a 1D random walk with a small fraction of cosine waves, plots the series, converts the series into a histogram, and then plots the histogram with both a log and linear color scale.\"",
        "id": 48
    },
    {
        "simple_instruction": "Create a Python script that generates two types of box plots - a standard box plot and a notched box plot. The plots should be based on four sets of 150 normally distributed random numbers, each with a different standard deviation ranging from 2 to 5. The data sets should be labeled as 'y1', 'y2', 'y3', and 'y4'. \n\nThe plots should be arranged in one row and two columns. The first subplot should be a standard box plot, while the second subplot should be a notched box plot. Both plots should have the boxes vertically aligned, filled with different colors, and labeled according to the data set labels. The titles of the subplots should be 'Standard box plot' and 'Notched box plot' respectively.\n\nThe boxes in both plots should be filled with different colors: orange for 'y1', purple for 'y2', yellow for 'y3', and cyan for 'y4'. Both plots should have horizontal grid lines for better readability. The x-axis should be labeled as 'Four separate samples' and the y-axis as 'Measured values'.",
        "expert_instruction": "Craft a Python script that utilizes the matplotlib and numpy libraries to produce two variations of box plots: a standard box plot and a notched box plot. Start by importing the necessary modules from matplotlib and numpy. Then, generate some random test data by setting a seed for the numpy random number generator and creating four sets of 150 normally distributed random numbers, each with a different standard deviation ranging from 2 to 5. Label these data sets as 'y1', 'y2', 'y3', and 'y4'.\n\nNext, construct a figure with two subplots arranged in one row and two columns, and adjust the figure size to 10 by 5. On the first subplot, construct a standard box plot of the test data. Ensure the boxes are vertically aligned, filled with color, and labeled according to the labels you created earlier. Set the title of this subplot to 'Standard box plot'.\n\nOn the second subplot, construct a notched box plot of the same data, with the same specifications as the first plot, but with the notch shape enabled. Set the title of this subplot to 'Notched box plot'.\n\nThen, fill the boxes in both plots with different colors: orange for 'y1', purple for 'y2', yellow for 'y3', and cyan for 'y4'. Add horizontal grid lines to both plots for better readability. Label the x-axis as 'Four separate samples' and the y-axis as 'Measured values'. Finally, display the plots using the appropriate function.",
        "id": 49
    },
    {
        "simple_instruction": "Generate two polar plots with error bars using a numerical array named 'alpha' that spans from 0 to 4\u03c0 with a step of \u03c0/2. For both plots, use 'alpha' for the x values and the square root of 'alpha' divided by \u03c0, subtracted by 0.2, for the y values. \n\nFor the first plot, set the x error to 0.5, the y error to 0.2, the cap size to 7, the format to \"o\", and the color to \"seagreen\". Title this plot as \"Beautiful polar error bars\".\n\nFor the second plot, set the x error to 0.5, the y error to 20.2, the cap size to 7, the format to \"o\", and the color to \"orangered\". Title this plot as \"Huge radius error bars\". \n\nBoth plots should be 10x10 in size.",
        "expert_instruction": "\"\"\"\nInstruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries for plotting and numerical operations.\n2. Construct a numerical array named 'alpha' that spans from 0 to 4\u03c0 with a step of \u03c0/2.\n3. Define a variable 's' as the square root of 'alpha' divided by \u03c0, then subtract 0.2 from the result.\n4. Generate a figure object with a size of 10x10 using the figure function from the plotting library.\n5. Add a subplot to the figure with a polar projection.\n6. Draw an error bar on the polar plot with 'alpha' and 's' as the x and y values respectively. Set the x error to 0.5, the y error to 0.2, the cap size to 7, the format to \"o\", and the color to \"seagreen\".\n7. Assign the title of the plot as \"Beautiful polar error bars\".\n8. Render the plot using the appropriate function.\n9. Create another figure object with the same size of 10x10.\n10. Add another subplot to the figure with a polar projection.\n11. Draw an error bar on the polar plot with 'alpha' and 's' as the x and y values respectively. Set the x error to 0.5, the y error to 20.2, the cap size to 7, the format to \"o\", and the color to \"orangered\".\n12. Assign the title of the plot as \"Huge radius error bars\".\n13. Finally, render the plot using the appropriate function.\n\"\"\"",
        "id": 50
    },
    {
        "simple_instruction": "Create a visual representation of a path using Python. The path should be represented as a series of possibly disconnected, possibly closed, line and curve segments. The path should include the following steps:\n- Start at point (2.5, -1.5)\n- Create a cubic Bezier curve to point (1.2, -0.8)\n- Create another cubic Bezier curve to point (-2.3, 1.8)\n- Create yet another cubic Bezier curve to point (0.5, 2.2)\n- Draw a line to point (1.1, 0.9)\n- Create a cubic Bezier curve to point (2.8, 2.9)\n- Create another cubic Bezier curve to point (3.5, 0.1)\n- Create yet another cubic Bezier curve to point (2.5, -0.3)\n- Close the path at point (2.5, -1.5)\n\nThe path should be filled with blue color with a transparency of 0.5. The vertices of the path should be plotted as yellow dots connected by lines. The plot should have a grid and the aspect ratio should be equal.",
        "expert_instruction": "Create a visual representation of a path using a Python script. You'll need to use a library that's commonly used for creating static, animated, and interactive visualizations in Python.\n\nFirst, you'll need to import a module from this library that provides a MATLAB-like interface which is generally easy to get started with for simple plots. Also, import two modules from the same library which are used for creating shapes and paths respectively.\n\nNow, create a figure and a set of subplots. This will return a figure and axes object(s). \n\nNext, create a variable that will represent a series of possibly disconnected, possibly closed, line and curve segments. \n\nAfter that, define a list of tuples. Each tuple in the list should represent a step in the path to be plotted. The first element of each tuple should be a path command, such as moving to a point, creating a cubic Bezier curve, drawing a line to a point, or closing a polygon. The second element of each tuple should be a pair of coordinates. For instance, you can use the following data:\n- Move to point (2.5, -1.5)\n- Create a cubic Bezier curve to point (1.2, -0.8)\n- Create another cubic Bezier curve to point (-2.3, 1.8)\n- Create yet another cubic Bezier curve to point (0.5, 2.2)\n- Draw a line to point (1.1, 0.9)\n- Create a cubic Bezier curve to point (2.8, 2.9)\n- Create another cubic Bezier curve to point (3.5, 0.1)\n- Create yet another cubic Bezier curve to point (2.5, -0.3)\n- Close the polygon at point (2.5, -1.5)\n\nNow, separate the list of tuples into two separate lists, one for the path commands and one for the coordinates, using a function that makes iterables out of the elements of the tuples.\n\nCreate a path object by passing the coordinates and path commands to the constructor of the path object. \n\nCreate a shape object by passing the path object to the constructor of the shape object. Set the color inside the shape to blue and its transparency to 0.5. \n\nAdd the shape to the axes object using the appropriate method. \n\nPlot the vertices of the path as yellow dots connected by lines by calling the appropriate method on the axes object. \n\nTurn on the grid for the axes object by calling its appropriate method. \n\nSet the aspect of the axes object to equal by calling its appropriate method with the argument 'equal'. \n\nFinally, display the plot by calling the appropriate method from the plotting library.",
        "id": 51
    },
    {
        "simple_instruction": "Generate a plot with six distinct lines using the 'ggplot' style sheet. Each line should be a function of a variable y (ranging from -5 to 5), a cosine function of y, and a random number. The lines should vary based on the following conditions: \n\n1. The sum of the cosine function, y, and the random number.\n2. The sum of the cosine function, one-third of y, and the random number.\n3. The sum of the cosine function, three times y, and the random number.\n4. The sum of the cosine function, negative one-third of y, and the random number.\n5. The sum of the cosine function, negative three times y, and the random number.\n6. The sum of the cosine function and the random number.\n\nEnsure the consistency of the results by setting the random seed to 123456789. Title the plot as \"'ggplot' style sheet\".",
        "expert_instruction": "Commence by incorporating the necessary libraries for data visualization and numerical operations in Python. Choose the plot style to be 'ggplot'. Generate a variable y that is a linear space from -5 to 5. To ensure the consistency of the results, set the random seed to 123456789.\n\nCreate a figure and axes using the function that allows you to create multiple layouts of subplots on a single figure. On these axes, plot six distinct lines. Each line should be a function of y, a cosine function of y, and a random number. \n\nFor the first line, it should be the sum of the cosine function, y, and the random number. The second line should be the sum of the cosine function, one-third of y, and the random number. The third line should be the sum of the cosine function, three times y, and the random number. The fourth line should be the sum of the cosine function, negative one-third of y, and the random number. The fifth line should be the sum of the cosine function, negative three times y, and the random number. The sixth line should be the sum of the cosine function and the random number.\n\nSet the title of the axes to \"'ggplot' style sheet\". Lastly, display the plot using the function that renders all figure windows.",
        "id": 52
    },
    {
        "simple_instruction": "Create a Python script that generates a 2x2 grid of subplots using a specific plotting library and a numerical computing library. \n\nIn the first subplot, construct a scatter plot with coordinates generated from a uniform distribution.\n\nFor the second subplot, draw cosine curves with colors from the default color cycle. The x values should be evenly distributed over a range and the y values should be the cosine of x plus a shift value.\n\nIn the third subplot, create two bar graphs with random integer y values. The x values should be the integers from 0 to 6. The second bar graph should be shifted to the right by the width of the bars. Label the x-axis with the letters 'a' through 'g'.\n\nIn the fourth subplot, draw squares at random positions. The colors of the squares should come from the default color cycle. Ensure the aspect ratio of the plot is equal.\n\nFinally, display the plots.",
        "expert_instruction": "Create a Python script that generates a 2x2 grid of subplots using a specific plotting library and a numerical computing library. Use the 'ggplot' style for the plots and ensure the random state is set to 123456 for consistency.\n\nIn the first subplot, construct a scatter plot using the 'x' marker. The x and y coordinates for the scatter plot should be generated from a uniform distribution with a size of 300.\n\nFor the second subplot, draw cosine curves with colors from the default color cycle. The x values should be evenly distributed over a range of 3*pi. The y values should be the cosine of x plus a shift value, where the shift values are evenly distributed over the same range as x. Ensure the margins of the plot are set to 0.\n\nIn the third subplot, create two bar graphs with random integer y values between 10 and 50. The x values should be the integers from 0 to 6. The width of the bars should be 0.3, and the second bar graph should be shifted to the right by the width of the bars. The color of the second bar graph should be the fourth color in the default color cycle. Label the x-axis with the letters 'a' through 'g'.\n\nIn the fourth subplot, draw squares at random positions with side length of 0.4. The colors of the squares should come from the default color cycle. Ensure the aspect ratio of the plot is equal and the margins are set to 0.\n\nFinally, display the plots.",
        "id": 53
    },
    {
        "simple_instruction": "Generate a Python code to plot the hyperbolic tangent function for a numerical array of 200 evenly spaced numbers between -20 and 20. The plot should include horizontal lines at y=0, y=1.0, and y=-1.0, and a solid vertical line at x=0. Additionally, draw a line through the point (0, 0.5) with a slope of 0.5. The function should be labeled and the x-axis should be limited from -20 to 20. Include a legend with a fontsize of 14.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries for plotting graphs and performing numerical operations.\n2. Create a variable 'x' and assign it a numerical array of 200 evenly spaced numbers between -20 and 20.\n3. Create a variable 'func' and assign it the hyperbolic tangent function applied to 'x'.\n4. Draw a horizontal line at y=0 with a dashed black line.\n5. Draw another horizontal line at y=1.0 with a dashed black line.\n6. Draw a third horizontal line at y=-1.0 with a dashed black line.\n7. Draw a vertical line at x=0 with a grey color.\n8. Draw a line starting from the point (0, 0.5) with a slope of 0.5 and a dashed black line.\n9. Plot the 'func' variable against 'x' with a linewidth of 2 and label it as the hyperbolic tangent function.\n10. Set the x-axis limit from -20 to 20.\n11. Label the x-axis as \"x\".\n12. Add a legend with a fontsize of 14.\n13. Finally, display the plot.",
        "id": 54
    },
    {
        "simple_instruction": "Create a Python script to visualize a 3D dataset in a 3D box surface plot where data values are plotted on the volume surfaces:\n\n- The dataset should be derived from a 3D grid with dimensions set to Px=100, Py=300, and Pz=500. Use the formula (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1) to generate the data.\n- The plot should include contour surfaces based on the Px, Py, and Pz parameters.\n- Customize the edges of the contours with specific color '0.4', linewidth of 1, and zorder of 1e3.\n- Label the x, y, and z axes as 'Px [km]', 'Py [km]', and 'Pz [m]' respectively.\n- Set the z-axis ticks to [0, -150, -300, -450].\n- Include a colorbar in the plot with the label 'Parameter [units]'.\n- Adjust the view angle and zoom level of the plot for clear and optimal visualization.\n\nThe script should result in a 3D plot that effectively represents the calculated dataset, with appropriate labels and visual enhancements for easy interpretation.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for data visualization and numerical operations.\n2. Establish dimensions Px, Py, and Pz as 100, 300, and 500 respectively. Construct a 3D grid using a function from the numerical library with these dimensions.\n3. Generate a dataset using the formula (((Px+100)**2 + (Py-20)**2 + 2*Pz)/1000+1).\n4. Define a dictionary 'params' with keys 'vmin', 'vmax', and 'levels'. The values should be the minimum and maximum of the data, and a linearly spaced array from the minimum to the maximum of the data with 12 steps respectively.\n5. Create a 3D plot with a figure size of 6x5 using the visualization library's function to create a figure and add a subplot.\n6. Plot contour surfaces on the 3D plot using a function from the visualization library. Do this three times, each time with different parameters for Px, Py, and Pz.\n7. Set the limits of the plot to be the minimum and maximum of Px, Py, and Pz.\n8. Plot edges on the 3D plot using a function from the visualization library with parameters for color '0.4', linewidth of 1, and zorder of 1e3.\n9. Set the labels for the x, y, and z axes as 'Px [km]', 'Py [km]', and 'Pz [m]' respectively. Also, set the zticks to [0, -150, -300, -450].\n10. Set the view angle and zoom of the plot using functions from the visualization library.\n11. Add a colorbar to the figure with a label 'Parameter [units]'.\n12. Finally, display the figure using a function from the visualization library.",
        "id": 55
    },
    {
        "simple_instruction": "Create a Python script that generates a noisy signal from a logarithmic function, a cosine wave, and a constant. The signal should be plotted against a variable that ranges from 0.0 to 10.0 with an increment of 0.2 using the ^ marker. The plot should have two subplots in one row: one drawing vertical lines at each point of the variable starting from the x axis to the height of the value of the function at said point of the variable and two additional green vertical lines at points 3 and 6 through the whole figure, and the other demonstrating horizontal lines at each point of the variable starting from the y axis to the length of the value with the axes flipped. The plots should be displayed in a figure of size 12 by 6.",
        "expert_instruction": "Create a Python script that begins by importing the necessary libraries for data visualization and numerical computations. Establish a fixed random state to ensure the results can be reproduced, using the seed value 123456.\n\nNext, construct a variable 'x' that ranges from 0.0 to 10.0 with an increment of 0.2. Then, create a signal 'y' that is the sum of a logarithmic function, a cosine wave, and a constant 2.\n\nAfterwards, generate a figure with two subplots arranged in a single row and two columns, with a figure size of 12 by 6. Name the subplots 'subplot1' and 'subplot2'. \n\nOn the 'subplot1', plot the signal against the 'x' variable, using '^' as the marker. Add vertical lines at each 'x' point from 0 to the signal value. Also, add two green vertical lines at 'x' points 3 and 6 that span the height of the plot. Set the x-label to 'x-axis' and the title to 'Vertical lines demonstration'.\n\nOn the 'subplot2', plot the signal against the 'x' variable, using '^' as the marker, but with the axes flipped compared to 'subplot1'. Add horizontal lines at each 'x' point from 0 to the signal value, with a line width of 2. Set the x-label to 'x-axis' and the title to 'Horizontal lines demonstration'.\n\nLastly, display the plot.",
        "id": 56
    },
    {
        "simple_instruction": "Create a contour plot in Python with a size of 6x6. The plot should contain four different contours, one for the objective function and three for the constraints. Generate boundary curves of the constraint functions. Distinguish the valid and invalid sides of the constraint boundaries using TickedStrokes. The objective function is the sum of the squares of two variables, minus thrice each of the variables, plus 3. The constraints are defined by three different formulas. The levels for the objective function should be at 0.02, 0.2, 1, 2, 3, 6, 12, 24 and should be colored black. The levels for the constraints should be at 0 and should be colored 'sandybrown', 'orangered', and 'mediumblue' respectively. The contours should be labeled with a format of \"%2.1f\". The x and y limits of the axes should be set to 0 and 5.",
        "expert_instruction": "Create a Python script that generates a contour plot using necessary libraries. Begin by importing the required libraries and initializing a figure and axes with a size of 6x6. Define two variables, let's call them 'px' and 'py', with values 150 and 155 respectively.\n\nCreate two survey vectors, let's name them 'xvec' and 'yvec', using a function that generates evenly spaced numbers over a specified range, with ranges from 0.002 to 5.0. Then, create two survey matrices, let's call them 'x1' and 'x2', using a function that returns coordinate grids from coordinate vectors with 'xvec' and 'yvec' as inputs. \n\nNext, calculate the values for the plot. Define a variable, let's call it 'obj', as the sum of the squares of 'x1' and 'x2', minus thrice each of 'x1' and 'x2', plus 3. Define three more variables, let's call them 'g1', 'g2', and 'g3', with the formulas -(4*'x1' + 'x2' - 6.5), -('x1' + 3*'x2' - 5.5), and 1.0 + 'x1'**-3 - 'x2' respectively.\n\nCreate a contour plot of 'obj' on the axes with levels at 0.02, 0.2, 1, 2, 3, 6, 12, 24 and black color. Label the contours with a format of \"%2.1f\" and use_clabeltext set to True. \n\nCreate three more contour plots for 'g1', 'g2', and 'g3' with levels at 0 and colors 'sandybrown', 'orangered', and 'mediumblue' respectively. Apply path effects to these contours with angles of 145, 70, and a spacing of 8 respectively.\n\nSet the x and y limits of the axes to 0 and 5. Finally, display the plot.",
        "id": 57
    },
    {
        "simple_instruction": "Create a Python script to generate a 2x2 subplot with the following specifications:\n\nFirst Row:\n\nDisplay horizontal and vertical event plots using a random data array of size 8x70.\nSet specific colors for each plot, adjust line offsets, and define line lengths.\nFor instance, the horizontal plot could use a color like 'navy' with a line offset of 1 and line length of 0.5, while the vertical plot could use 'darkgreen', a line offset of 1, and line length of 0.5.\nSecond Row:\n\nShow horizontal and vertical event plots using random gamma-distributed data with a shape parameter of 5 and size 80x70.\nUse different color, line offset, and line length parameters compared to the first row. For example, the horizontal plot might have 'crimson' color, line offset of 2, and line length of 0.7, and the vertical plot could use 'darkorange', line offset of 2, and line length of 0.7.\nGeneral Settings:\n\nSet the font size to 8.0 for all text in the graphs for clarity.\nUse a fixed seed for the random number generator to ensure consistency in results.",
        "expert_instruction": "1. Start by importing the necessary libraries. You'll need one for plotting graphs and another for numerical operations.\n2. Adjust the font size of the graphing library to 8.0 for better visibility.\n3. To ensure the results are consistent, set a fixed seed for the random number generator. Use the seed value 12345678.\n4. Generate a random data array of size 8x70 using the random number generation method from the numerical library.\n5. Define colors for the first row plots. For instance, the horizontal plot could use a color like 'navy' and the vertical plot could use 'darkgreen'.\n6. Define line offsets and line lengths for the first row plots. For instance, both plots could have a line offset of 1 and line length of 0.5.\n7. Create a subplot with 2 rows and 2 columns using the subplots method from the graphing library.\n8. On the first subplot, create a horizontal event plot using the random data, color, line offset, and line length defined earlier.\n9. On the second subplot, create a vertical event plot using the same data, color, line offset, and line length.\n10. Generate another set of random data using the random gamma method from the numerical library with shape parameter 5 and size 80x70.\n11. Define colors for the second row plots. For instance, the horizontal plot could use a color like 'crimson' and the vertical plot could use 'darkorange'.\n12. Define line offsets and line lengths for the second row plots. For instance, both plots could have a line offset of 2 and line length of 0.7.\n13. On the third subplot, create a horizontal event plot using the new random data and the new parameters.\n14. On the fourth subplot, create a vertical event plot using the new random data and the new parameters.\n15. Finally, display the plot using the show method from the graphing library.",
        "id": 58
    },
    {
        "simple_instruction": "Create a Python script for generating a plot with three distinct subplots, each demonstrating different transformations and plot types:\n\nUse a fixed random seed 12345678 to ensure consistent results across runs.\nImplement three separate functions, each taking a figure and a rectangle as inputs:\nThe first function creates a subplot with a transformation scaling by 3 in the x-direction and 2 in the y-direction, and a 45-degree rotation to the spines. It should return the subplot and its auxiliary axes.\nThe second function generates a subplot that displays the upper left quadrant of a full polar grid using polar coordinates with custom locators and formatters, returning the subplot and its auxiliary axes.\nThe third function creates a subplot with a composite transformation (including a 45 degree rotation, log scaling, and polar transformation which shows half of a full polar grid), adjusts axis directions and visibility, sets axis labels, and returns the subplot and its auxiliary axes.\nUse the first function to add a bar plot with specific x and y values.\nUtilize the second function to include a scatter plot with random theta and radius values.\nEmploy the third function to insert a scatter plot with random theta and radius values.\nDisplay the plot.\nThis script should result in a complex plot featuring different types of transformations and plotting methods.",
        "expert_instruction": "Could you help me create a Python script that does the following?\n\n1. First, we need to import some libraries. We'll need one for creating plots, one for numerical operations, and a few others for creating different types of transformations and for working with axes and grids.\n\n2. To ensure that our results are consistent every time we run the script, let's set a seed for the random number generator in our numerical operations library.\n\n3. Now, let's define a function that takes a figure and a rectangle as arguments. This function should create a transformation that scales by 3 in the x-direction and 2 in the y-direction, and rotates by 45 degrees. It should then create a helper for the grid with the transformation and certain extremes, and add a subplot to the figure with the grid helper. The function should return the subplot and its auxiliary axes.\n\n4. Next, let's define another function that also takes a figure and a rectangle as arguments. This function should create a polar transformation and a grid helper with the transformation, custom locators, and formatters. It should add a subplot to the figure with the grid helper and return the subplot and its auxiliary axes. This subplot should display the upper left quadrant of a full polar grid.\n\n5. Let's define a third function that takes a figure and a rectangle as arguments. This function should create a composite transformation that includes a 45-degree rotation, log scaling, and a polar transformation. It should create a grid helper with the transformation, custom locators, and formatters, and add a subplot to the figure with the grid helper. The function should adjust the axis directions and visibility, set axis labels, and return the subplot and its auxiliary axes.\n\n6. Now, let's create a figure with a specific size and subplot adjustments.\n\n7. We'll call the first function with the figure and a rectangle, and create a bar plot on the auxiliary axes. Let's use the numbers 1, 2, 3, and 4 for the x-values, and the numbers 4, 3, 2, and 4 for the y-values.\n\n8. Then, we'll call the second function with the figure and a rectangle, and create a scatter plot on the auxiliary axes with random theta and radius values. Let's use 20 random theta values between 0 and half pi, and 20 random radius values between 1 and 2.\n\n9. Finally, we'll call the third function with the figure and a rectangle, and create a scatter plot on the auxiliary axes with random theta and radius values. Let's use 20 random theta values between 120 and 210 degrees, and 20 random radius values between 0 and 20000.\n\n10. To finish, let's display the plot using the function from our plotting library that shows the current figure.",
        "id": 59
    },
    {
        "simple_instruction": "Generate a Python script that creates two 3D plots. The first plot should be a surface plot of a function defined in a parameter space of variables p and q, ranging from 0 to 4\u03c0 and -1 to 1 respectively. The function should map p, q pairs to x, y, z triples using the given formula. The plot should use a colormap that ranges from dark blue to light yellow and the z limit should be set to -2 and 2.\n\nThe second plot should be a surface plot of a function defined in a parameter space of radii and angles, ranging from 0.5 to 1.5 and 0 to 4\u03c0 respectively. The function should map radius, angle pairs to x, y, z points. The plot should use a colormap that ranges from dark red to light blue. Triangles where the square of the mean x and y coordinates is less than the square of the minimum radius should be masked off.",
        "expert_instruction": "Generate a Python script that does the following:\n\n1. Start by importing the necessary libraries. You will need a library for plotting, a library for numerical operations, and a library for triangulation.\n\n2. Create a figure with a specific aspect ratio using the plotting library's function.\n\n3. For the first plot:\n   - Create a mesh in the space of parameterisation variables p and q. Let p range from 0 to 4\u03c0 and q range from -1 to 1. Make sure to flatten the p and q arrays.\n   - Define a mapping that takes a p, q pair and returns an x, y, z triple. Use the formula x = (2 + 0.5 * q * cos(p / 2.0)) * cos(p), y = (2 + 0.5 * q * cos(p / 2.0)) * sin(p), and z = 0.5 * q * sin(p / 2.0).\n   - Triangulate the parameter space to determine the triangles.\n   - Plot the surface, with the triangles in parameter space determining which x, y, z points are connected by an edge. Use a colormap that ranges from dark blue to light yellow and set the z limit to -2 and 2.\n\n4. For the second plot:\n   - Define the parameter spaces for radii and angles. Let the radii range from 0.5 to 1.5 and the angles range from 0 to 4\u03c0.\n   - Map the radius, angle pairs to x, y, z points.\n   - Create the Triangulation with no triangles so a Delaunay triangulation is created.\n   - Mask off unwanted triangles by calculating the mean of x and y coordinates of the triangles and setting a condition that masks off triangles where the square of the mean x and y coordinates is less than the square of the minimum radius.\n   - Plot the surface using the plot_trisurf function with the triangulation and z values, and use a colormap that ranges from dark red to light blue.\n\n5. Finally, display the plot.",
        "id": 60
    },
    {
        "simple_instruction": "To generate a broken horizontal bar plot with gaps, use the following data and settings:  - Create the first broken bar of two segments at 98 with width 28 and at 128 with width 47, its y-position should be 10 with a height of 11,  set the facecolors of the bars to blue. Create the second broken bar of three segments at 8 with width 46, at 99 with width 22 and at 132 with width 15, its y-position should be 20 with a height of 11,set the  facecolors to orange, green and red. Use broken_barh() function to achieve the above instructions. - Set the x-axis label to 'seconds since start'. - Modify the y-axis tick labels to ['Bill', 'Jim']). Make the grid lines visible. - Add an annotation at coordinate (55, 28) to indicate \"race interrupted\" with text coordinate (0.7, 0.8), use a red arrow to do this annotation.",
        "expert_instruction": "To generate a broken horizontal bar plot with specific requirements, follow these instructions in Python using the matplotlib library:Import matplotlib.pyplot as plt.Define the data for the broken horizontal bars. For the first bar, create two segments: one starting at 98 with a width of 28, and another starting at 128 with a width of 47. For the second bar, create three segments: one starting at 8 with a width of 46, another starting at 99 with a width of 22, and the last one starting at 132 with a width of 15.Set the y-positions of the bars. The first bar should be positioned at 10 and the second at 20 on the y-axis. Both bars should have a height of 11.Specify the face colors of the bars. For the first bar, use blue for both segments. For the second bar, use orange for the first segment, green for the second, and red for the third.Create the plot using fig, ax = plt.subplots().Add the bars to the plot using ax.broken_barh(), passing the segments, y-position, and height as arguments.Set the x-axis label to \"seconds since start\" using ax.set_xlabel().Modify the y-axis tick labels to 'Bill' and 'Jim' using ax.set_yticks() and ax.set_yticklabels().Make the grid lines visible with ax.grid(True).Add an annotation at coordinates (55, 28) with the text \"race interrupted\". Set the text coordinate to (0.7, 0.8) using ax.annotate(). Use a red arrow for this annotation by setting arrowprops to dict(facecolor='red', shrink=0.05).Display the plot using plt.show()",
        "id": 61
    },
    {
        "simple_instruction": "Create a horizontal stacked bar chart titled 'Favorite Sports by Country' to visualize discrete distributions using matplotlib. Use the following data to plot it: category_names = ['Football', 'Volleyball', 'Basketball', 'Formula 1', 'Tennis'], results = {'USA': [12, 13, 15, 34, 28], 'UK': [22, 26, 32, 12, 10], 'Germany': [31, 32, 15, 6, 20], 'Spain': [30, 13, 11, 12, 35], 'China': [25, 24, 8, 3, 43], 'Italy': [18, 9, 15, 25, 30]}.   The horizontal stacked bar chart represents the result of a survey in which people from different countries were asked to rate their most favorite sport from five candidates. Each country is represented by a category on the y-axis, and the length of each bar represents the number of responses for each sport. Color the different categories using category_colors = plt.colormaps['RdYlGn'](        np.linspace(0.15, 0.85, data.shape[1])). Label each stacked bar with their respective data.",
        "expert_instruction": "Import the matplotlib.pyplot and numpy libraries as plt and np, respectively.Define your data:Set category_names as a list of strings representing the sports categories: 'Football', 'Volleyball', 'Basketball', 'Formula 1', and 'Tennis'.Create a dictionary named results with keys as country names ('USA', 'UK', 'Germany', 'Spain', 'China', 'Italy') and values as lists of integers representing the number of responses for each sport.Convert the results dictionary into a numpy array for easier manipulation.Calculate the cumulative sum of the data along the horizontal axis to help in plotting the stacked bars.Access the 'RdYlGn' colormap using plt.get_cmap('RdYlGn') and use np.linspace(0.15, 0.85, number_of_categories) to create a range of colors for the categories.Create a figure and axis using plt.subplots, and adjust the y-axis to be inverted and the x-axis to be hidden.Set the x-axis limits to the maximum cumulative sum of the data.Iterate through each category and its corresponding color:Calculate the width of each bar as the data for that category.Calculate the starting point of each bar as the cumulative sum minus the width.Use ax.barh to draw horizontal bars with specified labels, widths, colors, and starting points.Determine the text color (white or dark grey) based on the brightness of the bar color.Add text labels inside each bar, showing the number of responses.Add a legend to the plot, setting its location and size appropriately.Display the plot using plt.show().",
        "id": 62
    },
    {
        "simple_instruction": "Create a stackplot where multiple datasets are shown as vertically stacked areas. Use the following election results data of different party votes to draw this plot: year = [1994, 1998, 2002, 2006, 2010, 2014, 2018, 2022]; gdp_by_sector = {Agriculture: [228, 284, 365, 477, 631, 814, 1044, 1275], Technology: [340, 425, 519, 619, 727, 840, 943, 1006], Manufacturing: [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560], Services: [220, 253, 276, 295, 310, 303, 294, 293], Research & Development: [120, 150, 190, 220, 260, 310, 360, 390]}. Set the alpha of the stackplot to 0.8. Set the legend of the plot to the upper left part. Add a title that says 'Imaginary country election results', set the x-axis label to 'Year' and y-axis label to 'Number of people (millions)'.",
        "expert_instruction": "Create a Python script using Matplotlib to visualize the growth of GDP in different economic sectors of an imaginary country over a range of years from 1994 to 2022. The sectors should include Agriculture, Technology, Manufacturing, Services, and Research & Development. Update the values for the 'Research & Development' sector to make them larger for better visibility in the graph.The data for each sector over the years should be represented in a stacked area plot. Each sector should be distinctly colored and the plot should have a legend indicating each sector. The x-axis should represent the years, and the y-axis should represent the GDP growth in millions. Include labels for both axes and a title for the graph indicating it's about the GDP growth in different economic sectors of an imaginary country.The data for each sector over the specified years should be as follows:Agriculture: [228, 284, 365, 477, 631, 814, 1044, 1275]Technology: [340, 425, 519, 619, 727, 840, 943, 1006]Manufacturing: [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560]Services: [220, 253, 276, 295, 310, 303, 294, 293]Research & Development: [120, 150, 190, 220, 260, 310, 360, 390]Finally, the script should display the plot.",
        "id": 63
    },
    {
        "simple_instruction": "Use the matplotlib function fill_between to create a plot with shaded regions using the following toy data: t = np.arange(0.0, 2, 0.01), s = np.sin(2*np.pi*t). Shade the region between the curve defined by t and s when s > 0 with the color green and alpha value of 0.5. Shade the region between the curve defined by t and s when s < 0 with the color red and alpha value of 0.5. Display a legend on the top right corner.",
        "expert_instruction": "Write a Python script to create a plot with shaded regions using matplotlib. Start by importing the NumPy and Matplotlib's pyplot libraries. Generate a time array 't' from 0.0 to 2.0 with a step of 0.01. Compute the sine of t multiplied by 2*pi and store this in a variable 's'. Plot the sine curve using Matplotlib. Then, shade the region above the curve (where 's' is greater than 0) with green color and an alpha value of 0.5. Similarly, shade the region below the curve (where 's' is less than 0) with red color and the same alpha value. Finally, display the plot.",
        "id": 64
    },
    {
        "simple_instruction": "Show the marginal distributions of a scatter plot as histograms at the sides of the plot and nicely align the main axes with the marginal distributions. Use some random data x = np.random.randn(1000), y = np.random.randn(1000) to plot the scatter plot.",
        "expert_instruction": "To create a scatter plot with marginal distributions as histograms at the sides of the plot and to align the main axes with the marginal distributions using Python and Matplotlib, follow these steps:Import the necessary libraries: NumPy for data manipulation and Matplotlib for plotting. Additionally, import MaxNLocator from matplotlib.ticker for better control over the histogram tick marks.Generate random data: Create two arrays, x and y, each with 1000 normally distributed random numbers.Prepare the figure and grids: Create a figure and define a grid layout with a 2x2 grid. Allocate more space to the main scatter plot and ensure that the histograms are aligned with the scatter plot axes.Create subplots: Add three subplots to the figure:The main scatter plot in the lower-left grid.A histogram for the x-axis data in the upper-left grid.A histogram for the y-axis data in the lower-right grid.\nEnsure that the x-axis of the scatter plot is shared with the x-axis histogram, and the y-axis of the scatter plot is shared with the y-axis histogram.Create the scatter plot: Plot the x and y data on the main axes with your preferred style settings.Create the histograms:Plot a histogram of the x data on the top axes.Plot a histogram of the y data on the right axes, rotated horizontally.Optionally, control the number of bins and adjust the transparency with the alpha parameter.Adjust the appearance of the histograms:Limit the number of tick marks using MaxNLocator.Hide unnecessary spines and tick labels to keep the focus on the main plot.Finally, display the plot using plt.show().",
        "id": 65
    },
    {
        "simple_instruction": "Create a timeline with lines, dates, and text using real Matplotlib release dates.  Here are the versions and release dates: names = ['v2.2.4', 'v3.0.3', 'v3.0.2', 'v3.0.1', 'v3.0.0', 'v2.2.3',             'v2.2.2', 'v2.2.1', 'v2.2.0', 'v2.1.2', 'v2.1.1', 'v2.1.0',             'v2.0.2', 'v2.0.1', 'v2.0.0', 'v1.5.3', 'v1.5.2', 'v1.5.1',             'v1.5.0', 'v1.4.3', 'v1.4.2', 'v1.4.1', 'v1.4.0']    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',             '2014-10-26', '2014-10-18', '2014-08-26']. Create a stem plot titled 'Matplotlib Release Dates', where each version release date is represented by a vertical line perpendicular to the timeline. Adjust the height of these vertical lines to differentiate closely spaced events. Add markers at the base of each line to emphasize the timeline's one-dimensional nature. Annotate each vertical line with the corresponding version number, offsetting the text slightly from the tip of the line for clear visibility.",
        "expert_instruction": "Import necessary modules: Explain that the code should start by importing datetime from the datetime module, matplotlib.pyplot as plt, numpy as np, and matplotlib.dates as mdates. These are essential for handling dates, plotting, and numerical operations.Provide fallback data lists: Mention that in case of any issues such as a missing internet connection, the code should include predefined lists named names and dates. The names list will contain version strings, and the dates list will contain corresponding release dates in the 'YYYY-MM-DD' format.     names = ['v2.2.4', 'v3.0.3', 'v3.0.2', 'v3.0.1', 'v3.0.0', 'v2.2.3',             'v2.2.2', 'v2.2.1', 'v2.2.0', 'v2.1.2', 'v2.1.1', 'v2.1.0',             'v2.0.2', 'v2.0.1', 'v2.0.0', 'v1.5.3', 'v1.5.2', 'v1.5.1',             'v1.5.0', 'v1.4.3', 'v1.4.2', 'v1.4.1', 'v1.4.0']    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',             '2014-10-26', '2014-10-18', '2014-08-26'].Convert date strings to datetime objects: Instruct that the date strings in the dates list need to be converted into datetime objects using datetime.strptime with the format '%Y-%m-%d'.Create levels for the stem plot: Suggest creating an array of levels for plotting. These levels can be generated using np.tile with a pattern and length that matches the number of dates.Set up the figure and axes: Advise setting up a figure and axes for plotting using plt.subplots. Specify that the figure should have a constrained layout and a title indicating it's about Matplotlib release dates.Plot vertical lines and markers: Request plotting vertical lines (vlines) for each date with corresponding levels, and baseline markers (plot) on these dates.Annotate each line: Instruct to annotate each line with the corresponding name from the names list, adjusting the text alignment and position based on the level.Format the x-axis: Guide to format the x-axis to show dates at 4-month intervals and rotate the labels for better readability.Remove unnecessary elements: Suggest removing the y-axis and unnecessary spines from the plot for a cleaner look.Adjust margins and display the plot: Finally, instruct to adjust the margins and use plt.show() to display the plot.",
        "id": 66
    },
    {
        "simple_instruction": "Define a set of x and y values ranging from -3.0 to 3.0 and -2.0 to 2.0, respectively, with 100 points in each dimension. Create a meshgrid from the x and y values for the contour plot. Generate two 2D Gaussian distributions, Z1 and Z2. For Z1, use the negative exponent of the squares of X and Y. For Z2, scale X and Y by a factor of 5 before squaring and taking the exponent. Combine these two distributions into a single variable z by adding Z1 and Z2 multiplied by 45. Introduce 6 points of negative values in the bottom-left corner of the z array to test the log scaling. Mask out non-positive values in z to avoid issues when taking the logarithm. Use Matplotlib's contourf function to create a filled contour plot. Utilize the LogLocator from Matplotlib's ticker module for automatic selection of log-scaled levels.  Apply a colormap of your liking to the contour plot for aesthetic preference. Add a colorbar to the plot to show the log scale of the values. Finally, display the plot using plt.show().",
        "expert_instruction": "Import Necessary Libraries: Instruct the model to import matplotlib.pyplot, numpy, and relevant submodules from Matplotlib like cm (for colormap) and ticker (for setting the axis scales).Data Preparation:Define a grid of points to create arrays x and y. Specify the range for these arrays.Create 2D grid coordinates X and Y from the 1D arrays.Define a function Z1 as an exponential decay based on X and Y.Define another function Z2 with a sharper decay, scaled by a factor of 10 for both X and Y.Combine Z1 and Z2 to create the final data array z. Multiply Z2 by a factor (like 50) to create a spike in the data.Handling Negative Values:Introduce some negative values in a part of the z array to demonstrate handling of such values in a logarithmic plot.Mask the array wherever it is less than or equal to 0, to avoid issues with logarithmic scaling.Plotting:Create a figure and axis using matplotlib.pyplot.subplots.Create a contour plot using ax.contourf, with X, Y, and z as inputs. For the scale, use ticker.LogLocator() to set a logarithmic scale.Optionally, mention an alternative method to manually set levels and normalization using logarithmic scaling.Add a color bar to the plot using fig.colorbar.Display the Plot: Instruct to use plt.show() to display the final plot.",
        "id": 67
    },
    {
        "simple_instruction": "Create a Python script using matplotlib and numpy to generate a heatmap visualization. This heatmap should represent a dataset of average monthly temperatures in degrees Celsius in various cities throughout the year. Use a color map appropriate for temperature data, ensuring that the values within each cell are annotated for clarity. The annotated values should change to a lighter color when in cells with darker color and vice versa to improve contrast and readability. The rows should be labeled with the names of the months, such as January, February, March, April, May, June, July, August, September, October, November, and December. The columns should be labeled with names of cities like New York, London, Tokyo, Sydney, Cairo, Buenos Aires, and Moscow. Include a color bar on the right side of the heatmap to indicate the temperature scale, labeled as 'temperature [\u00b0C]'. Rotate the tick labels on the x-axis for better readability and use white grid lines to clearly delineate the cells. Implement a function to create the heatmap and another to annotate it with temperature values, formatted to one decimal place. Finally, adjust the layout for a tight fit and display the plot. Use the following data: months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",          \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] cities = [\"New York\", \"London\", \"Tokyo\", \"Sydney\", \"Cairo\", \"Buenos Aires\", \"Moscow\"] temperatures = np.array([    [-1, 5, 6, 26, 14, 25, -7],    [-1, 5, 7, 26, 15, 23, -9],    [3, 7, 10, 20, 20, 20, -4],    [10, 10, 15, 18, 25, 15, 6],    [16, 13, 20, 15, 30, 11, 15],    [21, 16, 22, 13, 35, 8, 19],    [25, 19, 27, 10, 35, 8, 21],    [24, 18, 29, 13, 35, 10, 20],    [20, 15, 24, 17, 30, 14, 13],    [14, 11, 19, 20, 25, 18, 7],    [8, 7, 13, 22, 20, 21, 0],    [2, 5, 9, 24, 15, 23, -5]])",
        "expert_instruction": "Create a heatmap visualization of average monthly temperatures for various cities throughout the year using matplotlib and numpy.Start by importing the matplotlib.pyplot and numpy libraries in Python.Define a function named create_heatmap that takes three arguments: temperatures, a 2D numpy array of temperature values; row_labels, a list of strings for row labels (months); and col_labels, a list of strings for column labels (cities).Inside this function, create a subplot using matplotlib.pyplot.subplots().Display the temperature data as a heatmap using the imshow function of the axes object, with the color map set to 'coolwarm' and aspect ratio set to 'auto'.Annotate each cell of the heatmap with the corresponding temperature value. Adjust the text color to white for darker cells and black for lighter cells for better contrast and readability. The temperature values should be formatted to one decimal place.Set the x-axis and y-axis ticks positions to correspond to the number of columns and rows, respectively.Label the x-axis and y-axis with the provided city and month names.Rotate the x-axis tick labels by 45 degrees for better readability, and adjust their alignment.Add a color bar to the right side of the heatmap, representing the temperature scale. Label the color bar with 'Temperature [\u00b0C]' and rotate this label for appropriate orientation.Add white grid lines to the heatmap for clarity by setting minor ticks and applying a white grid on them.Adjust the layout of the plot for a tight fit using plt.tight_layout().Finally, display the heatmap using plt.show().",
        "id": 68
    },
    {
        "simple_instruction": "Create two plots on the same axes with different left and right scales using matplotlib. Plot the data using the following arrays: t = np.arange(0.01, 10.0, 0.01), data1 = np.exp(t), data2 = np.sin(2 * np.pi * t).",
        "expert_instruction": "Write a Python script using Matplotlib to plot two different types of data on the same graph, with a shared x-axis but separate y-axes. The first dataset should be an exponential function, and the second dataset should be a sine function.Start by importing matplotlib.pyplot and numpy.Create a time variable 't' that ranges from 0.01 to 10.0, with increments of 0.01.Generate the first dataset 'data1' as an exponential function of 't'.Generate the second dataset 'data2' as the sine of 't' multiplied by 2\u03c0.Initialize a Matplotlib subplot.Set the x-axis label to 'time (s)'.Plot 'data1' on the primary y-axis (left side) with the label 'exp' and in red color. Ensure the y-axis tick labels are also in red.Create a secondary y-axis that shares the same x-axis with the primary y-axis.Plot 'data2' on this secondary y-axis (right side) with the label 'sin' and in blue color. The y-axis tick labels should be in blue as well.Finally, use 'fig.tight_layout()' to adjust the layout so that the right y-label is not clipped, and display the plot.",
        "id": 69
    },
    {
        "simple_instruction": "Create a broken axis plot with a portion of its y-axis cut out using matplotlib. Use some random data points to plot a scatter plot with ten outlier points on the upper part of the region, which are far away from many other scatter points on the lower part of the region. Use slanted lines to indicate the cut in the y-axis. The slanted lines themselves are markers at those locations, such that the lines keep their angle and position, independent of the axes size or scale",
        "expert_instruction": "Create a Python script using the matplotlib library to generate a broken axis plot. Follow these steps:Generate Random Data Points: Start by creating a set of random data points. These points will be used for the main scatter plot. You can use numpy's random number generation for this.Create Outlier Points: Add ten outlier points to your data set. Ensure these outliers are significantly distant from the main data points, for instance, by multiplying their values to increase the distance.Set Up a Broken Axis: Utilize matplotlib's functionality to create a plot with a broken y-axis. This involves creating two subplots (top and bottom) that share the same x-axis. Adjust the vertical spacing between these subplots to make it look like a single plot with a break in the y-axis.Add Slanted Lines as Markers: At the location of the y-axis break, add slanted lines to visually represent the discontinuity. These lines should be drawn as markers and should maintain their angle and position regardless of the axes' size or scale. Place these lines on both the top and bottom subplots at the edges where the axis breaks.Plot the Scatter Plot: Use the scatter plot function to plot the main data points and the outliers on your broken axis. Ensure the main data points appear on both the top and bottom subplots, while the outliers are only on the bottom subplot.Finalize the Plot: Adjust the plot's spines and ticks to hide the spines between the top and bottom subplots and to ensure tick labels appear correctly.End the script with a command to display the plot.",
        "id": 70
    },
    {
        "simple_instruction": "Write a Python script using matplotlib that creates a compound plot to demonstrate a zoom effect on the x-axis. The main plot should be at the bottom, showing the full range, in which there are two filled areas with light blue color indicating the zoomed-in regions. Above the main plot, create two smaller subplots side by side, each representing a zoomed-in section of the main plot. The subplots should highlight specific x-axis ranges with a light blue fill to indicate the zoomed regions. Include black slanted lines from the top of the main plot at the boundaries of the zoomed sections pointing to the subplots to signify the transition between the zoomed and full-range views. Ensure that the x-axis labels and tick marks are properly aligned and clearly indicate the relationship between the zoomed sections and the main plot's x-axis range.",
        "expert_instruction": "Create a Python script using the Matplotlib library to demonstrate the zoom effect in plots.Import Necessary Libraries: Include imports for matplotlib.pyplot, and specific functions from matplotlib.transforms and mpl_toolkits.axes_grid1.inset_locator.Connect Bounding Boxes Function: Ask for a function connect_bbox that takes two bounding boxes, locations for the connection points, properties for lines and patches. This function should create connectors and patches between the two bounding boxes.Zoom Effect Function with Specified Range: Request a function zoom_effect01 which takes two axes (ax1 and ax2), and a range defined by xmin and xmax. This function should mark a range in both axes to illustrate a zoom effect from ax1 to ax2.Zoom Effect Function with Automatic Range: Ask for a function zoom_effect02 similar to zoom_effect01, but it should automatically determine the xmin and xmax from the view limits of ax1.Setup and Apply Zoom Effects: The script should create a subplot mosaic with two zoomed subplots and one main subplot. Then apply zoom_effect01 to one zoomed subplot and the main plot with a specified range. Apply zoom_effect02 to the other zoomed subplot and the main plot.Display the Plot: Finally, instruct to include a command to display the plot using plt.show().This set of instructions would guide the language model to create a script that visually demonstrates zoom effects in a matplotlib plot)",
        "id": 71
    },
    {
        "simple_instruction": "Create a Python script that generates a horizontal boxplot chart displaying the distribution of dataset measurements across different methods. The dataset should consist of several groups, each corresponding to a unique detection method, such as 'Spectral Analysis', 'Direct Observation', 'Light Curve Analysis', 'Doppler Shift', 'Phase Curve', 'Gravitational Lensing', 'Transit Photometry', 'Eclipse Timing', and 'Direct Imaging'. Each method should have a range of data points representing some hypothetical measurements like 'signal strength', 'light intensity', 'velocity', or any other relevant metric in a scientific context, distributed over varying distances or periods. The measurements should be on a logarithmic scale ranging from 1 to 10,000, and measurements should vary randomly within reasonable ranges for each method. Ensure to include elements such as the median, outliers, and quartiles, similar to the example. Make sure the plot aesthetics, color scheme, and layout are clean and visually engaging.",
        "expert_instruction": "To create a Python script for generating a horizontal boxplot chart that displays the distribution of dataset measurements across different methods, follow these instructions:Import Required Libraries: Use matplotlib.pyplot for plotting and numpy for numerical operations. Import these libraries at the beginning of your script.Prepare the Dataset:Define a list of methods representing different detection techniques like 'Spectral Analysis', 'Direct Observation', 'Light Curve Analysis', etc.Use numpy to generate random data for each method. This can be done using a dictionary comprehension, where keys are the methods and values are arrays of data points. Use np.random.lognormal to create a log-normal distribution of data for each method, with means and sigmas generated randomly within specified ranges.Ensure that the data points are within the range of 1 to 10,000 by using np.clip.Create a Horizontal Boxplot:Set up the figure using plt.figure, specifying the size.Use plt.boxplot to create the boxplot. Set vert=False for a horizontal plot. Use the data.values() for the boxplot data and methods for labels. Enable patch artist for custom box colors, and show elements like fliers, caps, means, and mean lines.Apply a logarithmic scale to the x-axis using plt.xscale('log') and set the limits from 1 to 10,000.Add x-axis label, title, and enable grid for better readability.Use plt.tight_layout() for a clean layout.Display the Plot: Finally, use plt.show() to display the generated boxplot.",
        "id": 72
    },
    {
        "simple_instruction": "Create a polar bar plot visualizing a dataset with 50 items. Each item belongs to one of four groups (A, B, C, D) and has a unique name and value. Data Requirements: The dataset should consist of 50 items named \"item 1\" to \"item 50\". Assign random integer values between 30 and 100 for each item. Group the items into four categories: First 10 as 'A', next 20 as 'B', following 12 as 'C', and last 8 as 'D'. Plot Features: Use a polar coordinate system. Assign different colors to each group. Ensure there's a clear separation between the groups on the plot. Display the name of each item at the end of its corresponding bar. Rotate the names so they align radially, with names on the left half of the plot facing outward and names on the right half facing inward. Remove all axis lines, grid lines, and tick marks for a clean look. Adjust the plot so that group 'A' starts from the top (0 degrees). The center of the plot should be blank, making the polar bar bottoms stem from a invisible circle. Technical Aspects: The plot should be reproducible, so set a fixed seed for random number generation. Use Python libraries like Matplotlib, Pandas, and NumPy. Include comments for clarity and future reference.",
        "expert_instruction": "Initialize the required libraries: Start by importing matplotlib.pyplot, numpy, and pandas. Make sure to alias them as plt, np, and pd respectively.Set up a reproducible random number generator: Utilize numpy's random generator with a fixed seed for reproducibility. For instance, use np.random.default_rng(123).Create a DataFrame: Generate a DataFrame df using pandas with three columns: 'name', 'value', and 'group'. The 'name' column should contain strings like \"item 1\", \"item 2\", ..., \"item 50\". The 'value' column should have random integers between 30 and 100. The 'group' column should consist of a predetermined sequence of group labels (e.g., \"A\" repeated 10 times, \"B\" 20 times, \"C\" 12 times, and \"D\" 8 times).Define a function for label rotation and alignment: Write a function get_label_rotation that takes an angle and an offset, converts the angle from radians to degrees, adjusts for alignment ('right' if the angle is less than or equal to \u03c0, otherwise 'left'), and then returns the rotation and alignment.Create a function to add labels: Write a function add_labels that takes angles, values, labels, an offset, and an axis object. This function should iterate over the given angles, values, and labels to place text labels on a plot with appropriate rotation and alignment, determined by the previously defined get_label_rotation function.Prepare data for the polar plot: Extract 'group', 'value', and 'name' columns from the DataFrame into variables. Set an offset for the polar plot. Calculate the number of angles based on the values and group sizes, adding padding for spacing between groups. Compute the width of each bar.Calculate indexes for the bars: Determine the right indexes to place the bars on the polar plot, considering the group sizes and added padding.Set up the polar plot: Initialize a polar subplot with a specified size. Configure the plot's aesthetics like theta offset, y-axis limits, and removing grids and ticks.Assign colors and plot the bars: Assign different colors for each group and plot the bars on the polar axis using these colors. Make sure to skip some angles to leave space between groups.Add labels to the plot: Use the add_labels function to add labels to each bar on the plot.Display the plot: Finally, use plt.show() to display the polar bar plot.",
        "id": 73
    },
    {
        "simple_instruction": "Create a visually engaging bubble plot titled 'A colored bubble plot' using Python's plotting libraries. The plot should display a relationship between two variables, represented by the X and Y axes, with the following characteristics: Data Generation: The plot should be based on randomly generated data points. There should be 15 data points in total. Each point's position on the X-axis is determined by a random value, and its position on the Y-axis should be influenced by its corresponding X value but with some added randomness. Bubble Characteristics: The size of each bubble should vary, reflecting another dimension of the data. Specifically, the bubble size should be related to the X-axis value, but with an additional transformation to make the size variation more pronounced. Color Scheme: The color of the bubbles should be a gradient based on their position along the X-axis, using a cool color scheme like blues or greens. The bubbles should also have a degree of transparency for aesthetic appeal, and grey outlines to enhance visibility. Axis Labels and Title: Include clear labels for both the X and Y axes and a descriptive title for the plot that encapsulates its purpose or the nature of the data being represented. Display: Ensure the final plot is displayed clearly.",
        "expert_instruction": "Import Libraries: Begin by importing the necessary libraries. In this case, the model should import matplotlib.pyplot as plt, numpy as np, and seaborn as sns.Create Data: The next step is to generate the data that will be plotted. The model should create three numpy arrays:x: a random array with 15 elements.y: an array where each element is the sum of the corresponding element in x and a new random value.z: an array where each element is the sum of the corresponding element in x and a new random value, and then each element of this array is squared.Plotting the Data: The model should then use the scatter function from matplotlib to create a bubble plot. This involves:Mapping the x and y arrays to the respective axes.Using the z array to determine the size of the bubbles, multiplying it by a factor (2000 in this case) for visibility.Coloring the bubbles based on the values in the x array using a color map (like \"Blues\").Setting the transparency of the bubbles with the alpha parameter.Adding grey edge colors to the bubbles with a certain linewidth.Adding Titles and Labels: The model should add titles to the plot and labels to the axes. Specifically, it should:Label the x-axis as \"the X axis\".Label the y-axis as \"the Y axis\".Add a main title to the plot, such as \"A colored bubble plot\".Displaying the Plot: Finally, the model should include a command to display the plot, using plt.show().",
        "id": 74
    },
    {
        "simple_instruction": "Create a visual representation in Python that compares two groups of data, 'Group 1' and 'Group 2'. Each group should consist of 100 random data points, following a normal distribution. 'Group 1' should have a mean of 100 and a standard deviation of 30, while 'Group 2' should have a mean of 130 and a standard deviation of 30. The plot should uniquely combine a beeswarm plot and boxplots for a clear comparison of these two groups. The beeswarm plot must display the distribution of each group's data points without overlap, and the boxplots should be overlaid on the same chart to summarize the statistical distributions. The beeswarm plot representing Group 1 should have the color blue, the other beeswarm plot should have the color orange. Include the title 'Beeswarm plot and Boxplots, made with matplotlib', a y-axis label, and a legend indicating the groups. The final visualization should be displayed using matplotlib.",
        "expert_instruction": "Objective: Write a Python script using matplotlib, numpy, and pandas to create a combined beeswarm and boxplot visualization for two groups of data.Data Generation:Generate two sets of random data, each following a normal distribution.The first dataset (Group 1) should have 100 data points with a mean of 100 and a standard deviation of 30.The second dataset (Group 2) should have 100 data points with a mean of 130 and a standard deviation of 30.Combine these two datasets into a single array and create a corresponding categorical array indicating the group of each data point.Store this data in a pandas DataFrame with columns named 'numerical_variable' and 'categorical_variable'.Beeswarm Plot Function:Write a function simple_beeswarm2(y, nbins=None, width=1.) that computes x coordinates for a beeswarm plot.The function should accept a list of y-values and optionally the number of bins and the width for the plot.It should return x coordinates that, when plotted against y, result in a beeswarm plot.Plotting:Create a matplotlib figure and axis.Hide the x-axis of the plot.For each unique category in the DataFrame, plot a beeswarm plot using the simple_beeswarm2 function.Ensure each group's plot is shifted horizontally to prevent overlapping.Add boxplots above the beeswarm plots for each group.Customize the plot with a title ('Beeswarm plot and Boxplots, made with matplotlib'), y-axis label ('Y Axis Label'), and a legend indicating each group.Display:Show the final plot using plt.show().",
        "id": 75
    },
    {
        "id": 76,
        "simple_instruction": "Write a code to load 'data.csv' and visualize the \"Women's millions of dollars\" column with a composite graph: an axis-free box plot above and a histogram below. Label key statistics on the box plot and detail the frequency distribution in the histogram. Highlight quartiles with continuous red dashed lines across both sections, ensuring no breaks.",
        "expert_instruction": "I Have some data of Clothing Stores Retail Sales in U.S.A named 'data.csv'. There are two columns in the CSV file. The first column is \"Woman's millions of dollars\". the second column is \"Men's millions of dollars\". Write a python script to read data from file \"data.csv\" and create a vertical two-part graph with the top part being a box plot and the bottom part a histogram. The data visualized relates to 'Women's millions of dollars' in retail sales. The plot showcase the distribution of women's clothing retail sales in the U.S. The upper section is an axis-free box plot highlighting key statistical values, while the lower section is a histogram detailing the frequency distribution. Red dashed lines indicate the quartiles, seamlessly connecting both plots to emphasize these measures.The box plot should have no visible axes, and it should be narrower in width. Include numerical labels for key statistics such as the minimum, lower quartile, median, upper quartile, and maximum values, placed just above the box plot. The histogram should have visible axes and a smaller bin size for finer details. Add two continuous red dashed lines at the lower and upper quartiles. These lines should extend seamlessly across both the box plot and the histogram, without any gaps. The entire plot should be tightly laid out with no space between the box plot and the histogram so that the line can have no break."
    },
    {
        "id": 77,
        "simple_instruction": "I have data of protein consumption in 24 European countries named \"data.csv\". The column of data are [\"Country\",\"Red Meat\",\"White Meat\",\"Eggs\",\"Milk\",\"Fish\",\"Cereals\",\"Starch\",\"Nuts\",\"Fruits & Vegetables\"].\nWrite a Python code to visualize this data using a 2D scatter plot with K-Means clustering into three distinct color-coded clusters. The plot should include semi-transparent ellipses around each cluster, lines connecting data points to cluster centroids, and annotations for each point representing countries. It should be well-labeled and include a legend, aiming for clarity and visual grouping.",
        "expert_instruction": "I have data of protein consumption in 24 European countries named \"data.csv\". The column of data are [\"Country\",\"Red Meat\",\"White Meat\",\"Eggs\",\"Milk\",\"Fish\",\"Cereals\",\"Starch\",\"Nuts\",\"Fruits & Vegetables\"].\nWrite a python code to create an image of a 2D scatter plot representing a K-Means clustering of data. The plot should have three distinct clusters of points, each in its own color. For example, Cluster 0 could be blue, Cluster 1 could be red, and Cluster 2 could be green. Around each cluster, draw a semi-transparent ellipse in the same color as the cluster points but in a lighter shade, giving a sense of grouping. Connect each data point to the centroid of its cluster with a thick grey line. The background should have a grid, enhancing the plot's readability. Label the x-axis as 'Principal Component 1' and the y-axis as 'Principal Component 2'. Annotate each data point with a small text label close to it, which could be the names of countries for a realistic touch, but ensure the text is legible. The plot should have a title at the top: 'K-Means Clustering with PCA-reduced Data and Colored Ellipses'. Include a legend on the side, denoting the clusters with their respective colors."
    },
    {
        "id": 78,
        "simple_instruction": "Create a Python script to generate a 3D scatter plot from a CSV file named \"data.csv\" with columns [\"0-60 mph(sec)\", \"Gas Mileage(mpg)\", \"Power(kW)\", \"Weight(kg)\", \"Engine Displacement(cc)\"]. The plot should meet the following specifications:\n- Plot each car as a point in 3D space using its acceleration time, gas mileage, and power as coordinates.\n- Point sizes should increase with the engine displacement, and colors should vary from one end of the spectrum (like purple) for smaller engines to the other end (like yellow) for larger engines.\n- Add flat projections of these points onto the XY, ZX, and YZ planes below and to the sides of the 3D points, colored blue, red, and green, respectively.\n- Include a color bar to indicate the relationship between color and engine displacement.\n- Label each axis to show what it represents and use a 3D perspective for viewing the plot.\n- Ensure the plot has a modern and clean design, with clear, semi-transparent points to avoid visual clutter.",
        "expert_instruction": "I have data of car named \"data.csv\". The column of data is [\"0-60 mph(sec)\",\"Gas Mileage(mpg)\",\"Power(kW)\",\"Weight(kg)\",\"Engine Displacement(cc)\"].\nWrite a python code to draw a plot.\n1. **Type of Plot**: This is a 3D scatter plot.\n\n2. **Axes Description**:\n   - The X-axis represents \"0-60 mph (sec)\".\n   - The Y-axis represents \"Gas Mileage (mpg)\".\n   - The Z-axis represents \"Power (kW)\".\n\n3. **Data Points**:\n   - Each data point in the 3D space represents a car, plotted according to its 0-60 mph time, gas mileage, and power.\n   - The size of each point correlates positively with the engine displacement (cc) of the car. Larger points signify larger engine displacements.\n   - The color of the points also represents engine displacement, using a gradient color scheme (like viridis), where one color end (like purple) indicates smaller displacement, and the other end (like yellow) indicates larger displacement.\n\n4. **Projections**:\n   - There are projections of these data points on three planes: XY, ZX, and YZ.\n   - Each projection uses dots of a single color for all points on that plane.\n   - The XY plane projection is at the bottom (below the main data points), colored blue.\n   - The ZX plane projection is on one side, colored red.\n   - The YZ plane projection is on another side, colored green.\n\n5. **Additional Elements**:\n   - A color bar is present, showing the correlation between color and engine displacement in cc.\n   - The plot has labels for each axis, clearly stating what each axis represents.\n   - The plot uses a 3D perspective, allowing the axes and projections to be viewed at an angle rather than straight on.\n\n6. **Style**:\n   - The plot should have a modern, clean look, with a focus on readability and clarity.\n   - The scatter points are solid and well-defined, with a slightly transparent look to prevent overcrowding visually."
    },
    {
        "id": 79,
        "simple_instruction": "I have data of iris flower named \"data.csv\". Generate a 3D scatter plot from \"data.csv\" using the columns \"Petal Length(cm)\", \"Petal Width(cm)\", \"Sepal Length(cm)\", and \"Species\". Use distinct colors to represent each iris flower species. For each species, include confidence ellipses that encompass 95% of the data points, ensuring these ellipses are aligned with the principal axes of variation in the dataset. The confidence ellipses should be solid, opaque, and color-matched to the scatter points of each species, without any wireframes. Ensure the plot includes labeled axes for 'Petal Length', 'Petal Width', and 'Sepal Length', and add a legend that clearly identifies each species by its corresponding color.",
        "expert_instruction": "I have data of iris flower named \"data.csv\". The column of data is [\"Petal Length(cm)\",\"Petal Width(cm)\",\"Sepal Length(cm)\",\"Sepal Width(cm)\",\"Species\"].\nWrite a python code to draw a plot.\n1. Create a 3D scatter plot with axes representing 'Petal Length', 'Petal Width', and 'Sepal Length'.\n2. Plot data points for each iris flower species using distinct colors.\n3. For each species, calculate the mean of the data points to determine the ellipsoid center.\n4. Compute the covariance matrix for each species to define the ellipsoid shape and orientation.\n5. Scale the ellipsoids to include 95% of the respective data points, ensuring they are aligned with the dataset's principal variation axes.\n6. Draw solid, opaque ellipsoids for each species in matching colors to the scatter points, without wireframes.\n7. Add axis labels for each measurement dimension and a legend that identifies each species by color."
    },
    {
        "id": 80,
        "simple_instruction": "Create a 3D topographic visualization using the elevation data from \"data.csv\". The visualization should be structured in layers with:\n\nA 2D terrain map as the base layer, featuring appropriate terrain colors.\nAbove the base, a 3D representation of the terrain in saddlebrown color.\nHigher than the terrain, a layer of colored contour lines.\nAt the top, a 3D grid overlay.\nEnsure the view angle allows a clear view of all layers, with appropriate z-axis limits to display each layer effectively. Include a color legend for elevation and label the color bar as 'Height (m)'. Also, label the x, y, and z axes for clarity.",
        "expert_instruction": "Create a 3D topographic visualization from \"data.csv\" with elevation data:\n1. Load the elevation data.\n2. Form a coordinate grid based on the dimensions of the data.\n3. Layer the 3D plot with:\n  - A 2D map with terrain colors at z=0.\n  - A 3D terrain in saddlebrown at z=-200.\n  - Colored contour lines at z=800.\n  - A 3D grid at z=750.\n4. Adjust the view angle for optimal visibility.\n5. Set the z-axis limits to ensure all layers are visible.\n6. Include a color legend indicating the height in meters.\n7. Add a color bar as a legend, with the label 'Height (m)'.\n8. Label the x, y, and z axes."
    },
    {
        "id": 81,
        "simple_instruction": "Create a Sankey diagram using data from the 'data.csv' file. The diagram should clearly depict the flow from source nodes to target nodes, with the sources on the left and targets on the right. Each unique label in both source and target columns should have a consistent color throughout the diagram. The link weights should be based on the count of each unique source-target pair. Ensure the layout is clear, with distinct separation between the left (source) and right (target) sides. Save and display the final diagram.",
        "expert_instruction": "Create a Sankey diagram from the 'data.csv' file, where the source and target nodes are positioned on the left and right sides respectively, and ensuring the colors are consistent for matching source and target labels. You would follow these steps:\n1. Read Data: Load the data from 'data.csv' using Pandas, setting header=None and naming the columns 'Source' and 'Target' immediately after reading the file.\n2. Calculate Weights: Group the data by 'Source' and 'Target' columns and calculate the count of each unique pair. These counts will be used as weights for the Sankey links.\n3. Generate Node Labels and Colors:\n  - Create a list of unique labels for all items in both 'Source' and 'Target' columns.\n  - Assign a unique color to each unique label, ensuring that labels shared between sources and targets use the same color.\n4. Create Sankey Diagram:\n  - Use Plotly's go.Sankey to construct the diagram. Define node labels and colors, ensuring that the source nodes are on the left and target nodes are on the right. This is typically handled by the Sankey diagram layout itself, where source nodes flow to target nodes.\n  - Specify the nodes and their colors, and define the links with source indices, target indices, and weights.\n  - Customize the layout to ensure clarity and distinction between the left (source) and right (target) sides.\n5. Save and Display: Output the generated Sankey diagram."
    },
    {
        "id": 82,
        "simple_instruction": "I have a data named \"data.json\", showing the flow of energy in terawatt-hours (TWh).\nThe data.json file contains a dictionary at the root level with two keys: 'data' and 'layout'. Here's an overview of its structure:\n- 'data': This key corresponds to a list, and the length of this list is 1, indicating there is one primary data object. This object contains the following keys:\n  - 'type': Presumably indicates the type of plot or data representation.\n  - 'domain': Possibly specifies the domain or space in which the data is plotted.\n  - 'orientation': The orientation of the data visualization.\n  - 'valueformat': Format for numerical values, such as currency or percentages.\n  - 'valuesuffix': A suffix to append to the values, like units of measurement.\n  - 'node': An object containing information about the nodes in the Sankey diagram.\n  - 'link': An object containing information about the links between nodes in the Sankey diagram.\n- 'layout': This key corresponds to a dictionary that likely contains layout settings for the visualization, such as size, margins, titles, and other styling options.\nTo make a diagram showing energy flows using \"data.json\":\n1. Open the Data File: Start by opening the \"data.json\" file to read the energy data.\n2. Color Settings:\n  - Decide how see-through you want the link colors to be.\n  - Choose colors for each energy type or process, making sure they are a bit see-through too.\n3. Set Up Nodes:\n  - Nodes are the boxes or points that represent different types of energy or processes. Make sure each has a label and color.\n  - Adjust how far apart and how thick each node is.\n4. Set Up Links:\n  - Links are the arrows or lines that show the energy moving from one node to another. Make sure each has a starting point, an ending point, how much energy it represents, and a color.\n  - The color of the links should match the energy source or process it's coming from but a bit lighter.\n5. Finished Diagram:\n  - Your final diagram will show all the different types of energy on one side, what they're used for on the other, and all the energy flows between them. The thickness and color of each link will help show how much energy is moving.",
        "expert_instruction": "I have a data named \"data.json\", showing the flow of energy in terawatt-hours (TWh).\nThe data.json file contains a dictionary at the root level with two keys: 'data' and 'layout'. Here's an overview of its structure:\n- 'data': This key corresponds to a list, and the length of this list is 1, indicating there is one primary data object. This object contains the following keys:\n  - 'type': Presumably indicates the type of plot or data representation.\n  - 'domain': Possibly specifies the domain or space in which the data is plotted.\n  - 'orientation': The orientation of the data visualization.\n  - 'valueformat': Format for numerical values, such as currency or percentages.\n  - 'valuesuffix': A suffix to append to the values, like units of measurement.\n  - 'node': An object containing information about the nodes in the Sankey diagram.\n  - 'link': An object containing information about the links between nodes in the Sankey diagram.\n- 'layout': This key corresponds to a dictionary that likely contains layout settings for the visualization, such as size, margins, titles, and other styling options.\nEach of these keys ('node' and 'link' under 'data') likely holds further details about the nodes and links, respectively, such as labels, colors, sources, targets, and values. This structure is typical for a Plotly data object, where 'data' defines the figures and 'layout' defines how they're presented.\nPlot a sankey diagram to display energy sources on the left, uses and losses on the right, and links showing the flow of energy in terawatt-hours (TWh)\n1. **Read the JSON Data**:\n   Load your data with json.load(open('data.json', encoding='utf-8')).\n\n2. **Customize Node and Link Colors**: \n- Set an opacity level for the link colors (e.g., 0.4).\n- Change specific node colors to 'rgba' format to add opacity. For example, replace 'magenta' with its 'rgba' equivalent, ensuring transparency.\n\n3. **Sankey Diagram Nodes**: \n- Define nodes with padding, thickness, line color, labels, and custom colors using the node dictionary in go.Sankey.\n- Ensure the labels from the JSON data are correctly assigned.\n\n4. **Sankey Diagram Links**: \n- Define links with source indices, target indices, values, and colors using the link dictionary in go.Sankey.\n- Set the link colors to match the source node colors with adjusted opacity.\n\n5. **Figure Layout**: \n- Use fig.update_layout to set the title, including HTML formatting for links, and adjust font size.\n\n6. **Save the Figure**: \n- Save the Sankey diagram.\n\n7. **Resulting Diagram**: \n- The resulting diagram will display energy sources on the left, uses and losses on the right, and links showing the flow of energy in terawatt-hours (TWh).\n- The thickness and color intensity of the links correspond to the flow magnitude, with the color scheme reflecting the type of energy source or use."
    },
    {
        "id": 83,
        "simple_instruction": "I want to create a line chart of the Dow Jones Industrial Average from October 2006 to August 2013 using Python. The data is in 'data.csv' with columns \"date\", \"Dow Jones Industrial Average\" and \"1 year moving average\". Write a Python code to read the data and draw two lines on the chart. You should also color the area between the lines based on certain rules. Then add a title, labels, and a legend, and make sure the dates are readable.",
        "expert_instruction": "I want to plot a line graph of the Dow Jones Industrial Average (DJIA) from October 2006 to August 2013.\nThe data is in 'data.csv'\nThe data contains three columns:\ndate: The date of the record.\nDow Jones Industrial Average: The daily closing value of the DJIA.\n1 year moving average: The 1-year moving average value of the DJIA.\nWith this data, you can plot the line graph using Python. Here's how you can do it:\n\n- Read the data from the CSV file using pandas.\n- Convert the date column to datetime for proper plotting.\n- Plot the daily DJIA values and the 1-year moving average as lines on the graph.\n- Fill the area between the lines with the appropriate colors using the fill_between method.\n- Set the title of the graph and labels for the X and Y axes.\n- Adjust the X-axis to display the dates in a readable format.\n- Add a legend to the graph."
    },
    {
        "id": 84,
        "simple_instruction": "I want to create a phase diagram of water using Python. The data is in a file called 'data.csv'.\n\n- First, you should set up the chart with a horizontal axis for temperature and a vertical axis for pressure. These should be marked in Celsius, Kelvin, Pascals, bars and millibars, with conversions where necessary.\n- Next, you should use the data to draw the lines that separate the solid, liquid, and gas phases of water. Use columns 1 and 2 of data to draw the line that separates the solid, liquid, and gas phases. Use columns 3 and 4 to draw the line that separates the solid and liquid phases.\n- You should also mark two special points: the triple point at 273.16 K and 611.657 Pa, where solid, liquid, and gas coexist, and the critical point at 647.396 K and 22.064 MPa, where there's no difference between liquid and gas.\n- You should draw two vertical red lines to show the freezing and boiling points of water at normal pressure.\n- Make sure to label everything clearly, and color the different regions to show the solid, liquid, and gas phases.\n- Finally, you should add a grid to make the chart easier to read, and ensure the pressure scale is logarithmic, since phase diagrams often cover a wide range of pressures.",
        "expert_instruction": "Write a python script to draw the phase diagram of water with the provided data, named \"data.csv\":\n1. Prepare the Axes:\n- Create a horizontal axis for temperature, marking one scale in Celsius (0\u00b0C to 100\u00b0C) and another in Kelvin (273.15 K to 647.396 K). These scales should be aligned so that each temperature in Celsius matches its corresponding value in Kelvin.\n- Create a vertical axis for pressure, marking one scale in Pascals (from 611.657 Pa to 22.064 MPa, possibly using a logarithmic scale for better visualization) and another in bars and millibars. Align these scales so that, for example, 100 kPa corresponds with 1 bar.\n- Set X1 to x1 - 273.15 to convert Kelvin to Celsius for the top X-axis. Set Y1 to y1/100000 to convert Pascals to bars for the right Y-axis. Adjust the right Y-axis to have a Log10 scale type.\n2. Plot the Phase Boundaries:\n- Utilize columns 1 and 2 from your data to plot the boundary line between the solid, liquid, and gas phases, curving from the triple point to the critical point.\n- Use columns 3 and 4 to plot the boundary between solid and liquid phases, which typically curves less dramatically than the solid-liquid-gas line.\n3. Highlight Special Points:\n- Mark the triple point at 273.16 K and 611.657 Pa, where solid, liquid, and gas coexist.\n- Indicate the critical point at 647.396 K and 22.064 MPa, where the distinction between liquid and gas phases ends.\n4. Insert Red Lines:\n- Draw a vertical red line at 0\u00b0C and 273.15 K to represent the freezing point at 1 atm, intersecting the solid-liquid boundary.\n- Add another vertical red line at 100\u00b0C and 373.15 K for the boiling point at 1 atm, intersecting the liquid-gas boundary.\n5. Label and Color-Code:\n- Clearly label each axis with its respective units.\n- Color the different regions of the diagram to represent the solid (blue), liquid (green), and gas (yellow) phases.\n- Annotate the diagram with the special points and the red lines, including their corresponding temperature and pressure values.\n6. Grid and Scale:\n- It may be helpful to include a grid to accurately read off pressures and temperatures at various points on the diagram.\n- Ensure that the scale is logarithmic for pressure if you are spanning wide ranges, as phase diagrams often do."
    },
    {
        "id": 85,
        "simple_instruction": "To plot a circular dendrogram from \"data.csv\". This DNA Microarray data of 73 lung tissues including 67 lung tumors. There are 916 observations of genes for each lung tissue. Write a python code to plot a circular dendrogram using this data.\n1. Load and Prepare Data:\n  - Read \"data.csv\" into a DataFrame and exclude the first column with gene identifiers. Transpose the matrix to have tissues as columns and genes as rows.\n2. Hierarchical Clustering:\n  - Perform hierarchical clustering using correlation as the distance and 'average' linkage. Extract dendrogram data (linkage points and distances).\n3. Circular Dendrogram Transformation and Plotting:\n  - Convert the dendrogram coordinates into a circular format, ensuring that the coordinates encompass a full 360-degree range. Plot the transformed data on a polar coordinate system, forming branches of the dendrogram.\n4. Enhancement and Annotation:\n  - Color-code branches by clusters, label tissue samples at the perimeter, and design a correlation axis with higher correlations near the center. Clearly indicate the clustering method and distance type used.",
        "expert_instruction": "I have a data named \"data.csv\". This DNA Microarray data of 73 lung tissues including 67 lung tumors. There are 916 observations of genes for each lung tissue. Write a python code to plot a circular dendrogram using this data.\n1. Matrix Reconfiguration:\n  - Organize the data matrix with 916 rows, each representing a gene, and 73 columns for the lung tissues, excluding the first column of gene identifiers.\n2. Hierarchical Clustering:\n  - Apply hierarchical clustering to the transposed matrix (if needed) so that each column represents a lung tissue sample, and each row represents a gene observation.\n3. Dendrogram Data:\n  - Post-clustering, extract the dendrogram structure with linkage points (icoord) and correlation distances (dcoord).\n4. Circular Layout Transformation:\n  - Transform icoord into angles around a circle, distributing tissue samples evenly.\n  - Convert dcoord to radial coordinates inversely related to correlation, with higher correlations near the center.\n5. Circular Dendrogram Plotting:\n  - Plot the dendrogram on a polar coordinate system.\n  - Form branches by connecting points with angular (theta) and radial (r) coordinates.\n6. Branches and Cluster Coloring:\n  - Assign colors to branches to represent different clusters, ensuring consistency within and distinction between clusters.\n7. Lung Tissue Sample Labeling:\n  - Label each sample at the circle's edge corresponding to each branch endpoint, preferably with unique identifiers or abbreviations.\n8. Correlation Axis Implementation:\n  - Design the correlation axis so that higher correlations are near the center and lower correlations are towards the outer edge.\n9. Methodological Details:\n  - Clearly indicate the distance and clustering method used, typically near the bottom or center of the circular dendrogram."
    },
    {
        "id": 86,
        "simple_instruction": "The data from the CSV file \"data.csv\" consists of a table where:\nThe first column lists the Windows operating system versions (WinXP, Win7, Win8.1, Win10).\nThe subsequent columns represent the years from 2015 to 2019.\nEach cell in the table contains the market share percentage of the corresponding Windows version for that year.\n- Create a doughnut chart titled \"Desktop Windows Version Market Share Worldwide,\" displaying the market share from 2015 to 2019.\n- Each concentric ring in the chart represents a different year, with the innermost ring representing 2015 and the outermost representing 2019.\n- Assign distinct color families to each Windows version (WinXP, Win7, Win8.1, Win10), with the colors progressively darkening for each subsequent year.\n- Directly annotate each segment with its respective market share percentage.\n- At the top of each ring, include a white section representing the market share of other operating systems for that year. Inside this white section, label the corresponding year.\n- Ensure that the white sections for all years are aligned at the top of their respective rings.\n- Place a legend in the central blank area of the doughnut chart, indicating the colors associated with each Windows version.\n- The design should align the white sections visually for easy comparison and maintain a uniform appearance.\nThis design will clearly showcase the market share changes of different Windows versions over time, while elegantly including data for other operating systems.",
        "expert_instruction": "The data from the CSV file \"data.csv\" consists of a table where:\nThe first column lists the Windows operating system versions (WinXP, Win7, Win8.1, Win10).\nThe subsequent columns represent the years from 2015 to 2019.\nThe column name is [\"Version\",\"2015\",\"2016\",\"2017\",\"2018\",\"2019\"].\nEach cell in the table contains the market share percentage of the corresponding Windows version for that year.\nWrite a Python code to draw a graph displaying the market share of various Windows versions from 2015 to 2019 using a doughnut chart with multiple tightly packed rings. Here are the specifications:\n- Title: The chart should be titled \"Desktop Windows Version Market Share Worldwide.\"\n- Rings: Each ring in the doughnut chart represents a year, starting from the center with 2015 and moving outwards to 2019. The rings should be tightly packed together, with no visible gaps between consecutive years.\n- Color Palettes: Different Windows versions are represented by distinct color palettes, with variations in shade for different years. For instance, WinXP could use a range of blue tones, Win7 red tones, Win8.1 green tones, and Win10 purple tones. The shades should progressively darken from the center to the outer rings to represent the passage of time from 2015 to 2019.\n- Segment Labels: Label segments with their respective market share percentages directly on them. The color shades should be lighter near the doughnut's center and darker towards the edge.\n- Other Versions: Use white segments to represent the market share of other Windows versions not listed. Each white segment should be positioned at the top of its respective ring, with all white segments across the years aligned vertically for visual consistency and easy comparison.\n- Legend: Include a legend at the chart's center, indicating which color palette corresponds to each Windows version.\n- Version Order: The order of the Windows versions should be the same for each year to achieve alignment. The reference order is WinXP, Win8.1, Win7, Win10.\nThe key addition here is the alignment of the white segments (representing other versions) at the top of each ring, ensuring they are vertically aligned across the years for a uniform appearance and straightforward comparison."
    },
    {
        "id": 87,
        "simple_instruction": "Utilize the following data columns from 'data.csv' to create a sunburst plot:\n- 'country': for the names of the countries,\n- 'continent': to indicate which continent each country is in,\n- 'lifeExp': showing the expected lifespan in each country,\n- 'pop': representing the population of each country.\nYour chart should:\n- Organize the data hierarchically, starting with continents and then breaking down into countries.\n- Use the population of each country to determine the size of its segment in the chart.\n- Color code each segment by the country's expected lifespan, transitioning from red to blue across the range of values.\n- Set the central value of the color scale to the average lifespan, weighted by the population of the countries.\n- Finally, include a legend to help interpret the lifespan values as indicated by the color coding.",
        "expert_instruction": "Use data.csv to plot a sunburst chart.\n- The hierarchy is defined by the 'continent' and 'country' columns.\n- The size of each segment is determined by the 'pop' column (population).\n- The color of each segment is determined by the 'lifeExp' column (life expectancy).\n- The color scale is a diverging scale that goes from red to blue ('RdBu').\n- The midpoint of the color scale is the weighted average of the 'lifeExp' values, with the weights being the 'pop' values.\n- Add A color bar as a legend for the 'lifeExp' column."
    },
    {
        "id": 88,
        "simple_instruction": "The task is to write a Python code that uses a CSV file named 'data.csv'. Load a CSV file 'data.csv' with columns 'Major Area', 'Regions', 'Country', and 'Overall score'. Treat 'NA' in 'Regions' as a string, not a missing value. Then, using this DataFrame, create a sunburst chart.The center of the circle should be hollow. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. The legend on the chart indicates the color coding for different regions: Europe (dark green), Asia (yellow), Americas (blue), Oceania (purple), and Africa (green), which correspond to the sections of the sunburst chart. The center of the circle should be hollow. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'. \nFinally, the chart should be saved as an image file with dimensions of 1000x1000 pixels.",
        "expert_instruction": "My dataset is a CSV file named 'data.csv' containing the following columns:\n- Major Area: A string column representing the highest level of the hierarchy, such as continents or geopolitical regions.\n- Regions: A string column representing subdivisions within the Major Area. If a particular area does not fall into a region, it should be marked as 'NA', which will be treated as a regular string, not as a missing value.\n- Country: A string column with the name or code for each country, nested within Regions.\n- Overall score: A numeric column representing some quantifiable score attributed to each country.\nWrite a python code to plot a sunburst chart. Ensure that 'NA' values are treated as regular strings and not as missing values. Then, using this DataFrame, create a sunburst chart.The center of the circle should be hollow. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. The legend on the chart indicates the color coding for different regions: Europe (dark green), Asia (yellow), Americas (blue), Oceania (purple), and Africa (green), which correspond to the sections of the sunburst chart. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'.\nOnce the chart is created, save it as an image file with dimensions of 1000x1000 pixels."
    },
    {
        "id": 89,
        "simple_instruction": "I have a CSV file named 'data.csv' containing columns for \"Browser\", \"Version\", and \"Data\". I wish to create a chart with two concentric rings: the inner ring to display browser names, and the outer ring to show the various versions of these browsers. Each version in the outer ring should be clearly labeled with lines pointing to the segments. Visible gaps between both rings and within the segments will enhance readability. The browser names will be written directly on the segments of the inner ring. The center of the chart will be hollow, creating a donut-like appearance. The chart should be titled 'Browser Market Share'.",
        "expert_instruction": "I have a dataset named \"data.csv\" containing browser market share information in a CSV format with the following columns:\n- Browser: The name of the web browser.\n- Version: The specific version number of the browser.\n- Data: The market share percentage associated with each browser version.\nI want to create a two-layered sunburst chart to visualize this data. The chart should be designed as follows:\n- The inner layer should represent different browsers, with the browser names (Browser column) written on the segments.\n- The outer layer should depict the versions of these browsers (Version column), with labels and lines pointing to the specific data points on the chart's edge.\n- There should be white gaps between the layers and also between the segments within each layer for visual separation.\n- The center of the chart should be hollow, creating a donut-like appearance.\nPlease generate the sunburst chart using Python, ensuring that the 'Browser' and 'Version' columns are used for the hierarchical structure, and the 'Data' column is used to determine the size of each segment. The chart should be titled 'Browser Market Share'."
    },
    {
        "id": 90,
        "simple_instruction": "The task is to write a Python code that uses a CSV file named 'data.csv'. Load a CSV file 'data.csv' with columns 'Major Area', 'Regions', 'Country', and 'Overall score'. Treat 'NA' in 'Regions' as a string, not a missing value. The code should plot a sunburst chart using plotly, structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' providing the values for each segment. In the sunburst chart, regions' colors reflect the average scores of their countries, and continents' colors are averages of their regions. The color legend aligns shades with score ranges for easy comparison of hierarchical levels. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'. \nFinally, the chart should be saved as an image file with dimensions of 1000x1000 pixels.",
        "expert_instruction": "My dataset is a CSV file named 'data.csv' containing the following columns:\n- Major Area: A string column representing the highest level of the hierarchy, such as continents or geopolitical regions.\n- Regions: A string column representing subdivisions within the Major Area. If a particular area does not fall into a region, it should be marked as 'NA', which will be treated as a regular string, not as a missing value.\n- Country: A string column with the name or code for each country, nested within Regions.\n- Overall score: A numeric column representing some quantifiable score attributed to each country.\nWrite a python code to plot a sunburst chart. Ensure that 'NA' values are treated as regular strings and not as missing values. Then, using this DataFrame, create a sunburst chart with plotly. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. \nIn the sunburst chart, the score of a region is represented as the average of its constituent countries' scores, and similarly, the score of a continent is depicted as the average of its regions' scores. The color intensity for each segment within the chart corresponds to these average scores, with darker shades indicating higher scores and lighter shades for lower scores. The accompanying color legend maps these shades to specific score ranges, allowing for quick visual comparison across different hierarchical levels.\n The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'.\nOnce the chart is created, save it as an image file with dimensions of 1000x1000 pixels."
    },
    {
        "id": 91,
        "simple_instruction": "Create a 3D Waterfall plot using the 'data.csv' file, where the first column represents time and the subsequent columns represent time-series data for different frequencies. Each frequency should be plotted as a separate line, distinctly colored and marked, and displayed on different y-coordinates to avoid overlap. For clarity, add a light grey fill below each line. Set the camera to -69 degrees azimuth and 15 degrees elevation for optimal viewing. Ensure the y-axis is elongated to twice the length of the x-axis to distinctly space the frequency lines. Remove y-axis ticks. Label the axes appropriately: 'Time (sec)' for the x-axis, 'Frequency (Hz)' for the y-axis, and 'Amplitude (a.u.)' for the z-axis.",
        "expert_instruction": "Create a 3D Waterfall plot using the 'data.csv' file, which consists of a first column for time and subsequent columns for time-series data representing different frequencies. Ensure the y-axis is elongated to twice the length of the x-axis to distinctly space the frequency lines. Each frequency should be plotted as a separate line, distinctly colored and marked, and displayed on different y-coordinates to avoid overlap. Below each line, add a light grey fill for visual clarity. Adjust the plot's camera to an azimuth of -69 degrees and an elevation of 15 degrees to prevent overlap and make the data more discernible. Remove the scale from the y-axis for a neater appearance. Label the axes appropriately: 'Time (sec)' for the x-axis, 'Frequency (Hz)' for the y-axis, and 'Amplitude (a.u.)' for the z-axis. The final plot should display with a customized aspect ratio highlighting the stretched y-axis."
    },
    {
        "id": 92,
        "simple_instruction": "Create a stacked radial plot from \"data.csv\" showcasing 'Pollution Index' and 'Water Temp' with distinct white rings for separation. Begin with a hollow center for clarity. Draw two lines from the center to the edge: one to depict 'Pollution Index' in red and another for 'Water Temp' in a shade of blue. Between the two sets of data, maintain a white ring to visually separate them. Fill the region from the blue line representing 'Water Temp' to the white ring with a semi-transparent blue, and similarly, fill from the red line representing 'Pollution Index' to the hollow center with a semi-transparent red. Ensure the plot label the angular axes with dates formatted as 'YYYY-MM-DD' to prevent overlap. The visualization should be finalized with a clear title 'Stacked Radial Plots with Hourly Data' and a legend that differentiates the datasets.",
        "expert_instruction": "To create a radial plot from the \"data.csv\" file that visualizes the 'Pollution Index' and 'Water Temp', with a distinct design featuring two white rings for separation, follow these instructions:\n1. Load the \"data.csv\" file, ensuring to parse the 'Time' column as datetime, formatted as \"%Y-%m-%d %H:00:00\", and set it as the index.\n2. Create a radial plot to display 'Pollution Index' and 'Water Temp' without averaging the data, making each time point distinct.\n3. Offset the 'Water Temp' values to create a white ring that visually separates it from the 'Pollution Index', providing a clear delineation between the two data sets.\n4. Add another white ring at the center of the plot to anchor the design and enhance readability.\n5. Adjust the radial limits to be 10% greater than the maximum data values, ensuring the entire range of data is comfortably within view.\n6. Choose different semi-transparent colors for the 'Pollution Index' and 'Water Temp' to allow for visual overlap where necessary.\n7. Remove the radial grid labels to simplify the presentation.\n8. Set angular ticks to correspond with the unique dates from the data, formatted neatly as 'YYYY-MM-DD'.\n9. Include a descriptive title and a legend, clearly identifying the two variables.\n10. Ensure that the date labels are evenly spaced around the circumference of the plot, avoiding overlap and maintaining legibility."
    },
    {
        "id": 93,
        "simple_instruction": "Create a 3D plot from a CSV file named \"data.csv\" using the columns \"t\", \"bond 1-2\", \"bond 1-14\", and \"tot energy / Eh\" to visualize an ab initio molecular dynamics (AIMD) calculation of an ion pair. The plot should have three axes: two for the bond lengths (\"bond 1-2\" and \"bond 1-14\") and one for the total energy in Hartrees (Eh). Color the points along the trajectory from red (start) to blue (end) using the jet color map to represent time progression. Include larger, semi-transparent markers for each point, with connecting lines to show the trajectory. Add semi-transparent projection lines onto the XY, XZ, and YZ planes in blue, red, and green, respectively. Include a legend for these projection lines and a color bar legend to indicate time in femtoseconds. Label the axes as \"Bond 1-2\", \"Bond 1-14\", and \"Total Energy / Eh\" and format the z-axis labels for clarity.",
        "expert_instruction": "Create a 3D plot that visualizes the trajectory of an ab initio molecular dynamics (AIMD) calculation of an ion pair. The data for this plot is loaded from a CSV file named \"data.csv\", using the columns \"t\", \"bond 1-2\", \"bond 1-14\", and \"tot energy / Eh\" for the three dimensions. The plot will have three axes: two representing selected bond lengths and one representing the total energy in Hartrees (Eh). \nThe points on the plot are colored according to time intervals, with the start of the trajectory in red and the end in blue. The color map and normalization for the trajectory points are defined using the jet color map from matplotlib. \nThe plot includes markers for each point on the trajectory, which are larger and semi-transparent. The trajectory is also represented with connecting lines between the points. \nIn addition to the 3D trajectory, the plot also includes semi-transparent projection lines onto the XY, XZ, and YZ planes. These projection lines are colored in blue, red, and green respectively. \nA legend is added to the plot for the projection lines. A color bar legend is also added on the left side of the plot, representing the time in femtoseconds. \nThe axes of the plot are labeled as \"Bond 1-2\", \"Bond 1-14\", and \"Total Energy / Eh\". The z-axis labels are formatted to reduce their length and prevent overlap."
    },
    {
        "id": 94,
        "simple_instruction": "Create a chord diagram titled \"Mobile Phone Brand Switching Behavior\" using Holoviews with Bokeh backend. The data represents transitions between Samsung, Apple, Huawei, and Other Android.\ndata = pd.DataFrame({\n    'Samsung': [0.2925, 0.0195, 0.0117, 0.0663],\n    'Apple': [0.0224, 0.2816, 0.0032, 0.0128],\n    'Huawei': [0.0288, 0.0063, 0.0279, 0.027],\n    'Other Android': [0.042, 0.008, 0.01, 0.14]\n}, index=['Samsung', 'Apple', 'Huawei', 'Other Android'])\nConvert the matrix into a links list with source, target, and value, omitting zero values. Create a corresponding nodes list. Customize the diagram with a colormap, ensuring smooth transitions for self-links and clear labels. Display the share of each brand on the outer arc. Save the visual as an image and include the source label: \"Source: Deloitte Global Mobile Consumer Survey 2019, NL edition\"",
        "expert_instruction": "Create a chord diagram titled \"Mobile Phone Brand Switching Behavior\"  using Holoviews with Bokeh backend to visualize mobile brand switching probabilities between Samsung, Apple, Huawei, and Other Android. The data is a matrix representing transitions between Samsung, Apple, Huawei, and Other Android.\ndata = pd.DataFrame({\n    'Samsung': [0.2925, 0.0195, 0.0117, 0.0663],\n    'Apple': [0.0224, 0.2816, 0.0032, 0.0128],\n    'Huawei': [0.0288, 0.0063, 0.0279, 0.027],\n    'Other Android': [0.042, 0.008, 0.01, 0.14]\n}, index=['Samsung', 'Apple', 'Huawei', 'Other Android'])\nConvert this matrix into a links list with source, target, and value, omitting zero values. Create a corresponding nodes list, ensure all data types align. Customize the diagram's appearance with a colormap, ensuring smooth transitions for self-links and clear labels for all four categories. Display the share of each brand on the outer arc of the diagram. Finally, save the visual as an image and include the source label: \"Source: Deloitte Global Mobile Consumer Survey 2019, NL edition\"."
    },
    {
        "id": 95,
        "simple_instruction": "Create a polar coordinate diagram using data from \"data.csv\" to display the highest temperatures on the first of each month in Amherst, spanning from January 1, 2004, to August 1, 2015. The data includes columns labeled \"Year,\" \"Date,\" and \"Temperature.\" The diagram should include:\n\n- 12 sectors, each representing a month of the year.\n- Temperature data plotted according to the corresponding month.\n- Circular points for the temperature data, slightly offset to prevent alignment along a single radial line.\n- Abbreviated labels for the months (Jan, Feb, Mar, etc.).\n- A blue curve that connects the data points from the year 2015.\n- A legend positioned on the right side of the diagram.\n- A title: \"Monthly Highest Temperature in Amherst (2004-2015).\"\nThe purpose of the diagram is to clearly illustrate the temperature trends and monthly variations over the years, with an emphasis on the data from 2015.",
        "expert_instruction": "I want a polar coordinate diagram to visualize the highest temperature data in Amherst on the first of each month, spanning from January 1, 2004, to August 1, 2015. The data is named \"data.csv\". The data contains three columns: \"Year,\" \"Date,\" and \"Temperature.\" Here are My specific requirements for the visualization:\n- The diagram should be divided into 12 sectors, corresponding to the months of the year.\n- Temperature data should be plotted on the diagram according to the month.\n- The points representing the temperature data should be circular.\n- These points should be slightly offset so as not to align on a single radial line, with each point for the 1st of a month positioned between that month and the next. The offset should range from 0 to \u03c0/6 radians.\n- Month labels should be abbreviated (Jan, Feb, Mar, etc.) instead of numerical (1, 2, 3, etc.).\n- A blue curve should connect the data points for the year 2015 to distinguish it from other years.\n- The legend should be moved to the right to avoid overlapping the diagram.\nThe diagram will serve as a clear visual representation of temperature trends and variations by month over several years, with particular emphasis on the data from 2015."
    },
    {
        "id": 96,
        "simple_instruction": "Create a combination chart from the \"data.csv\" dataset, which contains sales data for various mobile phone brands across different quarters of the year. The columns in the CSV file are [\"Quarter\", \"Samsung\", \"Nokia/Microsoft\", \"Apple\", \"LG\", \"ZTE\", \"Huawei\"]. For each brand, create a box plot to represent the distribution of their sales data. On each box plot, display all the individual sales data points for that brand. Additionally, calculate the average sales for each brand and draw a line connecting these average values across the box plots. Use a consistent color scheme for the same quarter across different years, varying the shades to distinguish between years. Include a legend to aid in understanding the color coding.",
        "expert_instruction": "Write a Python code to create a combination chart from a dataset named \"data.csv\". The dataset contains sales data for various mobile phone brands (\"Samsung,\" \"Nokia/Microsoft,\" \"Apple,\" \"LG,\" \"ZTE,\" and \"Huawei\") across different quarters of the year titled \"Quarter\" (e.g., \"Q1 '10\" for the first quarter of 2010). The column of the CSV file is [\"Quarter\", \"Samsung\", \"Nokia/Microsoft\", \"Apple\", \"LG\", \"ZTE\", \"Huawei\"]. The chart should include a box plot for each brand showing the distribution of sales data across quarters, with individual sales data points represented as dots. Also, calculate the overall mean sales for each brand and draw a line connecting these points. Ensure the line points align with their respective box plots. Use a consistent color scheme for the same quarter across different years, varying the shades to distinguish between years. Include a legend to aid in understanding the color coding. The box plot should be the underlying layer, and the data points should be on top, ensuring visibility."
    },
    {
        "id": 97,
        "simple_instruction": "Create two ternary phase diagrams from the dataset \"data.csv\", containing 'No.', 'IL (25\u00b0C)', 'toluene (25\u00b0C)', and 'n-heptane (25\u00b0C)'. Each row indicates a mixture composition of these components at 25\u00b0C, with 'No.' indicating different groups or conditions.\n\nFor both diagrams:\n- Title: \"Liquid-Liquid Phase Diagram\".\n\n1. Equilateral Triangle Diagram:\n  - Plot with 'toluene' at the top, 'n-heptane' at the bottom left, and 'IL' at the bottom right.\n  - Transform component fractions to Cartesian coordinates for an equilateral layout.\n  - Plot data points as circles, connect same 'No.' group points with dashed lines, and use different colors for each group.\n  - Label each vertex with the component name and draw borders for the triangle and remove axis ticks and labels for a clean look.\n2. Right-Angled Triangle Diagram:\n  - Plot with 'IL' on the vertical axis, 'toluene' on the horizontal axis, right angle at the bottom left.\n  - Transform for a right-angled layout, similarly plot and connect points, using the same color scheme.\n  - Label axes with 'IL' and 'toluene', and draw borders for the triangle and remove axis ticks and labels for a clean look.\nDisplay both diagrams side-by-side, maintaining an equal aspect ratio for comparison.",
        "expert_instruction": "Create two ternary phase diagrams using the provided dataset named \"data.csv\". The dataset contains columns 'No.', 'IL (25\u00b0C)', 'toluene (25\u00b0C)', and 'n-heptane (25\u00b0C)', where each row represents a unique mixture composition of these three components at 25\u00b0C. The 'No.' column categorizes the data into different groups or experimental conditions.\n\nFor both diagrams:\n- Title: \"Liquid-Liquid Phase Diagram\".\n\nEquilateral Triangle Diagram:\n\n- Plot an equilateral triangle ternary diagram.\n- Position 'toluene' at the top vertex, 'n-heptane' at the bottom left vertex, and 'IL' at the bottom right vertex.\n- Convert the component fractions to Cartesian coordinates suitable for an equilateral triangle layout.\n- Plot each data point as a circle and connect points within the same 'No.' group with dashed lines.\n- Use different colors for each 'No.' group and add a legend to distinguish these groups.\n- Label each vertex of the triangle with the corresponding component name.\n- Draw borders for the triangle and remove axis ticks and labels for a clean look.\n\nRight-Angled Triangle Diagram:\n\n- Plot a right-angled triangle ternary diagram.\n- Position 'IL' on the vertical axis, 'toluene' on the horizontal axis, and have the right angle at the bottom left corner.\n- Convert the component fractions to Cartesian coordinates suitable for a right-angled triangle layout.\n- Plot each data point as a circle and connect points within the same 'No.' group with dashed lines.\n- Use the same color scheme as the equilateral diagram for consistency, and include a legend.\n- Label the vertical and horizontal axes with 'IL' and 'toluene' respectively.\n- Draw borders for the triangle and remove axis ticks and labels for a clean look.\nEnsure both diagrams are plotted side-by-side for easy comparison, and maintain an equal aspect ratio for both diagrams."
    },
    {
        "id": 98,
        "simple_instruction": "Create a multi-layered graph using Python with my data, follow these streamlined steps:\n1. Data Preparation:\n  - Load 'Imports.csv' and 'Consumption.csv'. 'Imports.csv' contains 'Year', 'Urban', and 'Rural' for grain imports, and 'Consumption.csv' has similar columns for consumption data.\n  - Load 'Grain_Consumption_Ratio.csv' for 2002, 2008, and 2016, with 'Year', 'Age Group'  (e.g., \"0-14 years old\"), and 'Consumption Ratio'.\n2. Graph Structure:\n  - Title the graph as \"Grain Import and Consumption Trends\".\n  - Create a Multi Category Waterfall Chart for urban and rural imports, with yearly changes displayed as color-coded bars, and cumulative totals represented at the end.\n  - Plot a stacked area chart for consumption data on a secondary y-axis, with translucent colors for urban and rural data.\n  - Embed pie charts for grain consumption ratios in 2002, 2008, and 2016, using an 'explode' feature for the oldest age group.\n  - Align the waterfall and area charts on a common x-axis (years), overlaying the pie charts at corresponding years.\n  - Include legends for both imports and consumption, and annotate pie charts with percentage values.\n  - Use dual y-axes for imports and consumption quantities, and adjust scales for clarity and proportionate representation.\n  - Merge and align all charts into a cohesive graph, ensuring legibility and visual flow.",
        "expert_instruction": "Write a python code using this data to plot a multi-layered graph. The data is as follows:\n1. Imports.csv: Contains columns 'Year', 'Urban', and 'Rural', detailing grain imports for urban and rural areas per year.\n2. Consumption.csv: Includes 'Year', 'Urban', and 'Rural' columns, showing yearly grain consumption in urban and rural regions.\n3. Grain_Consumption_Ratio.csv: Features 'Year', 'Age Group' (e.g., \"0-14 years old\"), and 'Consumption Ratio', depicting the percentage of grain consumption by different age groups each year.\nTo create the multi-layered graph, follow these visualization requirements:\n1. Data Preparation and Titles:\n  - Load 'Imports.csv' and 'Consumption.csv' for grain imports, and urban and rural consumption data, along with datasets for grain consumption by age groups for 2002, 2008, and 2016.\n  - Title the graph \"Grain Import and Consumption Trends\" and label axes for import quantities (kg) and consumption (kg).\n2. Multi Category Waterfall Chart for Imports:\n  - Design a waterfall chart with two categories side-by-side for each year: one for urban and another for rural imports.\n  - Start by plotting the initial import quantities for both urban and rural categories, followed by bars side by side within each year to illustrate annual changes.\n  - Apply distinct color codes to represent increases and decreases for urban and rural data.\n  - Include connecting lines within each year to illustrate the trend between urban and rural imports.\n  - The last set of bars should display the total cumulative imports for both urban and rural areas at the end of the dataset's timeline.\n3. Stacked Area Chart for Grain Consumption:\n  - Plot urban and rural consumption data on a secondary y-axis.\n  - Use translucent colors for urban and rural areas to indicate overlapping consumption.\n  - Set y-axis scale from 35 to 105 kg for consumption data.\n4. Pie Charts for Age Group Consumption Ratios:\n  - Create pie charts for 2002, 2008, and 2016 to show grain consumption distribution by age groups.\n  - Use an 'explode' feature for the oldest age group in each pie chart.\n5. Combining Charts:\n  - Align the waterfall and area charts on the same x-axis.\n  - Overlay the pie charts at their respective years without obstructing underlying data.\n6. Legends, Annotations, and Scales:\n  - Introduce legends for imports, urban, and rural consumption areas, and annotate pie charts with percentage values.\n  - Set the x-axis with years and use dual y-axes for proportional representation of imports and consumption data.\n7. Final Adjustments and Linking:\n  - Ensure all textual elements, such as axis labels and legends, are legible and strategically placed to prevent clutter.\n  - Adjust the positioning of the pie charts to correspond accurately with the years 2002, 2008, and 2016 on the x-axis.\n  - Link the scales of the primary and secondary y-axes to maintain proportionate representation of data.\n8. Graph Merging and Alignment:\n  - Merge the waterfall and area charts into a single coherent graph.\n  - Align the pie charts with the specified years, resizing them to fit within the overall graph's layout without disrupting the visual flow."
    },
    {
        "id": 99,
        "simple_instruction": "Create a dark-themed violin plot to compare the total bill amounts by day of the week from a CSV file named \"data.csv\" which includes columns \"total_bill\", \"tip\", \"sex\", \"smoker\", \"day\", \"time\", and \"size\". The plot should clearly distinguish between smokers and non-smokers using a green color for smokers and grey for non-smokers. Include split violins to show this distinction, and make sure the plot represents data quartiles inside each violin.",
        "expert_instruction": "To create a violin plot using Seaborn, you should use data from a CSV file named \"data.csv\" which includes columns \"total_bill\", \"tip\", \"sex\", \"smoker\", \"day\", \"time\", and \"size\". The plot should focus on comparing the 'total_bill' amounts for different 'day' values (days of the week), with a distinction between 'smoker' and 'non-smoker' categories. Implement split violins for this purpose, and within each violin, use quartiles to represent the data distribution. The color scheme should be green for smokers and grey for non-smokers. Adopt a dark style theme for the plot."
    },
    {
        "id": 100,
        "simple_instruction": "Use a CSV file named \"data.csv\" to create a polar plot visualizing electron transitions in an atom, with the plot representing only the top half of a circle (semi-circle). The file has columns 'Series', 'Wavelength', 'l position', and 'p position'. The plot should represent only the top half of a circle (semi-circle) and include the following elements:\n1. The semi-circle's radius should be divided into 6 concentric regions representing energy levels 1 to 6, with clear black lines separating them. Label the left side of the semi-circle with '1n' to '6n' indicators for each energy level, and the right side with corresponding energy values '0 eV' to '13.22 eV'.\n2. Electron transitions, indicated by arrows within the semi-circle, should originate from the 'l position' (lower energy level) and point to the 'p position' (higher energy level). Arrows should be evenly spaced to avoid overlap, and each should be annotated with its transition wavelength at the head, just outside the semi-circle.\n3. Color-code the transitions based on their series, like 'Lyman Series', 'Balmer Series', 'Paschen Series', etc., and use a lighter shade of the same color to highlight the angular range of each series.\n4. Ensure the plot is clear and legible, with no overlapping text or arrows. Exclude radial gridlines, radial ticks, or angle labels.\n5. Title the plot \"Electron Transitions for an Atom\".\nThe data should be sorted by the 'Series' column, and all labels and annotations should be easily readable. The plot should effectively represent the data in a visually appealing and scientifically accurate manner.",
        "expert_instruction": "Use a CSV file named \"data.csv\" to create a polar plot visualizing electron transitions in an atom, with the plot representing only the top half of a circle (semi-circle). The file has columns 'Series', 'Wavelength', 'l position', and 'p position'. Sort the data by the 'Series' column and group the transitions accordingly. \n\n1. The plot should be a semi-circle representing the top half of a polar coordinate system. The radius of the semi-circle should be divided into 6 concentric regions, each representing an energy level, numbered from 1 to 6 starting from the center. Black lines should separate these regions to clearly distinguish the different energy levels.\n2. Label the left side of the semi-circle with energy level indicators '1n' through '6n', with '1n' closest to the center and '6n' at the outer edge. These labels should be aligned with the divisions between the regions.\n3. Label the right side of the semi-circle with the energy values '0 eV', '10.2 eV', '12.09 eV', '12.75 eV', '13.06 eV', '13.22 eV', with '0 eV' closest to the center and '13.22 eV' at the outer edge. These labels should be aligned with the corresponding energy level divisions.\n4. Electron transitions should be represented by arrows within the semi-circle. Each arrow should start at the radial position corresponding to the 'l position' (lower energy level) and point towards the radial position corresponding to the 'p position' (higher energy level). Arrows should be evenly distributed across the semi-circle, with equal angular spacing between them to ensure clarity and avoid overlap.\n5. Annotate each arrow with the wavelength of the transition, placing the label at the head of the arrow, just outside the semi-circle.\n6. Group the transitions by series, such as 'Lyman Series', 'Balmer Series', 'Paschen Series', etc., and use different colors for each series. Highlight each series by filling the angular range it occupies with a lighter shade of the same color.\n7. Ensure the plot is clear, with no overlapping text or arrows, and all labels and annotations are easily readable.\n8. The plot should not display any radial gridlines, radial ticks, or angle labels, and should have a title \"Electron Transitions for an Atom\" at the top."
    }
]