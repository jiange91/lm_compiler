[
    {
        "simple_instruction": "Generate a series of boxplots using matplotlib and numpy libraries. The boxplots should include a basic plot, a notched plot, a plot with changed outlier point symbols, a plot without outlier points, a horizontal boxplot, and a plot with changed whisker length. The data for these plots should be randomly generated and reproducible. Each subplot should have one boxplot. The plots should be arranged in two rows and three columns.",
        "expert_instruction": "1. Import the required libraries: matplotlib.pyplot and numpy.\n2. Import the Polygon module from matplotlib.patches.\n3. Set the random seed for reproducibility using np.random.seed(19920215).\n4. Generate new fake data for the plot by creating arrays: spread, center, flier_high, flier_low, and data.\n   - Generate the spread array by multiplying np.random.rand(50) by 100.\n   - Generate the center array by multiplying np.ones(25) by 60.\n   - Generate the flier_high array by adding np.random.rand(10) multiplied by 100 to 150.\n   - Generate the flier_low array by multiplying np.random.rand(10) by -100.\n   - Concatenate the spread, center, flier_high, and flier_low arrays into the data array.\n5. Create a figure and subplots.\n6. Plot the basic boxplot on the first subplot and set the title to 'basic plot'.\n7. Plot a notched boxplot on the second subplot and set the title to 'notched plot'.\n8. Change the outlier point symbols on the third subplot and set the title to 'change outlier point symbols'.\n9. Create a boxplot without showing the outlier points on the fourth subplot and set the title to \"don't show outlier points\".\n10. Create a horizontal boxplot on the fifth subplot and set the title to 'horizontal boxes'.\n11. Change the whisker length on the sixth subplot and set the title to 'change whisker length'.\n12. Adjust the spacing and layout of the subplots using.\n13. Display the plot.",
        "id": 1
    },
    {
        "simple_instruction": "Create a 3x3 grid of subplots using matplotlib, with shared x-axis for each column and y-axis for each row. Ensure there is no spacing between all the subplots. The overall title of the figure should be 'Sharing x per column, y per row'. The subplots should contain the following plots:\n\n1. `z` against `w`.\n2. `z**3` against `w` in blue.\n3. `-z` against `w + 1` in yellow.\n4. `-z**3` against `w + 2` in purple.\n5. `z**2` against `w**2` in brown.\n6. `-z**2` against `w**2 + 1` in pink.\n7. `z**2` against `-w**2 + 2` in grey.\n8. `-z**2` against `-w**2 + 3` in black.\n9. `z` against `-w` in white.\n\nOnly the outermost subplots should be labeled.",
        "expert_instruction": "1. Begin by creating a new visual representation using matplotlib's function that generates a new figure.\n2. Add a 3x3 grid to the figure using the function that allows you to add a grid specification, with no horizontal or vertical space between the plots.\n3. Create nine subplots within this grid, sharing the x-axis for each column and the y-axis for each row. Assign these subplots to nine variables: `ax1`, `ax2`, `ax3`, `ax4`, `ax5`, `ax6`, `ax7`, `ax8`, and `ax9`.\n4. Set the overall title of the figure to 'Sharing x per column, y per row' using the function that sets a super title.\n5. Plot `z` against `w` on the first subplot (`ax1`).\n6. Plot `z**3` against `w` on the second subplot (`ax2`), and use the color blue for the plot.\n7. Plot `-z` against `w + 1` on the third subplot (`ax3`), and use the color yellow for the plot.\n8. Plot `-z**3` against `w + 2` on the fourth subplot (`ax4`), and use the color purple for the plot.\n9. Plot `z**2` against `w**2` on the fifth subplot (`ax5`), and use the color brown for the plot.\n10. Plot `-z**2` against `w**2 + 1` on the sixth subplot (`ax6`), and use the color pink for the plot.\n11. Plot `z**2` against `-w**2 + 2` on the seventh subplot (`ax7`), and use the color grey for the plot.\n12. Plot `-z**2` against `-w**2 + 3` on the eighth subplot (`ax8`), and use the color black for the plot.\n13. Plot `z` against `-w` on the ninth subplot (`ax9`), and use the color white for the plot.\n14. Finally, loop through all the axes in the figure using the function that retrieves all axes, and call the function on each axis to only label the outermost subplots.\n\"\"\"",
        "id": 2
    },
    {
        "simple_instruction": "Generate a nested pie plot using a bar plot method in polar coordinates. The plot should be based on a numerical array `data` with values [[80., 20.], [50., 50.], [40., 60.]]. Normalize this data to 2 pi. Use a colormap that provides a range of 20 colors to create two color arrays. Create two pie plots that are nested together with a blank center that is not filled in, the two rings should have the same thickness. The rings should have a white edge with line width of 1 to clearly delineate each segment, and they should be aligned at the edge of each bar segment for visual consistency. The outer pie plot should use the sum of the normalized data for the width and the inner pie plot should use the flattened normalized data for the width. Use outer_colors = cmap(np.arange(3)*4), inner_colors = cmap([1, 2, 5, 6, 9, 10]) to paint the nested pie chart. The title of the plot should be 'Pie plot with bar method and polar coordinates'. The axis should be turned off.",
        "expert_instruction": "Create a nested pie plot that utilizes the creation of bar plots in polar coordinates. Start by creating a subplot with a polar projection.\n\nNext, define a variable `thickness` with a value of 0.2 and a numerical array `data` with the values [[80., 20.], [50., 50.], [40., 60.]]. Normalize `data` to 2 pi and store it in `data_norm`. Then, calculate the ordinates of the bar edges and store them in `data_left`.\n\nDefine a colormap using a colormap from the data visualization library that provides a range of 20 colors and assign it to the variable `color_map`. Create two color arrays, `outer_colors` and `inner_colors`, using different ranges from the colormap.\n\nThen, create two bar plots using the method that allows for the creation of bar plots. The first bar plot should use the first column of `data_left` for the x-values, the sum of `data_norm` along axis 1 for the width, 1-thickness for the bottom, thickness for the height, `outer_colors` for the color, 'w' for the edgecolor, 1 for the linewidth, and align the edges. The second bar plot should use the flattened `data_left` for the x-values, the flattened `data_norm` for the width, 1-2*thickness for the bottom, thickness for the height, `inner_colors` for the color, 'w' for the edgecolor, 1 for the linewidth, and align the edges. The second bar plot should be wrapping the first one.\n\nFinally, set the title of the plot to \"Pie plot with bar method and polar coordinates\", turn off the axis, and display the plot.",
        "id": 6
    },
    {
        "simple_instruction": "Generate a Python script that creates a polar bar plot using a fixed seed for random number generation to ensure reproducibility. The plot should have 30 bars, with their positions, diameters, and thicknesses determined by linearly spaced and random values respectively. The colors of the bars should range from dark to light based on the normalized diameters. The transparency of the bars should be set to 0.5.",
        "expert_instruction": "1. Import the necessary modules for plotting and numerical operations.\n2. Set a fixed state for random number generation to ensure the results are reproducible. Use the seed value 12345678.\n3. Compute the slices for a pie chart by first defining a variable, let's call it M, with a value of 30.\n4. Create a variable, let's name it alpha, that is a linearly spaced array from 0.0 to 2 times a certain mathematical constant that represents the ratio of the circumference of a circle to its diameter, with M number of samples and without including the endpoint.\n5. Create a variable, let's call it diameters, that is an array of M random numbers, each multiplied by 20.\n6. Create a variable, let's name it thickness, that is an array of M random numbers, each multiplied by the aforementioned mathematical constant divided by 3.\n7. Create a variable, let's call it hues, that uses a color map from the plotting module to map the normalized diameters values to colors. Use a color map that provides a range of colors from dark to light.\n8. Create a subplot with polar projection and store it in a variable, let's call it chart.\n9. Use a method of chart to create a bar plot with alpha as the x values, diameters as the y values, thickness as the width of the bars, 0.0 as the bottom of the bars, hues as the color of the bars, and 0.5 as the alpha value of the bars.\n10. Finally, display the plot.",
        "id": 7
    },
    {
        "simple_instruction": "Generate a Python script using matplotlib to create a 4x4 inch figure that plots a line based on array 'x' from 0.0 to 10.0 (step 0.02) against 'y' which is sine(3pix). Annotate the midpoint at x=5 and the peak of the sine curve. Place an annotation of 'data point (4, sin(12pi))' at that data point and use an arrow to point at it. Place 'Sine Curve' text in the top-left using axis coordinates and 'Created by PlotAgent' in the bottom-right using figure coordinates. Add arrows pointing to the midpoint and peak annotations. Set the x-axis limit from -2 to 10 and the y-axis limit from -6 to 6.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computations.\n2. Create a figure with a size of 4x4 using a function from the data visualization library.\n3. Generate an array 'x' using a function from the numerical computation library, starting from 0.0, ending at 10.0 with a step of 0.02.\n4. Create another array 'y' which is the sine of 3*pi*x.\n5. Plot a line on the axes using 'x' and 'y'.\n6. Add an annotation 'Sine Curve' at position (0.05, 0.95) in axes fraction, aligned to the left and top with a font size of 20.\n7. Add another annotation 'Created by PlotAgent' at position (0.95, 0.05) in figure fraction, aligned to the right and bottom with a font size of 12.\n8. Add two more annotations with arrows pointing to data points. The first one should be 'Midpoint' at position (4, sin(12pi)) in data coordinates, with an arrow with a black face color and a shrink factor of 0.05. The second one should be 'Peak' at position (4, 1) in data coordinates, with an arrow with a black face color and a shrink factor of 0.05.\n9. Finally, set the x-axis limit from -2 to 10 and the y-axis limit from -6 to 6.",
        "id": 9
    },
    {
        "simple_instruction": "\"Could you assist me in creating a Python script that generates a plot with the following specifications?\n\n1. The plot should contain three lines. The first line should represent the square of a numerical sequence ranging from 0.0 to 3.0 in increments of 0.02. The second line should represent the cosine of '3*pi' times the same sequence, displayed with a dashed line and circle markers. The third line should represent the product of the square of the sequence and the cosine of '3*pi' times the sequence, displayed with a line style of 's-.'.\n\n2. The plot should also include a numerical sequence ranging from 0.0 to 3.0 in increments of 0.2, plotted against the square root of '1' plus the sequence, displayed with dot markers.\n\n3. The plot should have a legend in the upper left corner, with shadows, labeling the second line as 'oscillatory' and the third line as 'damped'.\n\n4. The x-axis should be labeled as 'time' and the y-axis as 'amplitude'. The title of the plot should be 'Damped oscillation'.\n\nCould you help me with this?\"",
        "expert_instruction": "Could you assist me in creating a Python script that accomplishes the following tasks?\n\n1. First, we need to import some libraries. We'll need one for plotting graphs, one for numerical operations, one for handling collections in our plot, one for managing the legend in our plot, and one for dealing with lines in our plot.\n\n2. Next, we need to create two numerical sequences. Let's call them 'x1' and 'x2'. 'x1' should range from 0.0 to 3.0 in increments of 0.2, and 'x2' should range from 0.0 to 3.0 in increments of 0.02.\n\n3. We'll need to set up a figure and a set of axes for our plot. There's a function in our plotting library that can create a subplot for us.\n\n4. Now, let's plot four lines on our axes. The first line should plot 'x2' against the square of 'x2'. The second line should plot 'x2' against the cosine of '3*pi*x2' with a dashed line and circle markers. The third line should plot 'x1' against the square root of '1+x1' with dot markers. The fourth line should plot 'x2' against the product of the square of 'x2' and the cosine of '3*pi*x2', with a line style of 's-.'.\n\n5. We should add a legend to the upper left of the axes, with shadows, labeling the second line as 'oscillatory' and the fourth line as 'damped'.\n\n6. Let's label the x-axis as 'time' and the y-axis as 'amplitude'. We should also set the title of the axes as 'Damped oscillation'.\n\n7. Lastly, we need to display the plot. There's a function in our plotting library that can do this for us.\n\nCould you help me with this?",
        "id": 10
    },
    {
        "simple_instruction": "Generate a Python script that creates a subplot mosaic with six sections. The first row should contain two bar plots with the same data but different hatch patterns. The second row should also contain two bar plots with the same data but different hatch patterns from the first row. The final section should span the entire third row and contain a filled area between the x-axis and a cosine curve with a hatch pattern and a magenta color. Additionally, add an Ellipse and a Polygon to the center of this section with appropriate sizes, hatch patterns, and colors. Adjust the aspect ratio and set the x and y limits of this section. Finally, display the plot.",
        "expert_instruction": "\nTo generate the provided code using an LLM, you would instruct it to create a Python script using the Matplotlib library that accomplishes the following tasks:\n\nDefine a list of categories labeled 'A' through 'E' and a corresponding list of numerical values [3, 7, 2, 5, 6].\nCreate a subplot mosaic with a layout of 2x2 bar plots at the top two rows and a larger plot spanning the entire bottom row for a cosine curve.\nFor the first row of bar plots, create two bar plots (bar1, bar2) using the defined categories and values. Apply different hatch patterns ('/' and '\\') to each plot.\nFor the second row, create two more bar plots (bar3, bar4) with the same data, but use different hatch patterns ('x' and '-').\nIn the larger bottom plot (cosine), plot a cosine curve over a range of 0 to 10. Fill the area under the curve with a magenta color and use a '*' hatch pattern.\nOn the same cosine plot, add an Ellipse at coordinates (5, 0) with width 4, height 1, colored yellow, and a '//' hatch pattern.\nAlso add a blue Polygon to the cosine plot, defined by the vertices [(2, -1), (8, -1), (5, -0.5)], closed, with an 'o' hatch pattern.\nAdjust the aspect ratio of the cosine plot to 'equal' and set x and y limits to 0-10 and -1.5 to 1.5, respectively.\nEnsure that the entire layout is neatly organized.\nFinally, display the plot.",
        "id": 13
    },
    {
        "simple_instruction": "Generate a Python script to create a plot with these features:\n\nEnsure random number generation is consistent in the script.\nEmploy the 'bmh' style for the plot.\nDevelop a function to create histograms based on beta distributions, which takes the plot's axes and two shape parameters as input.\nUse this function to produce a subplot with four histograms, each representing a beta distribution with different shape parameters.\nTitle the plot appropriately.\nDisplay the completed plot.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you please help me generate a Python code that accomplishes the following tasks:\n\n1. We need to bring in two libraries that are commonly used for data visualization and numerical operations. The first one is often used for creating static, animated, and interactive visualizations in Python. The second one is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.\n\n2. To ensure the consistency of our results, we need to set a fixed state for our random number generator. Use the function from the numerical operations library that allows us to set the seed for the random number generator. Let's use 123456 as our seed value.\n\n3. For our plot, let's use a style that is known for its minimalist and clear aesthetics. This style is named after the initials of the creator of a famous statistical programming language.\n\n4. We need to define a function that will create a histogram based on a beta distribution. This function should take three parameters: the axes for the plot, and two shape parameters for the beta distribution. Inside this function, use the first parameter to call the function that creates a histogram. The histogram should be based on a beta distribution generated by a function from the numerical operations library. The size of the distribution should be 10000. The histogram should be filled with steps, have 30 bins, a transparency of 0.7, and should be normalized.\n\n5. Create a subplot and assign its axes to a variable.\n\n6. Use the function we defined earlier four times, each time with different pairs of shape parameters for the beta distribution.\n\n7. Set the title of the plot to \"'Minimalist' style sheet\".\n\n8. Lastly, we need to display the plot. Use the function from the data visualization library that allows us to do this.\"",
        "id": 14
    },
    {
        "simple_instruction": "Create a Python script using matplotlib to generate a specific plot with the following detailed parameters:\nInitialize a figure with a custom size of 7.5 by 7.5 inches.\nAdd a single axis to the figure with a custom aspect ratio and specified position.\nDefine X as a linear space from 0.5 to 3.5 with 100 elements.\nCalculate Y1 as 3 plus the cosine of X, Y2 as 1 plus the cosine of 1+X/0.75\u200b divided by 2, and Y3 as random values uniformly distributed between Y1 and Y2.\nSet major and minor locators for both x and y axes with major intervals of 1 and minor intervals of 4.\nSet minor formatter for x-axis to display values with two decimal places.\nLimit the x and y axes to a range from 0 to 4.\nFor major ticks, set the width to 1.0, length to 10, and label size to 14.\nFor minor ticks, set the width to 1.0, length to 5, label size to 10, and label color to '0.25'.\nAdd a grid with these specific attributes:\nLinestyle set to \"--\" (dashed).\nLinewidth of 0.5.\nColor set to '.25' (a shade of gray).\nZ-order set to -10.\nPlot three lines with distinct characteristics:\nThe first line (Blue signal) should use color 'C0', linewidth of 2.5, and be placed at z-order 10.\nThe second line (Orange signal) should use color 'C1' and linewidth of 2.5.\nThe third line should consist of scatter markers at every third point, with no linewidth, markersize of 9, marker style 's' (square), marker face color 'none', marker edge color 'C4', and marker edge width of 2.5.\nSet the title \"Anatomy of a figure\" and axis labels \"x Axis label\" and \"y Axis label\" with specific font sizes:\nTitle font size should be 20.\nAxis label font sizes should be 14.\nAdd a legend with these specifications:\nPositioned at the \"upper right\".\nFont size set to 14.\nAnnotate the figure such as tick labels, axes labels, grid, etc., using circles, text, and code snippets at specified coordinates.\nThe circles should have a radius of 0.15, a border color defined by the royal_blue variable with an alpha of 0.6, and a white, non-filled center.\nText annotations should be in both royal blue and black colors, with bold and italic styles",
        "expert_instruction": "Begin by importing the necessary libraries for data visualization and numerical operations. Then, import the Circle class from a library that deals with shapes and patches, and a function that deals with stroke effects from a library that handles path effects. Also, import two classes that deal with minor and major locators from a library that handles tickers. Define a variable that represents the color royal blue as a list with the values 65/255, 105/255, and 225/255.\n\nNext, set the seed of the numerical library to 12345678. Define X as an array with 100 numbers evenly spaced between 0.5 and 3.5. Define Y1 as 3 plus the cosine of X, Y2 as 1 plus the cosine of 1 plus X divided by 0.75, all divided by 2. Define Y3 as an array with randomly distributed numbers between Y1 and Y2.\n\nCreate a figure with a size of 7.5 by 7.5 and add axes to it. Set the major and minor locators of both x and y axes using the classes you imported earlier. Set the minor formatter of the x axis to display two decimal places. Set the limits of x and y axes to 0 and 4. Set the parameters of the major and minor ticks. Add a grid to the axes with a linestyle of \"--\", linewidth of 0.5, color of '.25', and zorder of -10.\n\nPlot Y1, Y2, and Y3 against X with different styles and labels. Set the title of the axes to \"Anatomy of a figure\" with a fontsize of 20 and vertical alignment at the bottom. Set the labels of x and y axes to \"x Axis label\" and \"y Axis label\" respectively with a fontsize of 14. Add a legend to the upper right of the axes with a fontsize of 14.\n\nDefine a function named annotate that takes four parameters: x, y, text, and code. Inside the function, create a circle marker and add it to the axes. Then, create two texts with different path_effects and add them to the axes. Call this function multiple times with different parameters to annotate different parts of the figure, such as tick labels, axes labels, grid, etc., using circles and text with specific styling and path effects.\n\nFinally, set the linewidth and edgecolor of the figure patch to 4 and '0.5' respectively. Display the figure.",
        "id": 16
    },
    {
        "simple_instruction": "Generate a packed bubble chart in Python to represent the popularity of different programming languages. The programming languages to be included are 'Python', 'Java', 'C', 'C++', 'JavaScript', 'R', and 'Swift', with corresponding popularity percentages of 29.72, 19.03, 16.76, 6.91, 8.41, 5.59, and 3.47 respectively. Use the area of the bubble to indicate the popularity. Each bubble should be adjacent to one another. Each language should be represented by a different color. The chart should be titled 'Programming Languages Popularity'.",
        "expert_instruction": "Instruct the LLM to generate a Python code that creates a packed bubble chart representing the popularity of different programming languages. The code should start by importing the necessary libraries for data visualization and numerical computations. Then, define a dictionary named 'programming_languages_popularity' that contains three lists: 'languages', 'popularity', and 'color'. The 'languages' list should contain the names of the languages: 'Python', 'Java', 'C', 'C++', 'JavaScript', 'R', and 'Swift'. The 'popularity' list should contain the corresponding popularity percentages of these languages: 29.72, 19.03, 16.76, 6.91, 8.41, 5.59, and 3.47. The 'color' list should contain the colors to be used for each language in the chart.\n\nNext, use the matplotlib library to create a bubble chart. The size of each bubble should be proportional to the popularity of the programming language it represents. Each bubble should be colored according to the 'color' list in the 'programming_languages_popularity' dictionary.\n\nFinally, set the title of the chart to 'Programming Languages Popularity' and display the chart using the show() function from matplotlib.",
        "id": 17
    },
    {
        "simple_instruction": "Create a Python script that generates a custom geographic projection using a plotting library. The script should include a class for geographic projections and a class for the Aitoff-Hammer projection, an equal-area map projection. The geographic projection class should have methods for setting up and clearing axes, setting limits and transforms, formatting coordinates, and setting longitude and latitude grids. The Aitoff-Hammer projection class should include transformations for the projection. Finally, the script should create a plot displaying a square with four edges on 60 and -60 degrees latitude and 60 and -60 degrees longitude on a globe-like plot using the custom projection.",
        "expert_instruction": "Create a Python script that generates a custom geographic projection using a plotting library. Begin by importing the necessary modules, which include a mathematical module and several components from the plotting library.\n\nCreate a class named `GeoAxes` that inherits from the `Axes` class in the plotting library. This class will act as an abstract base class for geographic projections. \n\nWithin this class, define a nested class `ThetaFormatter` that inherits from the `Formatter` class in the plotting library. This class will be used to format the theta tick labels, converting the native unit of radians into degrees and adding a degree symbol. \n\nIn the `GeoAxes` class, define several methods to set up the axes, clear them, set the limits and transforms, format the coordinates, set the longitude and latitude grids, set the longitude grid ends, and get the data ratio. Also, override several methods to disable interactive panning and zooming.\n\nNext, define a class called `HammerAxes` that inherits from the `GeoAxes` class. This class will be used for the Aitoff-Hammer projection, an equal-area map projection. Inside this class, define two nested classes `HammerTransform` and `InvertedHammerTransform` that inherit from the `Transform` class in the plotting library. These classes will be used to perform the actual transformations for the projection.\n\nFinally, register the `HammerAxes` projection with the plotting library using the `register_projection` function. Then, create a simple example plot using the custom projection. This plot should display a square on a globe-like plot.",
        "id": 18
    },
    {
        "simple_instruction": "Create a Python program to visualize fruit sales data across different regions with these specifications:\n\nConstruct a stacked bar chart representing sales of 'Apples', 'Oranges', 'Bananas', 'Grapes', and 'Berries' for 'North', 'South', 'East', 'West', and 'Central' regions. Use the following sales data: sales_data = [\n    [120, 95, 130, 85, 100],  # Apples\n    [90, 115, 80, 105, 95],   # Oranges\n    [75, 80, 85, 70, 90],     # Bananas\n    [65, 70, 60, 75, 80],     # Grapes\n    [55, 60, 65, 50, 55]      # Berries\n]\nThe y-axis should indicate sales in hundreds, and the x-axis should remain unlabeled.\nTitle the chart 'Sales by Region' and choose soft shades for the bar colors.\nDisplay the cumulative sales value for each region at the top of its stacked bar.\nAdd a table below the chart that corresponds to the data in the bars, with rows colored to match the bar segments. Format the sales numbers in the table to two decimal place, representing the actual value divided by 100.\nThe layout should be adjusted so that both the chart and the table are clearly visible.\nShow the completed chart with the table included.",
        "expert_instruction": "Create a Python program that utilizes two libraries, one for data manipulation and the other for data visualization, to generate a stacked bar chart. The data for the chart should be a two-dimensional list where each sublist signifies a different type of fruit and contains the sales for different regions. The fruit types are 'Apples', 'Oranges', 'Bananas', 'Grapes', and 'Berries'. The regions are 'North', 'South', 'East', 'West', and 'Central', represented as strings. Use the following sales data: sales_data = [\n    [120, 95, 130, 85, 100],  # Apples\n    [90, 115, 80, 105, 95],   # Oranges\n    [75, 80, 85, 70, 90],     # Bananas\n    [65, 70, 60, 75, 80],     # Grapes\n    [55, 60, 65, 50, 55]      # Berries\n]\n\nThe y-axis should represent the sales in hundreds and the x-axis should not have any ticks. The chart should be titled 'Sales by Region'. \n\nUse soft shades for the colors of the bars and make sure that the last value is displayed at the top. \n\nBelow the chart, include a table that shows the same data. The table should have the same row and column labels as the chart, and the cell text should be the sales values divided by 100, formatted to two decimal places. The row colors should match the corresponding bars in the chart. \n\nFinally, adjust the layout to make room for the table and display the chart.",
        "id": 19
    },
    {
        "simple_instruction": "Create a 3D bar plot using Python. The plot should have a fixed random state for reproducibility. The plot should incorporate a 3D subplot and use the colors 'purple', 'orange', 'grey', and 'pink'. Each color should correspond to a unique set of data for the y=k 'layer'. The x values should range from 0 to 29, and the y values should be an array of 30 random numbers. The last bar of each set should be colored 'black' to demonstrate the flexibility of the color parameter. The bars should be plotted on the plane y=k with 80% opacity. The x, y, and z axes should be labeled appropriately, with the y-axis only labeling the discrete values that data is available for.",
        "expert_instruction": "Create a 3D bar plot using a Python-based data visualization library and a numerical computation library. Begin by importing the necessary modules. Establish a fixed random state to ensure the results are reproducible.\n\nNext, construct a figure and incorporate a 3D subplot into it. Define a list of colors and yticks. The colors should be 'purple', 'orange', 'grey', and 'pink', and the yticks should be [4, 3, 2, 1]. For each color and ytick, generate a unique set of data for the y=k 'layer'. The x values should be an array of numbers from 0 to 29, and the y values should be an array of 30 random numbers. \n\nTo demonstrate the flexibility of the color parameter, color the last bar of each set 'black'. Plot the bar graph on the plane y=k with 80% opacity. \n\nSet the labels for the x, y, and z axes. On the y-axis, only label the discrete values that you have data for. Lastly, display the plot.",
        "id": 20
    },
    {
        "simple_instruction": "Generate a 3D plot of a parametric curve, where the curve is defined by the cosine, sine of 2 times, and cosine of 4 times an array ranging from 0 to 4*pi+0.1. Use error bars with a frequency of 20 and limits defined by two boolean conditions: the array's index modulo 20 equals 0 and the array's index integer divided by 20 modulo 3 equals 0 or 2. The error should be 0.3. Label the x, y, and z axes as \"X label\", \"Y label\", and \"Z label\" respectively. Display the plot.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for creating plots and handling numerical computations.\n2. Create a 3D subplot from a newly created figure object and assign it to a variable.\n3. Set up a parametric curve by creating an array that starts from 0, ends at 4*pi+0.1, and has a step of 0.02. Then, calculate three variables as the cosine of the array, sine of 2 times the array, and cosine of 4 times the array respectively.\n4. Define a variable with a value of 20 and an array that contains the size of the previously mentioned array.\n5. Create two boolean arrays that are true when the array's index modulo the defined variable equals 0 and the array's index integer divided by the defined variable modulo 3 equals 0 or 2 respectively.\n6. Plot an error bar with the three calculated variables as the data, 0.3 as the error, the two boolean arrays as the up and low limits of the error bars, and the defined variable as the frequency of the error bars.\n7. Set the labels of the x, y, and z axes to \"X label\", \"Y label\", and \"Z label\" respectively.\n8. Finally, display the plot.",
        "id": 21
    },
    {
        "simple_instruction": "\nDevelop a Python script that:\n\nInitializes random number generation with a fixed seed of 1234567 to ensure reproducibility.\nGenerates two sets of 200 random values within the range of -5 to 5.\nCreates a 2D histogram of these values with 10 bins across the specified range.\nConstructs a 3D bar plot from the histogram data.\nDisplays the resulting 3D plot.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Start by importing two libraries that are commonly used for data visualization and numerical operations.\n2. To ensure the consistency of the results, set a fixed state for random number generation. Use the same seed value as 1234567.\n3. Create a new visual space where you can plot your data.\n4. Add a 3D area to the visual space you just created.\n5. Generate two sets of data, let's call them 'a' and 'b'. Each set should contain 200 random values between -5 and 5.\n6. From these two sets of data, create a 2D histogram. Set the number of divisions to 10 and the range for both axes to [-5, 5]. Keep the output in three separate variables.\n7. Construct arrays for the anchor positions of the 100 bars. Use the edges of the histogram bins, shifted by 0.5, as inputs. Flatten the resulting arrays and store them in two new variables. Set the third dimension position to 0.\n8. Construct arrays with the dimensions for the 100 bars. Set the length and width to half of an array of ones with the same shape as the third dimension position. Set the height to the flattened histogram array.\n9. Create a 3D bar plot using the position and dimension arrays as inputs. Sort the bars based on their average height.\n10. Finally, display the plot.",
        "id": 22
    },
    {
        "simple_instruction": "Generate a Python code that uses the Rossler attractor equations to create a 3D plot. The plot should have 'u', 'v', and 'w' as axes, a line width of 0.5, and the title \"Rossler Attractor\". The initial values for the Rossler attractor should be (1., 1., 1.).",
        "expert_instruction": "Instruct the LLM to generate a Python code that starts by importing the necessary libraries for data visualization and numerical operations. Then, define a function named 'rossler' that accepts an array-like parameter 'uvw' and three float parameters 'a', 'b', and 'c'. This function should unpack 'uvw' into 'u', 'v', and 'w', then calculate 'u_dot', 'v_dot', and 'w_dot' using the Rossler attractor equations. The function should return these values as a numerical array.\n\nNext, set a small time increment and a large number of steps. Create an empty numerical array 'uvws' with shape (number of steps + 1, 3) and set the initial values to (1., 1., 1.). Then, create a loop that iterates over the range of the number of steps. In each iteration, calculate the next point in the Rossler attractor by adding the product of the 'rossler' function and the small time increment to the current point.\n\nFinally, create a 3D plot using the data visualization library. Plot 'uvws' with a line width of 0.5, set the labels for the u, v, and w axes, and set the title to \"Rossler Attractor\". Display the plot using the appropriate function from the data visualization library.",
        "id": 24
    },
    {
        "simple_instruction": "Create a Python script that uses data visualization and numerical computation libraries to generate a figure with two subplots. The first subplot should be a 2D plot of a function, g(s), which is the sine of 3*pi*s multiplied by the exponential of -s, with three different sets of data g(s), g(s + 0.1) and g(s + 0.2). The second subplot should be a 3D plot of a surface generated from two arrays, P and Q, and a function, E, which is the cosine of the square root of the sum of squares of P and Q. The figure should have a title 'A Story of 2 Subplots'.",
        "expert_instruction": "Create a Python script that uses data visualization and numerical computation libraries to generate a figure with two subplots. Begin by bringing in the necessary libraries. Define a function, g(s), that gives the sine of 3*pi*s multiplied by the exponential of -s.\n\nConstruct a figure with a height twice its width and assign it a title 'A Story of 2 Subplots'. \n\nFor the first subplot, create three sets of data: s1, s2, and s3, using a function that generates evenly spaced values within a given interval. The intervals for s1, s2, and s3 should be different. Plot s1 and g(s1) as red triangles, and s2 and g(s2) as a grey dotted line with yellow marker face color. Enable grid and set the y-label as 'Damped wave'.\n\nFor the second subplot, create a 3D projection. Generate two arrays, P and Q, using a function that generates evenly spaced values within an interval of 0.5 from -10 to 10. Create a meshgrid from P and Q. Calculate D as the square root of the sum of squares of P and Q, and E as the cosine of D. Plot a surface using P, Q, and E with a stride of 1, no linewidth, and disable antialiasing. Set the z-limit from -1 to 1.\n\nLastly, display the plot using a function that shows the plot.",
        "id": 25
    },
    {
        "simple_instruction": "Create a 3D plot in Python that generates multiple polygons to fill under a series of 3D line graphs\n\n- The x-axis should have values from 0 to 20, evenly spaced.\n- The y-axis should range from 2 to 10.\n- For the z-axis, calculate probabilities using a Gaussian distribution function.\n- Include a series of polygons along the y-axis, each representing a different y-value for the mean of the Gaussian distribution and set the standard deviation to half of the y-value.\n- Color the polygons using a reversed plasma color map.\n- Ensure all axes and the plot itself are properly labeled. \n- Set appropriate x-axis, y-axis and z-axis limits. \n\nDisplay the final 3D plot.",
        "expert_instruction": "Import Necessary Libraries: Begin by importing the essential Python libraries: numpy, matplotlib.pyplot, and specific modules from mpl_toolkits.mplot3d and scipy.stats. Highlight that numpy is for numerical operations, matplotlib.pyplot for plotting, and mpl_toolkits.mplot3d and scipy.stats for 3D plotting and statistical functions, respectively.\n\nDefine a Function for Creating Gaussian Polygons: Request to create a function named create_gaussian_polygons that takes parameters x, mean, and std_dev. This function should compute the Gaussian distribution values using norm.pdf from scipy.stats and return vertices for polygons formed by these values.\n\nSet Up X-axis Values and Y-axis Range: Ask to create a linearly spaced array x using numpy.linspace for the x-axis, spanning from -10 to 20 with 100 points. Then, define a range y using numpy.arange for the y-axis, representing mean values from 2 to 10.\n\nInitialize a 3D Plot: Instruct to create a 3D plot using matplotlib.pyplot. This involves initializing a figure and adding a subplot with 3D projection.\n\nGenerate and Plot Polygons: Indicate the need to loop over each value in the y array. In each iteration, calculate the standard deviation as half of the mean (yi). Then, call the create_gaussian_polygons function with x, the current mean (yi), and the calculated standard deviation. Create a Poly3DCollection for these polygons, setting its facecolors with a colormap (cm.plasma_r) and add this collection to the 3D axis.\n\nLabel Axes and Set Limits: Request to set labels for the x-axis, y-axis (as \"Mean\"), and z-axis (as \"Probability (Gaussian Distribution)\"). Also, instruct to set the limits for each axis, with specific ranges for x, y, and z axes.\n\nDisplay the Plot: Finally, ask to show the plot using plt.show().",
        "id": 26
    },
    {
        "simple_instruction": "Generate a unfilled 3D tricontour plot in Python that visualizes data in polar coordinates with the following details:\n\nUse 36 angles and 10 radii, with the radii starting at 0.15 and extending to 0.85.\nThe angles should be within a range of 0 to 1.5 times pi.\nCalculate the x, y, and z coordinates from these polar coordinates, with the z-values determined by the sine of twice the angle values.\nMask out any triangles in the mesh that have an average hypotenuse shorter than the minimum radius.\nApply an appropriate colormap to the plot.\nSet the view angle of the plot to 60 degrees for optimal viewing.",
        "expert_instruction": "Create a 3D contour plot using Python, utilizing the necessary libraries for data manipulation and visualization.\n\nFirst, you'll need to define the parameters for the plot. Instead of 48 angles and 8 radii, let's use 36 angles and 10 radii. Set the minimum radius to 0.15 instead of 0.25.\n\nNext, create a mesh in polar coordinates. Generate an array of radii that ranges from the minimum radius to 0.85, and an array of angles that ranges from 0 to 1.5 times pi. Repeat the angles for each radius and shift every second angle by pi divided by the number of angles.\n\nNow, calculate the x, y, and z coordinates. For x and y, multiply the radii with the cosine and sine of the angles respectively. For z, instead of multiplying the cosine of the radii with the cosine of 3 times the angles, use the sine of twice the angles. Flatten these arrays afterwards.\n\nNext, create a custom triangulation using the x and y coordinates. Exclude triangles that are not needed by masking off those whose average hypotenuse is less than the minimum radius.\n\nAfterwards, create a 3D subplot and plot the triangulation and z coordinates. Use a tricontourf plot with the same color map as before. Adjust the view angle to 60 degrees for better visualization.\n\nFinally, display the plot.",
        "id": 30
    },
    {
        "simple_instruction": "Generate a Python script to create a plot comparing the cumulative distribution functions (CDFs) of normal, Laplacian, and Cauchy distributions, with these specifics:\n\nUse a range of values from -20 to 20, with a high resolution.\nCalculate and plot the CDFs for each distribution.\nOrganize the plots into a grid with three rows and two columns, each subplot demonstrating all three distribution type.\nImplement logit scaling for the y-axis in the first two rows, with appropriate y-limits, and linear scaling for the y-axis in the third row.\nFor certain subplots, adjust the x and y limits to focus on specific areas of the distribution.\nLabel each subplot with the corresponding distribution type and include legends and grids for clarity.\nMake layout adjustments to ensure all subplots are displayed neatly.\nShow the complete figure with these comparisons.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you help me generate a Python code that completes the following tasks?\n\n1. First, we need to import some libraries. We'll need one for mathematical functions, one for creating plots, and one for numerical operations.\n\n2. Now, let's define a variable that we'll call `ymax` and assign it a value of 20. We also need to create an array, let's call it `y`, using a function from our numerical operations library that generates evenly spaced numbers over a specified range. The range should be from `-ymax` to `ymax`, and we want 20000 numbers.\n\n3. We need to calculate the cumulative distribution function (CDF) for three different distributions: a normal distribution, a Laplacian distribution, and a Cauchy distribution. We'll use our array `y` for these calculations. Let's store the results in `cdf_norm`, `cdf_laplacian`, and `cdf_cauchy` respectively.\n\n4. Next, we need to create a figure with 3 rows and 2 columns of subplots using a function from our plotting library. The figure size should be `(6.4, 8.5)`.\n\n5. For each subplot, we should plot the CDFs we calculated earlier. Let's label them as `r\"$\\mathcal{N}$\"`, `r\"$\\mathcal{L}$\"`, and `\"Cauchy\"`. We should also add a legend and grid to each subplot.\n\n6. For the first row of subplots, let's set the y-scale to `\"logit\"` and the y-limit to `(1e-5, 1 - 1e-5)`. For the second subplot in the first row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1 - 5e-3)`.\n\n7. For the second row of subplots, we should also set the y-scale to `\"logit\"` with `one_half=\"1/2\"` and `use_overline=True`. We should set the y-limit to `(1e-5, 1 - 1e-5)`. For the second subplot in the second row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1 - 5e-3)`.\n\n8. For the third row of subplots, let's set the y-scale to `\"linear\"` and the y-limit to `(0, 1)`. For the second subplot in the third row, we should also set the x-limit to `(0, ymax)` and the y-limit to `(0.8, 1)`.\n\n9. We should adjust the layout of the figure to fit the subplots neatly using a function from our plotting library.\n\n10. Finally, we need to display the figure. There should be a function in our plotting library that can do this.\"",
        "id": 36
    },
    {
        "simple_instruction": "Create a Python script to generate a Hinton Diagram with the following features:\n\nVisualize a 15x15 matrix of random values ranging from -2 to 1. Use a fixed random seed (123456) for reproducibility.\nRepresent positive values with white rectangles and negative values with black rectangles.\nThe size of each rectangle should correspond to the magnitude of the matrix value it represents.\nPosition the rectangles such that they are centered on their corresponding matrix elements.\nUse gray as the background color for the plot.",
        "expert_instruction": "Could you help me create a Python script that performs the following tasks?\n\n1. First, we need to import two libraries. One is commonly used for creating static, animated, and interactive visualizations in Python. The other one is a library used for working with arrays.\n\n2. We need to define a function that will be used to visualize a weight matrix. Let's call this function 'visualize_weights'. This function should take three parameters: a matrix, a maximum weight which is optional, and an axis which is also optional.\n\n3. Inside the function, if the axis is not provided, we should use the current axis.\n\n4. If the maximum weight is not provided, we should calculate it. To do this, find the maximum absolute value in the matrix, take the base 2 logarithm of this value, round it up to the nearest integer, and then raise 2 to the power of this value.\n\n5. We should set the face color of the axis patch to gray and set the aspect of the axis to 'equal' and 'box'.\n\n6. We should remove the major ticks from the x and y axes.\n\n7. We need to iterate over the matrix. For each element, we should determine its color (white if it's positive, black if it's negative) and size (the square root of its absolute value divided by the maximum weight).\n\n8. We should create a rectangle patch with the calculated size and color, centered at the current position, and add it to the axis.\n\n9. After iterating over all elements, we should adjust the axis to fit the patches and invert the y-axis.\n\n10. In the main part of the script, we should set the random seed of our array library to 123456 for reproducibility.\n\n11. We should call the 'visualize_weights' function with a 15x15 matrix filled with random values between -2 and 1.\n\n12. Finally, we should display the plot.",
        "id": 37
    },
    {
        "simple_instruction": "Create a Python script to generate a fishbone diagram that visualizes the potential causes of \"Decreased Sales Performance\" in a business context. The diagram should include the following elements:\n\nMain Problem: \"Problem\" at the head of the diagram.\n\nSix Key Categories branching off from the main spine, each with its own specific causes:\n\nProduct Issues: Poor Quality, Limited Range, Obsolete Features.\nMarketing and Sales Strategy: Ineffective Advertising, Poor Online Presence, Inadequate Sales Training.\nCustomer Service: Slow Response Time, Lack of Personalization, Poor After-Sales Support.\nPricing Strategy: High Prices, Inflexible Payment Options.\nMarket Conditions: Increased Competition, Changing Preferences, Economic Downturn.\nInternal Processes: Inefficient Supply Chain, Poor Communication, Limited R&D.\nArrange these categories and their causes at specific locations and angles on the diagram, emanating from the central spine.\n\nThe diagram should have a clear and organized layout, reflecting the relationship between the main problem and its potential causes.",
        "expert_instruction": "Create a Python script that generates a fishbone diagram to visualize the potential causes of \"Decreased Sales Performance\". Use a plotting library, such as matplotlib, and some specific classes from it for creating shapes like polygons and wedges.\n\nStart by setting up your plot. Create a figure and axes, and set the limits for the x and y axes. Turn off the axis lines.\n\nDefine a function to add problem categories to the diagram. This function should take as input a string for the category name, two numbers for the x and y positions of the problem arrows, and two more numbers for the angle of the problem annotations. It should then add an annotation to the diagram at the specified position and angle, with the category name as the text.\n\nCreate a second function to add causes to the diagram. This function should take a list of causes, two numbers for the x and y positions of the cause annotations, an optional pair of numbers to adjust the distance of the cause text from the problem arrow, and a boolean to indicate whether the cause is at the top or bottom of the diagram. It should then add an annotation for each cause at the specified position.\n\nThen, create a third function that will draw the main body of the fishbone diagram. This function should take a dictionary where the keys are problem categories and the values are lists of causes. It should draw the main spine of the fishbone diagram, the head, and the tail, and call the previous two functions to add the problem categories and causes to the diagram.\n\nFinally, create a dictionary of problem categories and their causes. The categories should be 'Product Issues', 'Marketing and Sales Strategy', 'Customer Service', 'Pricing Strategy', 'Market Conditions', and 'Internal Processes'. The causes should be as specified as follows: Product Issues: Poor Quality, Limited Range, Obsolete Features.\nMarketing and Sales Strategy: Ineffective Advertising, Poor Online Presence, Inadequate Sales Training.\nCustomer Service: Slow Response Time, Lack of Personalization, Poor After-Sales Support.\nPricing Strategy: High Prices, Inflexible Payment Options.\nMarket Conditions: Increased Competition, Changing Preferences, Economic Downturn.\nInternal Processes: Inefficient Supply Chain, Poor Communication, Limited R&D.. Call the function to draw the main body of the diagram with this dictionary as an argument, and then display the plot.\n\nThe goal is to create a fishbone diagram that visually represents potential causes of \"Decreased Sales Performance\", categorized by type.",
        "id": 38
    },
    {
        "simple_instruction": "Create a Python script using matplotlib and numpy to visualize the left ventricle's 17 segments in a 'bullseye plot', a polar representation. \nDefine a function, 'bullseye_plot', designed to plot each segment's intensity values. The function should:\nAccept parameters for the axes object, intensity values of the 17 segments, an optional list to highlight specific segments, a colormap (with a default setting), and an optional data normalizer.\nAutomatically handle the flattening of data and setting defaults for unspecified parameters.\nUtilize radii to differentiate between segment layers and ensure the plot is free from gridlines and labels.\nApply a color scheme to represent intensity values and indicate segment borders, with emphasized borders for highlighted segments.\nThe script must then create a representative dataset ranging from 1 to 17 to simulate intensity values.\nConstruct a layout with three polar subplots, each demonstrating a unique aspect of the 'bullseye_plot' function:\nThe first subplot should display the standard visualization.\nThe second should incorporate a different color scheme.\nThe third should emphasize segments [3, 5, 6, 11, 12, 16] in bold, showcasing the function's ability to highlight specific areas, and have a discrete intervals in color coding.\nInclude horizontal colorbars beneath each corresponding bullseye plot, with clear indications of the represented values.\nConclude with a command to display the final plot.",
        "expert_instruction": "Create a Python script that employs the necessary libraries to generate a bullseye plot that represents the left ventricle's 17 segments. Start by importing the required libraries and defining a function that will create the bullseye plot. This function should accept parameters for the axes, data, segments to emphasize, colormap, and normalizer.\n\nThe function should first flatten the data and set default values for the segments to emphasize and the normalizer if they are not provided. Then, it should set the radii to differentiate between segment layers, remove x and y tick labels, and remove the grid. \n\nNext, it should fill in the segments using a loop and the appropriate method, applying a color scheme to represent intensity values. After that, it should draw the segment borders, with emphasized borders for highlighted segments. \n\nOutside the function, create synthetic data using a method that generates a sequence of numbers from 1 to 17 to simulate intensity values. Then, create a figure and axes with desired dimensions using methods from the plotting library. Set the colormap and norm to correspond to the data for which the colorbar will be used. \n\nCreate three subplots, each demonstrating a unique aspect of the 'bullseye_plot' function. The first subplot should display the standard visualization. The second should incorporate a different color scheme. The third should emphasize certain segments, showcasing the function's ability to highlight specific areas. Include colorbars corresponding to the data on each subplot, with clear indications of the represented values.\n\nFinally, create the 17 segment model using the bullseye plot function and display the plot using a method from the plotting library.",
        "id": 39
    },
    {
        "simple_instruction": "Create a Python script to generate a radar chart displaying average temperature profiles for five cities - New York, London, Tokyo, Sydney, and Cairo - across all months. Use the following dataset and guidelines:\nDataset:\naverage_temperatures = [\n    [0, 1, 5, 11, 16, 21, 24, 23, 19, 14, 8, 3],  # New York\n    [4, 5, 7, 9, 13, 16, 19, 18, 15, 11, 7, 5],   # London\n    [5, 6, 9, 14, 19, 22, 26, 27, 23, 18, 12, 8], # Tokyo\n    [23, 23, 22, 20, 17, 14, 13, 15, 17, 19, 21, 22], # Sydney\n    [13, 14, 17, 20, 24, 27, 28, 28, 26, 22, 18, 15]  # Cairo\n]\nFill each plot with a different color to represent each city's temperature profile.\nInclude a legend in the top-right to identify the cities.\nTitle the chart to reflect its content, such as \"Average Monthly Temperatures of Five Cities.\"\nUse the months as labels for the spokes of the radar chart.\nThe script should result in a radar chart that compares the average monthly temperatures of New York, London, Tokyo, Sydney, and Cairo, making it easy to visualize and compare the climate patterns of these cities.",
        "expert_instruction": "Data Description: Begin by instructing the LLM to define a dataset representing average monthly temperatures for several cities throughout the year. Specifically, ask for:\n\nA list named average_temperatures containing sub-lists for each city. Each sub-list should have 12 values representing the average temperature for each month. For example, include the following data:\nNew York: [0, 1, 5, 11, 16, 21, 24, 23, 19, 14, 8, 3]\nLondon: [4, 5, 7, 9, 13, 16, 19, 18, 15, 11, 7, 5]\nTokyo: [5, 6, 9, 14, 19, 22, 26, 27, 23, 18, 12, 8]\nSydney: [23, 23, 22, 20, 17, 14, 13, 15, 17, 19, 21, 22]\nCairo: [13, 14, 17, 20, 24, 27, 28, 28, 26, 22, 18, 15]\nA list named cities containing the names of the cities: [\"New York\", \"London\", \"Tokyo\", \"Sydney\", \"Cairo\"].\nA list named months for the months of the year: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"].\nRadar Chart Initialization: Instruct to import numpy and matplotlib.pyplot, and set up a radar chart using a polar subplot. Mention calculating angles for each axis to form a full circle.\n\nPlotting Helper Function: Ask for a function that takes a city name, its temperature values, and a color to plot these values on the radar chart with some transparency.\n\nPlot Data for Each City: Guide the LLM to use the plotting function to add each city's data to the radar chart. Each city should be represented with a different color.\n\nChart Customization: Request adding a legend with city names and a descriptive title like 'Average Monthly Temperatures of Five Cities'.\n\nAxis Configuration: Instruct on setting the theta offset and direction for proper orientation.\n\nAxes Labeling: Guide to set the x-tick labels to the month names, aligning them with the respective axes.\n\nSaving and Displaying the Figure: Conclude by asking to include code for saving the figure as a PNG file and displaying the chart.",
        "id": 40
    },
    {
        "simple_instruction": "Create a scatter plot of two distinct sets of random data, each containing 150 points. The first set (Group X) should be centered around (-2,-2) and visualized in blue, and the second set (Group Y) should be centered around (2,2) and visualized in orange. Label each group at their respective centers with a round white box around the text. Add a text label at the center of the plot (0,0) with the text \"Orientation\", rotated at 60 degrees, and with a purple arrow-shaped box around it. The plot should be of size 5x5 with an aspect ratio of 1, and the x and y limits should be between -5 and 5.",
        "expert_instruction": "Create a Python script that produces a scatter plot using necessary libraries. To ensure the results are consistent, set a random seed.\n\nConstruct a figure and an axes of size 5x5 and adjust the aspect ratio to 1. Generate two distinct sets of random data, each containing 150 points. The first set (Group X) should be centered around (-2,-2) and the second set (Group Y) should be centered around (2,2). \n\nVisualize these two sets of data on the axes, using blue color for Group X and orange color for Group Y. Add labels for each group at their respective centers, with a round white box around the text. \n\nNext, add a text label at the center of the plot (0,0) with the text \"Orientation\", rotated at 60 degrees, and with a purple arrow-shaped box around it. Adjust the padding of the box to 0.7. \n\nLastly, set the x and y limits of the plot to be between -5 and 5, and display the plot.",
        "id": 45
    },
    {
        "simple_instruction": "Create a Python script using Matplotlib and NumPy to visualize a comparison between two methods of contour plotting for irregularly spaced data. The first method should involve interpolating the data onto a regular grid and then creating a contour plot. The second method should directly use triangular contour plotting for an unstructured grid.\n\nIn the script, start by using NumPy to create 300 points with x and y coordinates randomly distributed within a range of -3 to 3. For the z-values, apply a function, x times the exponential of the negative square of x and y, to these points to simulate real-world data. Use these points to simulate a scenario of irregularly spaced data. Then, for the first method, interpolate these data points onto a regular grid with 100 * 200 grid points and create a contour plot from this grid. For the second method, apply triangular contour plotting directly to the irregular data.\n\nEnsure the script includes two plots in a single figure of two rows, one row for each method. Use cmap=\"RdBu_r\" and display a filled contour plot with 14 levels. Also display contour lines with 14 levels with linewidth of 0.5 and line color of black. Add colorbars for clarity and mark the original data points on both plots. Also, include titles that clearly distinguish between the two methods and mention the number of data points and grid points used. The plots should be visually appealing and easy to compare.",
        "expert_instruction": "Generate a Python script that begins by importing the necessary libraries for data visualization and numerical computations. Also, import a specific module from the data visualization library that is used for triangular grid functions. Set the random seed of the numerical computation library to 12345678 and define three variables, let's call them total_points, grid_points_x, and grid_points_y, and assign them the values 300, 150, and 300 respectively.\n\nCreate two arrays, let's name them array_x and array_y, each with 300 random values ranging from -3 to 3. Then, create a third array, let's call it array_z, which is the product of array_x and the exponential of the negative of the square of array_x and array_y.\n\nNext, create a figure with two subplots and assign them to three variables, let's call them figure, subplot1, and subplot2. For the first subplot, interpolate the data (array_x, array_y) on a grid defined by grid_x and grid_y, which are linearly spaced arrays from -3.1 to 3.1 with grid_points_x and grid_points_y points respectively. Use the triangular grid functions to perform the interpolation. Then, plot a contour and filled contour plot on subplot1 using the interpolated data. Add a colorbar, scatter plot of the original data points, set the x and y limits to -3 and 3, and add a title.\n\nFor the second subplot, directly supply the unordered, irregularly spaced coordinates to the functions to create a contour and filled contour plot. Add a colorbar, scatter plot of the original data points, set the x and y limits to -3 and 3, and add a title. Finally, adjust the space between the subplots to 0.5 and display the plot.",
        "id": 47
    },
    {
        "simple_instruction": "Create a Python script that generates a 1D random walk with a small fraction of cosine waves. The script should plot the series, convert the series into a histogram, and then plot the histogram with both a log and linear color scale. The plot should reveal the hidden signal in the data, and the color scales should be adjusted to make the signal more visible. The plots should be arranged in three rows and one column.",
        "expert_instruction": "Sure, here is the modified instruction:\n\n\"Let's create a Python script that starts by bringing in the necessary modules. We'll need one for timing our operations, one for creating plots, and one for numerical operations.\n\nNext, we'll create a subplot with three rows and a figure size of 6x8 using a layout that is constrained.\n\nTo ensure our results are consistent, we'll set a random seed. Now, we're going to generate some data for a 1D random walk with a small fraction of cosine waves. We'll create 500 series with 200 points each and a Signal to Noise Ratio of 0.15. We'll use a function to generate evenly spaced numbers over the range of 0 to 6*pi.\n\nWe'll generate unbiased Gaussian random walks and cosine signals with a small random offset. \n\nWe'll then plot the series using a function that allows us to set a small value of alpha. This will make it difficult to observe the cosine behavior due to the number of overlapping series. Also, we'll note the time it takes to run this because of the number of individual artists that need to be generated. \n\nNext, we'll convert the multiple time series into a histogram. This will make the hidden signal more visible and is also a quicker procedure. We'll interpolate between the points in each time series. \n\nWe'll plot the points in a 2D histogram with a log color scale. It should be evident that there is some kind of structure under the noise. We can tune vmax to make the signal more visible. We'll use the 'plasma' colormap and adjust the extremes. \n\nFinally, we'll plot the same data but on a linear color scale. We'll note the time it takes to run this. We'll display the plot using a function that shows the plot.\n\nRemember, the goal is to create a Python script that generates a 1D random walk with a small fraction of cosine waves, plots the series, converts the series into a histogram, and then plots the histogram with both a log and linear color scale.\"",
        "id": 48
    },
    {
        "simple_instruction": "Create a Python script that generates a 2x2 grid of subplots using a specific plotting library and a numerical computing library. \n\nIn the first subplot, construct a scatter plot with coordinates generated from a uniform distribution.\n\nFor the second subplot, draw cosine curves with colors from the default color cycle. The x values should be evenly distributed over a range and the y values should be the cosine of x plus a shift value.\n\nIn the third subplot, create two bar graphs with random integer y values. The x values should be the integers from 0 to 6. The second bar graph should be shifted to the right by the width of the bars. Label the x-axis with the letters 'a' through 'g'.\n\nIn the fourth subplot, draw squares at random positions. The colors of the squares should come from the default color cycle. Ensure the aspect ratio of the plot is equal.\n\nFinally, display the plots.",
        "expert_instruction": "Create a Python script that generates a 2x2 grid of subplots using a specific plotting library and a numerical computing library. Use the 'ggplot' style for the plots and ensure the random state is set to 123456 for consistency.\n\nIn the first subplot, construct a scatter plot using the 'x' marker. The x and y coordinates for the scatter plot should be generated from a uniform distribution with a size of 300.\n\nFor the second subplot, draw cosine curves with colors from the default color cycle. The x values should be evenly distributed over a range of 3*pi. The y values should be the cosine of x plus a shift value, where the shift values are evenly distributed over the same range as x. Ensure the margins of the plot are set to 0.\n\nIn the third subplot, create two bar graphs with random integer y values between 10 and 50. The x values should be the integers from 0 to 6. The width of the bars should be 0.3, and the second bar graph should be shifted to the right by the width of the bars. The color of the second bar graph should be the fourth color in the default color cycle. Label the x-axis with the letters 'a' through 'g'.\n\nIn the fourth subplot, draw squares at random positions with side length of 0.4. The colors of the squares should come from the default color cycle. Ensure the aspect ratio of the plot is equal and the margins are set to 0.\n\nFinally, display the plots.",
        "id": 53
    },
    {
        "simple_instruction": "Create a Python script for generating a plot with three distinct subplots, each demonstrating different transformations and plot types:\n\nUse a fixed random seed 12345678 to ensure consistent results across runs.\nImplement three separate functions, each taking a figure and a rectangle as inputs:\nThe first function creates a subplot with a transformation scaling by 3 in the x-direction and 2 in the y-direction, and a 45-degree rotation to the spines. It should return the subplot and its auxiliary axes.\nThe second function generates a subplot that displays the upper left quadrant of a full polar grid using polar coordinates with custom locators and formatters, returning the subplot and its auxiliary axes.\nThe third function creates a subplot with a composite transformation (including a 45 degree rotation, log scaling, and polar transformation which shows half of a full polar grid), adjusts axis directions and visibility, sets axis labels, and returns the subplot and its auxiliary axes.\nUse the first function to add a bar plot with specific x and y values.\nUtilize the second function to include a scatter plot with random theta and radius values.\nEmploy the third function to insert a scatter plot with random theta and radius values.\nDisplay the plot.\nThis script should result in a complex plot featuring different types of transformations and plotting methods.",
        "expert_instruction": "Could you help me create a Python script that does the following?\n\n1. First, we need to import some libraries. We'll need one for creating plots, one for numerical operations, and a few others for creating different types of transformations and for working with axes and grids.\n\n2. To ensure that our results are consistent every time we run the script, let's set a seed for the random number generator in our numerical operations library.\n\n3. Now, let's define a function that takes a figure and a rectangle as arguments. This function should create a transformation that scales by 3 in the x-direction and 2 in the y-direction, and rotates by 45 degrees. It should then create a helper for the grid with the transformation and certain extremes, and add a subplot to the figure with the grid helper. The function should return the subplot and its auxiliary axes.\n\n4. Next, let's define another function that also takes a figure and a rectangle as arguments. This function should create a polar transformation and a grid helper with the transformation, custom locators, and formatters. It should add a subplot to the figure with the grid helper and return the subplot and its auxiliary axes. This subplot should display the upper left quadrant of a full polar grid.\n\n5. Let's define a third function that takes a figure and a rectangle as arguments. This function should create a composite transformation that includes a 45-degree rotation, log scaling, and a polar transformation. It should create a grid helper with the transformation, custom locators, and formatters, and add a subplot to the figure with the grid helper. The function should adjust the axis directions and visibility, set axis labels, and return the subplot and its auxiliary axes.\n\n6. Now, let's create a figure with a specific size and subplot adjustments.\n\n7. We'll call the first function with the figure and a rectangle, and create a bar plot on the auxiliary axes. Let's use the numbers 1, 2, 3, and 4 for the x-values, and the numbers 4, 3, 2, and 4 for the y-values.\n\n8. Then, we'll call the second function with the figure and a rectangle, and create a scatter plot on the auxiliary axes with random theta and radius values. Let's use 20 random theta values between 0 and half pi, and 20 random radius values between 1 and 2.\n\n9. Finally, we'll call the third function with the figure and a rectangle, and create a scatter plot on the auxiliary axes with random theta and radius values. Let's use 20 random theta values between 120 and 210 degrees, and 20 random radius values between 0 and 20000.\n\n10. To finish, let's display the plot using the function from our plotting library that shows the current figure.",
        "id": 59
    },
    {
        "simple_instruction": "To generate a broken horizontal bar plot with gaps, use the following data and settings:  - Create the first broken bar of two segments at 98 with width 28 and at 128 with width 47, its y-position should be 10 with a height of 11,  set the facecolors of the bars to blue. Create the second broken bar of three segments at 8 with width 46, at 99 with width 22 and at 132 with width 15, its y-position should be 20 with a height of 11,set the  facecolors to orange, green and red. Use broken_barh() function to achieve the above instructions. - Set the x-axis label to 'seconds since start'. - Modify the y-axis tick labels to ['Bill', 'Jim']). Make the grid lines visible. - Add an annotation at coordinate (55, 28) to indicate \"race interrupted\" with text coordinate (0.7, 0.8), use a red arrow to do this annotation.",
        "expert_instruction": "To generate a broken horizontal bar plot with specific requirements, follow these instructions in Python using the matplotlib library:Import matplotlib.pyplot as plt.Define the data for the broken horizontal bars. For the first bar, create two segments: one starting at 98 with a width of 28, and another starting at 128 with a width of 47. For the second bar, create three segments: one starting at 8 with a width of 46, another starting at 99 with a width of 22, and the last one starting at 132 with a width of 15.Set the y-positions of the bars. The first bar should be positioned at 10 and the second at 20 on the y-axis. Both bars should have a height of 11.Specify the face colors of the bars. For the first bar, use blue for both segments. For the second bar, use orange for the first segment, green for the second, and red for the third.Create the plot using fig, ax = plt.subplots().Add the bars to the plot using ax.broken_barh(), passing the segments, y-position, and height as arguments.Set the x-axis label to \"seconds since start\" using ax.set_xlabel().Modify the y-axis tick labels to 'Bill' and 'Jim' using ax.set_yticks() and ax.set_yticklabels().Make the grid lines visible with ax.grid(True).Add an annotation at coordinates (55, 28) with the text \"race interrupted\". Set the text coordinate to (0.7, 0.8) using ax.annotate(). Use a red arrow for this annotation by setting arrowprops to dict(facecolor='red', shrink=0.05).Display the plot using plt.show()",
        "id": 61
    },
    {
        "simple_instruction": "Create a horizontal stacked bar chart titled 'Favorite Sports by Country' to visualize discrete distributions using matplotlib. Use the following data to plot it: category_names = ['Football', 'Volleyball', 'Basketball', 'Formula 1', 'Tennis'], results = {'USA': [12, 13, 15, 34, 28], 'UK': [22, 26, 32, 12, 10], 'Germany': [31, 32, 15, 6, 20], 'Spain': [30, 13, 11, 12, 35], 'China': [25, 24, 8, 3, 43], 'Italy': [18, 9, 15, 25, 30]}.   The horizontal stacked bar chart represents the result of a survey in which people from different countries were asked to rate their most favorite sport from five candidates. Each country is represented by a category on the y-axis, and the length of each bar represents the number of responses for each sport. Color the different categories using category_colors = plt.colormaps['RdYlGn'](        np.linspace(0.15, 0.85, data.shape[1])). Label each stacked bar with their respective data.",
        "expert_instruction": "Import the matplotlib.pyplot and numpy libraries as plt and np, respectively.Define your data:Set category_names as a list of strings representing the sports categories: 'Football', 'Volleyball', 'Basketball', 'Formula 1', and 'Tennis'.Create a dictionary named results with keys as country names ('USA', 'UK', 'Germany', 'Spain', 'China', 'Italy') and values as lists of integers representing the number of responses for each sport.Convert the results dictionary into a numpy array for easier manipulation.Calculate the cumulative sum of the data along the horizontal axis to help in plotting the stacked bars.Access the 'RdYlGn' colormap using plt.get_cmap('RdYlGn') and use np.linspace(0.15, 0.85, number_of_categories) to create a range of colors for the categories.Create a figure and axis using plt.subplots, and adjust the y-axis to be inverted and the x-axis to be hidden.Set the x-axis limits to the maximum cumulative sum of the data.Iterate through each category and its corresponding color:Calculate the width of each bar as the data for that category.Calculate the starting point of each bar as the cumulative sum minus the width.Use ax.barh to draw horizontal bars with specified labels, widths, colors, and starting points.Determine the text color (white or dark grey) based on the brightness of the bar color.Add text labels inside each bar, showing the number of responses.Add a legend to the plot, setting its location and size appropriately.Display the plot using plt.show().",
        "id": 62
    },
    {
        "simple_instruction": "Use the matplotlib function fill_between to create a plot with shaded regions using the following toy data: t = np.arange(0.0, 2, 0.01), s = np.sin(2*np.pi*t). Shade the region between the curve defined by t and s when s > 0 with the color green and alpha value of 0.5. Shade the region between the curve defined by t and s when s < 0 with the color red and alpha value of 0.5. Display a legend on the top right corner.",
        "expert_instruction": "Write a Python script to create a plot with shaded regions using matplotlib. Start by importing the NumPy and Matplotlib's pyplot libraries. Generate a time array 't' from 0.0 to 2.0 with a step of 0.01. Compute the sine of t multiplied by 2*pi and store this in a variable 's'. Plot the sine curve using Matplotlib. Then, shade the region above the curve (where 's' is greater than 0) with green color and an alpha value of 0.5. Similarly, shade the region below the curve (where 's' is less than 0) with red color and the same alpha value. Finally, display the plot.",
        "id": 64
    },
    {
        "simple_instruction": "Show the marginal distributions of a scatter plot as histograms at the sides of the plot and nicely align the main axes with the marginal distributions. Use some random data x = np.random.randn(1000), y = np.random.randn(1000) to plot the scatter plot.",
        "expert_instruction": "To create a scatter plot with marginal distributions as histograms at the sides of the plot and to align the main axes with the marginal distributions using Python and Matplotlib, follow these steps:Import the necessary libraries: NumPy for data manipulation and Matplotlib for plotting. Additionally, import MaxNLocator from matplotlib.ticker for better control over the histogram tick marks.Generate random data: Create two arrays, x and y, each with 1000 normally distributed random numbers.Prepare the figure and grids: Create a figure and define a grid layout with a 2x2 grid. Allocate more space to the main scatter plot and ensure that the histograms are aligned with the scatter plot axes.Create subplots: Add three subplots to the figure:The main scatter plot in the lower-left grid.A histogram for the x-axis data in the upper-left grid.A histogram for the y-axis data in the lower-right grid.\nEnsure that the x-axis of the scatter plot is shared with the x-axis histogram, and the y-axis of the scatter plot is shared with the y-axis histogram.Create the scatter plot: Plot the x and y data on the main axes with your preferred style settings.Create the histograms:Plot a histogram of the x data on the top axes.Plot a histogram of the y data on the right axes, rotated horizontally.Optionally, control the number of bins and adjust the transparency with the alpha parameter.Adjust the appearance of the histograms:Limit the number of tick marks using MaxNLocator.Hide unnecessary spines and tick labels to keep the focus on the main plot.Finally, display the plot using plt.show().",
        "id": 65
    },
    {
        "simple_instruction": "Define a set of x and y values ranging from -3.0 to 3.0 and -2.0 to 2.0, respectively, with 100 points in each dimension. Create a meshgrid from the x and y values for the contour plot. Generate two 2D Gaussian distributions, Z1 and Z2. For Z1, use the negative exponent of the squares of X and Y. For Z2, scale X and Y by a factor of 5 before squaring and taking the exponent. Combine these two distributions into a single variable z by adding Z1 and Z2 multiplied by 45. Introduce 6 points of negative values in the bottom-left corner of the z array to test the log scaling. Mask out non-positive values in z to avoid issues when taking the logarithm. Use Matplotlib's contourf function to create a filled contour plot. Utilize the LogLocator from Matplotlib's ticker module for automatic selection of log-scaled levels.  Apply a colormap of your liking to the contour plot for aesthetic preference. Add a colorbar to the plot to show the log scale of the values. Finally, display the plot using plt.show().",
        "expert_instruction": "Import Necessary Libraries: Instruct the model to import matplotlib.pyplot, numpy, and relevant submodules from Matplotlib like cm (for colormap) and ticker (for setting the axis scales).Data Preparation:Define a grid of points to create arrays x and y. Specify the range for these arrays.Create 2D grid coordinates X and Y from the 1D arrays.Define a function Z1 as an exponential decay based on X and Y.Define another function Z2 with a sharper decay, scaled by a factor of 10 for both X and Y.Combine Z1 and Z2 to create the final data array z. Multiply Z2 by a factor (like 50) to create a spike in the data.Handling Negative Values:Introduce some negative values in a part of the z array to demonstrate handling of such values in a logarithmic plot.Mask the array wherever it is less than or equal to 0, to avoid issues with logarithmic scaling.Plotting:Create a figure and axis using matplotlib.pyplot.subplots.Create a contour plot using ax.contourf, with X, Y, and z as inputs. For the scale, use ticker.LogLocator() to set a logarithmic scale.Optionally, mention an alternative method to manually set levels and normalization using logarithmic scaling.Add a color bar to the plot using fig.colorbar.Display the Plot: Instruct to use plt.show() to display the final plot.",
        "id": 67
    },
    {
        "simple_instruction": "Create a Python script using matplotlib and numpy to generate a heatmap visualization. This heatmap should represent a dataset of average monthly temperatures in degrees Celsius in various cities throughout the year. Use a color map appropriate for temperature data, ensuring that the values within each cell are annotated for clarity. The annotated values should change to a lighter color when in cells with darker color and vice versa to improve contrast and readability. The rows should be labeled with the names of the months, such as January, February, March, April, May, June, July, August, September, October, November, and December. The columns should be labeled with names of cities like New York, London, Tokyo, Sydney, Cairo, Buenos Aires, and Moscow. Include a color bar on the right side of the heatmap to indicate the temperature scale, labeled as 'temperature [\u00b0C]'. Rotate the tick labels on the x-axis for better readability and use white grid lines to clearly delineate the cells. Implement a function to create the heatmap and another to annotate it with temperature values, formatted to one decimal place. Finally, adjust the layout for a tight fit and display the plot. Use the following data: months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",          \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] cities = [\"New York\", \"London\", \"Tokyo\", \"Sydney\", \"Cairo\", \"Buenos Aires\", \"Moscow\"] temperatures = np.array([    [-1, 5, 6, 26, 14, 25, -7],    [-1, 5, 7, 26, 15, 23, -9],    [3, 7, 10, 20, 20, 20, -4],    [10, 10, 15, 18, 25, 15, 6],    [16, 13, 20, 15, 30, 11, 15],    [21, 16, 22, 13, 35, 8, 19],    [25, 19, 27, 10, 35, 8, 21],    [24, 18, 29, 13, 35, 10, 20],    [20, 15, 24, 17, 30, 14, 13],    [14, 11, 19, 20, 25, 18, 7],    [8, 7, 13, 22, 20, 21, 0],    [2, 5, 9, 24, 15, 23, -5]])",
        "expert_instruction": "Create a heatmap visualization of average monthly temperatures for various cities throughout the year using matplotlib and numpy.Start by importing the matplotlib.pyplot and numpy libraries in Python.Define a function named create_heatmap that takes three arguments: temperatures, a 2D numpy array of temperature values; row_labels, a list of strings for row labels (months); and col_labels, a list of strings for column labels (cities).Inside this function, create a subplot using matplotlib.pyplot.subplots().Display the temperature data as a heatmap using the imshow function of the axes object, with the color map set to 'coolwarm' and aspect ratio set to 'auto'.Annotate each cell of the heatmap with the corresponding temperature value. Adjust the text color to white for darker cells and black for lighter cells for better contrast and readability. The temperature values should be formatted to one decimal place.Set the x-axis and y-axis ticks positions to correspond to the number of columns and rows, respectively.Label the x-axis and y-axis with the provided city and month names.Rotate the x-axis tick labels by 45 degrees for better readability, and adjust their alignment.Add a color bar to the right side of the heatmap, representing the temperature scale. Label the color bar with 'Temperature [\u00b0C]' and rotate this label for appropriate orientation.Add white grid lines to the heatmap for clarity by setting minor ticks and applying a white grid on them.Adjust the layout of the plot for a tight fit using plt.tight_layout().Finally, display the heatmap using plt.show().",
        "id": 68
    },
    {
        "simple_instruction": "Write a Python script using matplotlib that creates a compound plot to demonstrate a zoom effect on the x-axis. The main plot should be at the bottom, showing the full range, in which there are two filled areas with light blue color indicating the zoomed-in regions. Above the main plot, create two smaller subplots side by side, each representing a zoomed-in section of the main plot. The subplots should highlight specific x-axis ranges with a light blue fill to indicate the zoomed regions. Include black slanted lines from the top of the main plot at the boundaries of the zoomed sections pointing to the subplots to signify the transition between the zoomed and full-range views. Ensure that the x-axis labels and tick marks are properly aligned and clearly indicate the relationship between the zoomed sections and the main plot's x-axis range.",
        "expert_instruction": "Create a Python script using the Matplotlib library to demonstrate the zoom effect in plots.Import Necessary Libraries: Include imports for matplotlib.pyplot, and specific functions from matplotlib.transforms and mpl_toolkits.axes_grid1.inset_locator.Connect Bounding Boxes Function: Ask for a function connect_bbox that takes two bounding boxes, locations for the connection points, properties for lines and patches. This function should create connectors and patches between the two bounding boxes.Zoom Effect Function with Specified Range: Request a function zoom_effect01 which takes two axes (ax1 and ax2), and a range defined by xmin and xmax. This function should mark a range in both axes to illustrate a zoom effect from ax1 to ax2.Zoom Effect Function with Automatic Range: Ask for a function zoom_effect02 similar to zoom_effect01, but it should automatically determine the xmin and xmax from the view limits of ax1.Setup and Apply Zoom Effects: The script should create a subplot mosaic with two zoomed subplots and one main subplot. Then apply zoom_effect01 to one zoomed subplot and the main plot with a specified range. Apply zoom_effect02 to the other zoomed subplot and the main plot.Display the Plot: Finally, instruct to include a command to display the plot using plt.show().This set of instructions would guide the language model to create a script that visually demonstrates zoom effects in a matplotlib plot)",
        "id": 71
    },
    {
        "simple_instruction": "Create a visually engaging bubble plot titled 'A colored bubble plot' using Python's plotting libraries. The plot should display a relationship between two variables, represented by the X and Y axes, with the following characteristics: Data Generation: The plot should be based on randomly generated data points. There should be 15 data points in total. Each point's position on the X-axis is determined by a random value, and its position on the Y-axis should be influenced by its corresponding X value but with some added randomness. Bubble Characteristics: The size of each bubble should vary, reflecting another dimension of the data. Specifically, the bubble size should be related to the X-axis value, but with an additional transformation to make the size variation more pronounced. Color Scheme: The color of the bubbles should be a gradient based on their position along the X-axis, using a cool color scheme like blues or greens. The bubbles should also have a degree of transparency for aesthetic appeal, and grey outlines to enhance visibility. Axis Labels and Title: Include clear labels for both the X and Y axes and a descriptive title for the plot that encapsulates its purpose or the nature of the data being represented. Display: Ensure the final plot is displayed clearly.",
        "expert_instruction": "Import Libraries: Begin by importing the necessary libraries. In this case, the model should import matplotlib.pyplot as plt, numpy as np, and seaborn as sns.Create Data: The next step is to generate the data that will be plotted. The model should create three numpy arrays:x: a random array with 15 elements.y: an array where each element is the sum of the corresponding element in x and a new random value.z: an array where each element is the sum of the corresponding element in x and a new random value, and then each element of this array is squared.Plotting the Data: The model should then use the scatter function from matplotlib to create a bubble plot. This involves:Mapping the x and y arrays to the respective axes.Using the z array to determine the size of the bubbles, multiplying it by a factor (2000 in this case) for visibility.Coloring the bubbles based on the values in the x array using a color map (like \"Blues\").Setting the transparency of the bubbles with the alpha parameter.Adding grey edge colors to the bubbles with a certain linewidth.Adding Titles and Labels: The model should add titles to the plot and labels to the axes. Specifically, it should:Label the x-axis as \"the X axis\".Label the y-axis as \"the Y axis\".Add a main title to the plot, such as \"A colored bubble plot\".Displaying the Plot: Finally, the model should include a command to display the plot, using plt.show().",
        "id": 74
    },
    {
        "simple_instruction": "Create a visual representation in Python that compares two groups of data, 'Group 1' and 'Group 2'. Each group should consist of 100 random data points, following a normal distribution. 'Group 1' should have a mean of 100 and a standard deviation of 30, while 'Group 2' should have a mean of 130 and a standard deviation of 30. The plot should uniquely combine a beeswarm plot and boxplots for a clear comparison of these two groups. The beeswarm plot must display the distribution of each group's data points without overlap, and the boxplots should be overlaid on the same chart to summarize the statistical distributions. The beeswarm plot representing Group 1 should have the color blue, the other beeswarm plot should have the color orange. Include the title 'Beeswarm plot and Boxplots, made with matplotlib', a y-axis label, and a legend indicating the groups. The final visualization should be displayed using matplotlib.",
        "expert_instruction": "Objective: Write a Python script using matplotlib, numpy, and pandas to create a combined beeswarm and boxplot visualization for two groups of data.Data Generation:Generate two sets of random data, each following a normal distribution.The first dataset (Group 1) should have 100 data points with a mean of 100 and a standard deviation of 30.The second dataset (Group 2) should have 100 data points with a mean of 130 and a standard deviation of 30.Combine these two datasets into a single array and create a corresponding categorical array indicating the group of each data point.Store this data in a pandas DataFrame with columns named 'numerical_variable' and 'categorical_variable'.Beeswarm Plot Function:Write a function simple_beeswarm2(y, nbins=None, width=1.) that computes x coordinates for a beeswarm plot.The function should accept a list of y-values and optionally the number of bins and the width for the plot.It should return x coordinates that, when plotted against y, result in a beeswarm plot.Plotting:Create a matplotlib figure and axis.Hide the x-axis of the plot.For each unique category in the DataFrame, plot a beeswarm plot using the simple_beeswarm2 function.Ensure each group's plot is shifted horizontally to prevent overlapping.Add boxplots above the beeswarm plots for each group.Customize the plot with a title ('Beeswarm plot and Boxplots, made with matplotlib'), y-axis label ('Y Axis Label'), and a legend indicating each group.Display:Show the final plot using plt.show().",
        "id": 75
    },
    {
        "id": 77,
        "simple_instruction": "I have data of protein consumption in 24 European countries named \"data.csv\". The column of data are [\"Country\",\"Red Meat\",\"White Meat\",\"Eggs\",\"Milk\",\"Fish\",\"Cereals\",\"Starch\",\"Nuts\",\"Fruits & Vegetables\"].\nWrite a Python code to visualize this data using a 2D scatter plot with K-Means clustering into three distinct color-coded clusters. The plot should include semi-transparent ellipses around each cluster, lines connecting data points to cluster centroids, and annotations for each point representing countries. It should be well-labeled and include a legend, aiming for clarity and visual grouping.",
        "expert_instruction": "I have data of protein consumption in 24 European countries named \"data.csv\". The column of data are [\"Country\",\"Red Meat\",\"White Meat\",\"Eggs\",\"Milk\",\"Fish\",\"Cereals\",\"Starch\",\"Nuts\",\"Fruits & Vegetables\"].\nWrite a python code to create an image of a 2D scatter plot representing a K-Means clustering of data. The plot should have three distinct clusters of points, each in its own color. For example, Cluster 0 could be blue, Cluster 1 could be red, and Cluster 2 could be green. Around each cluster, draw a semi-transparent ellipse in the same color as the cluster points but in a lighter shade, giving a sense of grouping. Connect each data point to the centroid of its cluster with a thick grey line. The background should have a grid, enhancing the plot's readability. Label the x-axis as 'Principal Component 1' and the y-axis as 'Principal Component 2'. Annotate each data point with a small text label close to it, which could be the names of countries for a realistic touch, but ensure the text is legible. The plot should have a title at the top: 'K-Means Clustering with PCA-reduced Data and Colored Ellipses'. Include a legend on the side, denoting the clusters with their respective colors."
    },
    {
        "id": 81,
        "simple_instruction": "Create a Sankey diagram using data from the 'data.csv' file. The diagram should clearly depict the flow from source nodes to target nodes, with the sources on the left and targets on the right. Each unique label in both source and target columns should have a consistent color throughout the diagram. The link weights should be based on the count of each unique source-target pair. Ensure the layout is clear, with distinct separation between the left (source) and right (target) sides. Save and display the final diagram.",
        "expert_instruction": "Create a Sankey diagram from the 'data.csv' file, where the source and target nodes are positioned on the left and right sides respectively, and ensuring the colors are consistent for matching source and target labels. You would follow these steps:\n1. Read Data: Load the data from 'data.csv' using Pandas, setting header=None and naming the columns 'Source' and 'Target' immediately after reading the file.\n2. Calculate Weights: Group the data by 'Source' and 'Target' columns and calculate the count of each unique pair. These counts will be used as weights for the Sankey links.\n3. Generate Node Labels and Colors:\n  - Create a list of unique labels for all items in both 'Source' and 'Target' columns.\n  - Assign a unique color to each unique label, ensuring that labels shared between sources and targets use the same color.\n4. Create Sankey Diagram:\n  - Use Plotly's go.Sankey to construct the diagram. Define node labels and colors, ensuring that the source nodes are on the left and target nodes are on the right. This is typically handled by the Sankey diagram layout itself, where source nodes flow to target nodes.\n  - Specify the nodes and their colors, and define the links with source indices, target indices, and weights.\n  - Customize the layout to ensure clarity and distinction between the left (source) and right (target) sides.\n5. Save and Display: Output the generated Sankey diagram."
    },
    {
        "id": 82,
        "simple_instruction": "I have a data named \"data.json\", showing the flow of energy in terawatt-hours (TWh).\nThe data.json file contains a dictionary at the root level with two keys: 'data' and 'layout'. Here's an overview of its structure:\n- 'data': This key corresponds to a list, and the length of this list is 1, indicating there is one primary data object. This object contains the following keys:\n  - 'type': Presumably indicates the type of plot or data representation.\n  - 'domain': Possibly specifies the domain or space in which the data is plotted.\n  - 'orientation': The orientation of the data visualization.\n  - 'valueformat': Format for numerical values, such as currency or percentages.\n  - 'valuesuffix': A suffix to append to the values, like units of measurement.\n  - 'node': An object containing information about the nodes in the Sankey diagram.\n  - 'link': An object containing information about the links between nodes in the Sankey diagram.\n- 'layout': This key corresponds to a dictionary that likely contains layout settings for the visualization, such as size, margins, titles, and other styling options.\nTo make a diagram showing energy flows using \"data.json\":\n1. Open the Data File: Start by opening the \"data.json\" file to read the energy data.\n2. Color Settings:\n  - Decide how see-through you want the link colors to be.\n  - Choose colors for each energy type or process, making sure they are a bit see-through too.\n3. Set Up Nodes:\n  - Nodes are the boxes or points that represent different types of energy or processes. Make sure each has a label and color.\n  - Adjust how far apart and how thick each node is.\n4. Set Up Links:\n  - Links are the arrows or lines that show the energy moving from one node to another. Make sure each has a starting point, an ending point, how much energy it represents, and a color.\n  - The color of the links should match the energy source or process it's coming from but a bit lighter.\n5. Finished Diagram:\n  - Your final diagram will show all the different types of energy on one side, what they're used for on the other, and all the energy flows between them. The thickness and color of each link will help show how much energy is moving.",
        "expert_instruction": "I have a data named \"data.json\", showing the flow of energy in terawatt-hours (TWh).\nThe data.json file contains a dictionary at the root level with two keys: 'data' and 'layout'. Here's an overview of its structure:\n- 'data': This key corresponds to a list, and the length of this list is 1, indicating there is one primary data object. This object contains the following keys:\n  - 'type': Presumably indicates the type of plot or data representation.\n  - 'domain': Possibly specifies the domain or space in which the data is plotted.\n  - 'orientation': The orientation of the data visualization.\n  - 'valueformat': Format for numerical values, such as currency or percentages.\n  - 'valuesuffix': A suffix to append to the values, like units of measurement.\n  - 'node': An object containing information about the nodes in the Sankey diagram.\n  - 'link': An object containing information about the links between nodes in the Sankey diagram.\n- 'layout': This key corresponds to a dictionary that likely contains layout settings for the visualization, such as size, margins, titles, and other styling options.\nEach of these keys ('node' and 'link' under 'data') likely holds further details about the nodes and links, respectively, such as labels, colors, sources, targets, and values. This structure is typical for a Plotly data object, where 'data' defines the figures and 'layout' defines how they're presented.\nPlot a sankey diagram to display energy sources on the left, uses and losses on the right, and links showing the flow of energy in terawatt-hours (TWh)\n1. **Read the JSON Data**:\n   Load your data with json.load(open('data.json', encoding='utf-8')).\n\n2. **Customize Node and Link Colors**: \n- Set an opacity level for the link colors (e.g., 0.4).\n- Change specific node colors to 'rgba' format to add opacity. For example, replace 'magenta' with its 'rgba' equivalent, ensuring transparency.\n\n3. **Sankey Diagram Nodes**: \n- Define nodes with padding, thickness, line color, labels, and custom colors using the node dictionary in go.Sankey.\n- Ensure the labels from the JSON data are correctly assigned.\n\n4. **Sankey Diagram Links**: \n- Define links with source indices, target indices, values, and colors using the link dictionary in go.Sankey.\n- Set the link colors to match the source node colors with adjusted opacity.\n\n5. **Figure Layout**: \n- Use fig.update_layout to set the title, including HTML formatting for links, and adjust font size.\n\n6. **Save the Figure**: \n- Save the Sankey diagram.\n\n7. **Resulting Diagram**: \n- The resulting diagram will display energy sources on the left, uses and losses on the right, and links showing the flow of energy in terawatt-hours (TWh).\n- The thickness and color intensity of the links correspond to the flow magnitude, with the color scheme reflecting the type of energy source or use."
    },
    {
        "id": 83,
        "simple_instruction": "I want to create a line chart of the Dow Jones Industrial Average from October 2006 to August 2013 using Python. The data is in 'data.csv' with columns \"date\", \"Dow Jones Industrial Average\" and \"1 year moving average\". Write a Python code to read the data and draw two lines on the chart. You should also color the area between the lines based on certain rules. Then add a title, labels, and a legend, and make sure the dates are readable.",
        "expert_instruction": "I want to plot a line graph of the Dow Jones Industrial Average (DJIA) from October 2006 to August 2013.\nThe data is in 'data.csv'\nThe data contains three columns:\ndate: The date of the record.\nDow Jones Industrial Average: The daily closing value of the DJIA.\n1 year moving average: The 1-year moving average value of the DJIA.\nWith this data, you can plot the line graph using Python. Here's how you can do it:\n\n- Read the data from the CSV file using pandas.\n- Convert the date column to datetime for proper plotting.\n- Plot the daily DJIA values and the 1-year moving average as lines on the graph.\n- Fill the area between the lines with the appropriate colors using the fill_between method.\n- Set the title of the graph and labels for the X and Y axes.\n- Adjust the X-axis to display the dates in a readable format.\n- Add a legend to the graph."
    },
    {
        "id": 85,
        "simple_instruction": "To plot a circular dendrogram from \"data.csv\". This DNA Microarray data of 73 lung tissues including 67 lung tumors. There are 916 observations of genes for each lung tissue. Write a python code to plot a circular dendrogram using this data.\n1. Load and Prepare Data:\n  - Read \"data.csv\" into a DataFrame and exclude the first column with gene identifiers. Transpose the matrix to have tissues as columns and genes as rows.\n2. Hierarchical Clustering:\n  - Perform hierarchical clustering using correlation as the distance and 'average' linkage. Extract dendrogram data (linkage points and distances).\n3. Circular Dendrogram Transformation and Plotting:\n  - Convert the dendrogram coordinates into a circular format, ensuring that the coordinates encompass a full 360-degree range. Plot the transformed data on a polar coordinate system, forming branches of the dendrogram.\n4. Enhancement and Annotation:\n  - Color-code branches by clusters, label tissue samples at the perimeter, and design a correlation axis with higher correlations near the center. Clearly indicate the clustering method and distance type used.",
        "expert_instruction": "I have a data named \"data.csv\". This DNA Microarray data of 73 lung tissues including 67 lung tumors. There are 916 observations of genes for each lung tissue. Write a python code to plot a circular dendrogram using this data.\n1. Matrix Reconfiguration:\n  - Organize the data matrix with 916 rows, each representing a gene, and 73 columns for the lung tissues, excluding the first column of gene identifiers.\n2. Hierarchical Clustering:\n  - Apply hierarchical clustering to the transposed matrix (if needed) so that each column represents a lung tissue sample, and each row represents a gene observation.\n3. Dendrogram Data:\n  - Post-clustering, extract the dendrogram structure with linkage points (icoord) and correlation distances (dcoord).\n4. Circular Layout Transformation:\n  - Transform icoord into angles around a circle, distributing tissue samples evenly.\n  - Convert dcoord to radial coordinates inversely related to correlation, with higher correlations near the center.\n5. Circular Dendrogram Plotting:\n  - Plot the dendrogram on a polar coordinate system.\n  - Form branches by connecting points with angular (theta) and radial (r) coordinates.\n6. Branches and Cluster Coloring:\n  - Assign colors to branches to represent different clusters, ensuring consistency within and distinction between clusters.\n7. Lung Tissue Sample Labeling:\n  - Label each sample at the circle's edge corresponding to each branch endpoint, preferably with unique identifiers or abbreviations.\n8. Correlation Axis Implementation:\n  - Design the correlation axis so that higher correlations are near the center and lower correlations are towards the outer edge.\n9. Methodological Details:\n  - Clearly indicate the distance and clustering method used, typically near the bottom or center of the circular dendrogram."
    },
    {
        "id": 86,
        "simple_instruction": "The data from the CSV file \"data.csv\" consists of a table where:\nThe first column lists the Windows operating system versions (WinXP, Win7, Win8.1, Win10).\nThe subsequent columns represent the years from 2015 to 2019.\nEach cell in the table contains the market share percentage of the corresponding Windows version for that year.\n- Create a doughnut chart titled \"Desktop Windows Version Market Share Worldwide,\" displaying the market share from 2015 to 2019.\n- Each concentric ring in the chart represents a different year, with the innermost ring representing 2015 and the outermost representing 2019.\n- Assign distinct color families to each Windows version (WinXP, Win7, Win8.1, Win10), with the colors progressively darkening for each subsequent year.\n- Directly annotate each segment with its respective market share percentage.\n- At the top of each ring, include a white section representing the market share of other operating systems for that year. Inside this white section, label the corresponding year.\n- Ensure that the white sections for all years are aligned at the top of their respective rings.\n- Place a legend in the central blank area of the doughnut chart, indicating the colors associated with each Windows version.\n- The design should align the white sections visually for easy comparison and maintain a uniform appearance.\nThis design will clearly showcase the market share changes of different Windows versions over time, while elegantly including data for other operating systems.",
        "expert_instruction": "The data from the CSV file \"data.csv\" consists of a table where:\nThe first column lists the Windows operating system versions (WinXP, Win7, Win8.1, Win10).\nThe subsequent columns represent the years from 2015 to 2019.\nThe column name is [\"Version\",\"2015\",\"2016\",\"2017\",\"2018\",\"2019\"].\nEach cell in the table contains the market share percentage of the corresponding Windows version for that year.\nWrite a Python code to draw a graph displaying the market share of various Windows versions from 2015 to 2019 using a doughnut chart with multiple tightly packed rings. Here are the specifications:\n- Title: The chart should be titled \"Desktop Windows Version Market Share Worldwide.\"\n- Rings: Each ring in the doughnut chart represents a year, starting from the center with 2015 and moving outwards to 2019. The rings should be tightly packed together, with no visible gaps between consecutive years.\n- Color Palettes: Different Windows versions are represented by distinct color palettes, with variations in shade for different years. For instance, WinXP could use a range of blue tones, Win7 red tones, Win8.1 green tones, and Win10 purple tones. The shades should progressively darken from the center to the outer rings to represent the passage of time from 2015 to 2019.\n- Segment Labels: Label segments with their respective market share percentages directly on them. The color shades should be lighter near the doughnut's center and darker towards the edge.\n- Other Versions: Use white segments to represent the market share of other Windows versions not listed. Each white segment should be positioned at the top of its respective ring, with all white segments across the years aligned vertically for visual consistency and easy comparison.\n- Legend: Include a legend at the chart's center, indicating which color palette corresponds to each Windows version.\n- Version Order: The order of the Windows versions should be the same for each year to achieve alignment. The reference order is WinXP, Win8.1, Win7, Win10.\nThe key addition here is the alignment of the white segments (representing other versions) at the top of each ring, ensuring they are vertically aligned across the years for a uniform appearance and straightforward comparison."
    },
    {
        "id": 91,
        "simple_instruction": "Create a 3D Waterfall plot using the 'data.csv' file, where the first column represents time and the subsequent columns represent time-series data for different frequencies. Each frequency should be plotted as a separate line, distinctly colored and marked, and displayed on different y-coordinates to avoid overlap. For clarity, add a light grey fill below each line. Set the camera to -69 degrees azimuth and 15 degrees elevation for optimal viewing. Ensure the y-axis is elongated to twice the length of the x-axis to distinctly space the frequency lines. Remove y-axis ticks. Label the axes appropriately: 'Time (sec)' for the x-axis, 'Frequency (Hz)' for the y-axis, and 'Amplitude (a.u.)' for the z-axis.",
        "expert_instruction": "Create a 3D Waterfall plot using the 'data.csv' file, which consists of a first column for time and subsequent columns for time-series data representing different frequencies. Ensure the y-axis is elongated to twice the length of the x-axis to distinctly space the frequency lines. Each frequency should be plotted as a separate line, distinctly colored and marked, and displayed on different y-coordinates to avoid overlap. Below each line, add a light grey fill for visual clarity. Adjust the plot's camera to an azimuth of -69 degrees and an elevation of 15 degrees to prevent overlap and make the data more discernible. Remove the scale from the y-axis for a neater appearance. Label the axes appropriately: 'Time (sec)' for the x-axis, 'Frequency (Hz)' for the y-axis, and 'Amplitude (a.u.)' for the z-axis. The final plot should display with a customized aspect ratio highlighting the stretched y-axis."
    },
    {
        "id": 92,
        "simple_instruction": "Create a stacked radial plot from \"data.csv\" showcasing 'Pollution Index' and 'Water Temp' with distinct white rings for separation. Begin with a hollow center for clarity. Draw two lines from the center to the edge: one to depict 'Pollution Index' in red and another for 'Water Temp' in a shade of blue. Between the two sets of data, maintain a white ring to visually separate them. Fill the region from the blue line representing 'Water Temp' to the white ring with a semi-transparent blue, and similarly, fill from the red line representing 'Pollution Index' to the hollow center with a semi-transparent red. Ensure the plot label the angular axes with dates formatted as 'YYYY-MM-DD' to prevent overlap. The visualization should be finalized with a clear title 'Stacked Radial Plots with Hourly Data' and a legend that differentiates the datasets.",
        "expert_instruction": "To create a radial plot from the \"data.csv\" file that visualizes the 'Pollution Index' and 'Water Temp', with a distinct design featuring two white rings for separation, follow these instructions:\n1. Load the \"data.csv\" file, ensuring to parse the 'Time' column as datetime, formatted as \"%Y-%m-%d %H:00:00\", and set it as the index.\n2. Create a radial plot to display 'Pollution Index' and 'Water Temp' without averaging the data, making each time point distinct.\n3. Offset the 'Water Temp' values to create a white ring that visually separates it from the 'Pollution Index', providing a clear delineation between the two data sets.\n4. Add another white ring at the center of the plot to anchor the design and enhance readability.\n5. Adjust the radial limits to be 10% greater than the maximum data values, ensuring the entire range of data is comfortably within view.\n6. Choose different semi-transparent colors for the 'Pollution Index' and 'Water Temp' to allow for visual overlap where necessary.\n7. Remove the radial grid labels to simplify the presentation.\n8. Set angular ticks to correspond with the unique dates from the data, formatted neatly as 'YYYY-MM-DD'.\n9. Include a descriptive title and a legend, clearly identifying the two variables.\n10. Ensure that the date labels are evenly spaced around the circumference of the plot, avoiding overlap and maintaining legibility."
    },
    {
        "id": 93,
        "simple_instruction": "Create a 3D plot from a CSV file named \"data.csv\" using the columns \"t\", \"bond 1-2\", \"bond 1-14\", and \"tot energy / Eh\" to visualize an ab initio molecular dynamics (AIMD) calculation of an ion pair. The plot should have three axes: two for the bond lengths (\"bond 1-2\" and \"bond 1-14\") and one for the total energy in Hartrees (Eh). Color the points along the trajectory from red (start) to blue (end) using the jet color map to represent time progression. Include larger, semi-transparent markers for each point, with connecting lines to show the trajectory. Add semi-transparent projection lines onto the XY, XZ, and YZ planes in blue, red, and green, respectively. Include a legend for these projection lines and a color bar legend to indicate time in femtoseconds. Label the axes as \"Bond 1-2\", \"Bond 1-14\", and \"Total Energy / Eh\" and format the z-axis labels for clarity.",
        "expert_instruction": "Create a 3D plot that visualizes the trajectory of an ab initio molecular dynamics (AIMD) calculation of an ion pair. The data for this plot is loaded from a CSV file named \"data.csv\", using the columns \"t\", \"bond 1-2\", \"bond 1-14\", and \"tot energy / Eh\" for the three dimensions. The plot will have three axes: two representing selected bond lengths and one representing the total energy in Hartrees (Eh). \nThe points on the plot are colored according to time intervals, with the start of the trajectory in red and the end in blue. The color map and normalization for the trajectory points are defined using the jet color map from matplotlib. \nThe plot includes markers for each point on the trajectory, which are larger and semi-transparent. The trajectory is also represented with connecting lines between the points. \nIn addition to the 3D trajectory, the plot also includes semi-transparent projection lines onto the XY, XZ, and YZ planes. These projection lines are colored in blue, red, and green respectively. \nA legend is added to the plot for the projection lines. A color bar legend is also added on the left side of the plot, representing the time in femtoseconds. \nThe axes of the plot are labeled as \"Bond 1-2\", \"Bond 1-14\", and \"Total Energy / Eh\". The z-axis labels are formatted to reduce their length and prevent overlap."
    },
    {
        "id": 95,
        "simple_instruction": "Create a polar coordinate diagram using data from \"data.csv\" to display the highest temperatures on the first of each month in Amherst, spanning from January 1, 2004, to August 1, 2015. The data includes columns labeled \"Year,\" \"Date,\" and \"Temperature.\" The diagram should include:\n\n- 12 sectors, each representing a month of the year.\n- Temperature data plotted according to the corresponding month.\n- Circular points for the temperature data, slightly offset to prevent alignment along a single radial line.\n- Abbreviated labels for the months (Jan, Feb, Mar, etc.).\n- A blue curve that connects the data points from the year 2015.\n- A legend positioned on the right side of the diagram.\n- A title: \"Monthly Highest Temperature in Amherst (2004-2015).\"\nThe purpose of the diagram is to clearly illustrate the temperature trends and monthly variations over the years, with an emphasis on the data from 2015.",
        "expert_instruction": "I want a polar coordinate diagram to visualize the highest temperature data in Amherst on the first of each month, spanning from January 1, 2004, to August 1, 2015. The data is named \"data.csv\". The data contains three columns: \"Year,\" \"Date,\" and \"Temperature.\" Here are My specific requirements for the visualization:\n- The diagram should be divided into 12 sectors, corresponding to the months of the year.\n- Temperature data should be plotted on the diagram according to the month.\n- The points representing the temperature data should be circular.\n- These points should be slightly offset so as not to align on a single radial line, with each point for the 1st of a month positioned between that month and the next. The offset should range from 0 to \u03c0/6 radians.\n- Month labels should be abbreviated (Jan, Feb, Mar, etc.) instead of numerical (1, 2, 3, etc.).\n- A blue curve should connect the data points for the year 2015 to distinguish it from other years.\n- The legend should be moved to the right to avoid overlapping the diagram.\nThe diagram will serve as a clear visual representation of temperature trends and variations by month over several years, with particular emphasis on the data from 2015."
    },
    {
        "id": 97,
        "simple_instruction": "Create two ternary phase diagrams from the dataset \"data.csv\", containing 'No.', 'IL (25\u00b0C)', 'toluene (25\u00b0C)', and 'n-heptane (25\u00b0C)'. Each row indicates a mixture composition of these components at 25\u00b0C, with 'No.' indicating different groups or conditions.\n\nFor both diagrams:\n- Title: \"Liquid-Liquid Phase Diagram\".\n\n1. Equilateral Triangle Diagram:\n  - Plot with 'toluene' at the top, 'n-heptane' at the bottom left, and 'IL' at the bottom right.\n  - Transform component fractions to Cartesian coordinates for an equilateral layout.\n  - Plot data points as circles, connect same 'No.' group points with dashed lines, and use different colors for each group.\n  - Label each vertex with the component name and draw borders for the triangle and remove axis ticks and labels for a clean look.\n2. Right-Angled Triangle Diagram:\n  - Plot with 'IL' on the vertical axis, 'toluene' on the horizontal axis, right angle at the bottom left.\n  - Transform for a right-angled layout, similarly plot and connect points, using the same color scheme.\n  - Label axes with 'IL' and 'toluene', and draw borders for the triangle and remove axis ticks and labels for a clean look.\nDisplay both diagrams side-by-side, maintaining an equal aspect ratio for comparison.",
        "expert_instruction": "Create two ternary phase diagrams using the provided dataset named \"data.csv\". The dataset contains columns 'No.', 'IL (25\u00b0C)', 'toluene (25\u00b0C)', and 'n-heptane (25\u00b0C)', where each row represents a unique mixture composition of these three components at 25\u00b0C. The 'No.' column categorizes the data into different groups or experimental conditions.\n\nFor both diagrams:\n- Title: \"Liquid-Liquid Phase Diagram\".\n\nEquilateral Triangle Diagram:\n\n- Plot an equilateral triangle ternary diagram.\n- Position 'toluene' at the top vertex, 'n-heptane' at the bottom left vertex, and 'IL' at the bottom right vertex.\n- Convert the component fractions to Cartesian coordinates suitable for an equilateral triangle layout.\n- Plot each data point as a circle and connect points within the same 'No.' group with dashed lines.\n- Use different colors for each 'No.' group and add a legend to distinguish these groups.\n- Label each vertex of the triangle with the corresponding component name.\n- Draw borders for the triangle and remove axis ticks and labels for a clean look.\n\nRight-Angled Triangle Diagram:\n\n- Plot a right-angled triangle ternary diagram.\n- Position 'IL' on the vertical axis, 'toluene' on the horizontal axis, and have the right angle at the bottom left corner.\n- Convert the component fractions to Cartesian coordinates suitable for a right-angled triangle layout.\n- Plot each data point as a circle and connect points within the same 'No.' group with dashed lines.\n- Use the same color scheme as the equilateral diagram for consistency, and include a legend.\n- Label the vertical and horizontal axes with 'IL' and 'toluene' respectively.\n- Draw borders for the triangle and remove axis ticks and labels for a clean look.\nEnsure both diagrams are plotted side-by-side for easy comparison, and maintain an equal aspect ratio for both diagrams."
    },
    {
        "id": 98,
        "simple_instruction": "Create a multi-layered graph using Python with my data, follow these streamlined steps:\n1. Data Preparation:\n  - Load 'Imports.csv' and 'Consumption.csv'. 'Imports.csv' contains 'Year', 'Urban', and 'Rural' for grain imports, and 'Consumption.csv' has similar columns for consumption data.\n  - Load 'Grain_Consumption_Ratio.csv' for 2002, 2008, and 2016, with 'Year', 'Age Group'  (e.g., \"0-14 years old\"), and 'Consumption Ratio'.\n2. Graph Structure:\n  - Title the graph as \"Grain Import and Consumption Trends\".\n  - Create a Multi Category Waterfall Chart for urban and rural imports, with yearly changes displayed as color-coded bars, and cumulative totals represented at the end.\n  - Plot a stacked area chart for consumption data on a secondary y-axis, with translucent colors for urban and rural data.\n  - Embed pie charts for grain consumption ratios in 2002, 2008, and 2016, using an 'explode' feature for the oldest age group.\n  - Align the waterfall and area charts on a common x-axis (years), overlaying the pie charts at corresponding years.\n  - Include legends for both imports and consumption, and annotate pie charts with percentage values.\n  - Use dual y-axes for imports and consumption quantities, and adjust scales for clarity and proportionate representation.\n  - Merge and align all charts into a cohesive graph, ensuring legibility and visual flow.",
        "expert_instruction": "Write a python code using this data to plot a multi-layered graph. The data is as follows:\n1. Imports.csv: Contains columns 'Year', 'Urban', and 'Rural', detailing grain imports for urban and rural areas per year.\n2. Consumption.csv: Includes 'Year', 'Urban', and 'Rural' columns, showing yearly grain consumption in urban and rural regions.\n3. Grain_Consumption_Ratio.csv: Features 'Year', 'Age Group' (e.g., \"0-14 years old\"), and 'Consumption Ratio', depicting the percentage of grain consumption by different age groups each year.\nTo create the multi-layered graph, follow these visualization requirements:\n1. Data Preparation and Titles:\n  - Load 'Imports.csv' and 'Consumption.csv' for grain imports, and urban and rural consumption data, along with datasets for grain consumption by age groups for 2002, 2008, and 2016.\n  - Title the graph \"Grain Import and Consumption Trends\" and label axes for import quantities (kg) and consumption (kg).\n2. Multi Category Waterfall Chart for Imports:\n  - Design a waterfall chart with two categories side-by-side for each year: one for urban and another for rural imports.\n  - Start by plotting the initial import quantities for both urban and rural categories, followed by bars side by side within each year to illustrate annual changes.\n  - Apply distinct color codes to represent increases and decreases for urban and rural data.\n  - Include connecting lines within each year to illustrate the trend between urban and rural imports.\n  - The last set of bars should display the total cumulative imports for both urban and rural areas at the end of the dataset's timeline.\n3. Stacked Area Chart for Grain Consumption:\n  - Plot urban and rural consumption data on a secondary y-axis.\n  - Use translucent colors for urban and rural areas to indicate overlapping consumption.\n  - Set y-axis scale from 35 to 105 kg for consumption data.\n4. Pie Charts for Age Group Consumption Ratios:\n  - Create pie charts for 2002, 2008, and 2016 to show grain consumption distribution by age groups.\n  - Use an 'explode' feature for the oldest age group in each pie chart.\n5. Combining Charts:\n  - Align the waterfall and area charts on the same x-axis.\n  - Overlay the pie charts at their respective years without obstructing underlying data.\n6. Legends, Annotations, and Scales:\n  - Introduce legends for imports, urban, and rural consumption areas, and annotate pie charts with percentage values.\n  - Set the x-axis with years and use dual y-axes for proportional representation of imports and consumption data.\n7. Final Adjustments and Linking:\n  - Ensure all textual elements, such as axis labels and legends, are legible and strategically placed to prevent clutter.\n  - Adjust the positioning of the pie charts to correspond accurately with the years 2002, 2008, and 2016 on the x-axis.\n  - Link the scales of the primary and secondary y-axes to maintain proportionate representation of data.\n8. Graph Merging and Alignment:\n  - Merge the waterfall and area charts into a single coherent graph.\n  - Align the pie charts with the specified years, resizing them to fit within the overall graph's layout without disrupting the visual flow."
    }
]