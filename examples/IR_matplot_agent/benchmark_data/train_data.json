[
    {
        "simple_instruction": "Create a Python script that uses mathematical and data visualization libraries to produce a violin plot. The plot should consist of two subplots sharing the y-axis, with the first subplot displaying a default violin plot and the second subplot showing a customized violin plot with no means, medians, or extrema. The bodies of the violins in the second subplot should be blue with black edges and an opacity alpha of 0.5. The data for the plot should be generated from a normal distribution with a seed of 12345678 for reproducibility, and should consist of five arrays of 150 sorted random numbers each, with standard deviations ranging from 2 to 6. The first quartile, median, and third quartile of the data should be calculated and the whiskers should be plotted using these values. The medians should be plotted as red dots on the first subplot, with vertical lines at the locations of the quartiles and whiskers. The x-axis labels for both subplots should be 'E', 'F', 'G', 'H', and 'I'. Adjust the bottom and wspace of the subplots for better visualization.",
        "expert_instruction": "Create a Python script that utilizes two libraries, one for mathematical functions and another for data visualization, to produce a violin plot. Start by importing the necessary libraries and defining two functions. The first function should calculate the upper and lower adjacent values, then return them. The second function should take two parameters, one for the axis and another for the labels, then set the x-ticks and x-label of the given axis.\n\nNext, generate some test data of random numbers from a normal distribution. Set a seed of 12345678 for reproducibility. The data should consist of five arrays of 150 sorted random numbers each, with standard deviations ranging from 2 to 6.\n\nCreate a figure with two subplots that share the y-axis. The first subplot should have the title 'Default violin plot' and the y-label 'Observed values'. It should display a default violin plot of the data. The second subplot should have the title 'Customized violin plot'. It should display a customized violin plot of the data, with no means, medians, or extrema shown. The bodies of the violins should be blue with black edges and an opacity alpha of 0.5.\n\nCalculate the first quartile, median, and third quartile of the data along the first axis. Calculate the whiskers using the first function you defined. Plot the medians as red dots on the first subplot. Add vertical lines at the locations of the quartiles and whiskers.\n\nFinally, set the x-axis style for both subplots using the second function you defined with labels 'E', 'F', 'G', 'H', and 'I'. Adjust the bottom and wspace of the subplots and display the plot.",
        "id": 3
    },
    {
        "simple_instruction": "\nCreate a matplotlib plot with the following characteristics:\n\nThe plot should be a 6x6 in figsize.\nIt should include a scatter plot of a correlated dataset with 700 data points, generated based on specific parameters ([0.6, 0.85] and [-0.3, 0.25] for correlations, and (1, 1) and (7, 6) for data point distribution).\nAdd vertical and horizontal lines in grey color through the dataset.\nOverlay three confidence ellipses on the scatter plot, each representing a different standard deviation (1, 2, and 3). The first ellipse should be in 'firebrick' color, the second in 'fuchsia' with a dashed line, and the third in 'blue' with a dotted line. Label these ellipses with '$1\\sigma$', '$2\\sigma$', and '$3\\sigma$' respectively.\nHighlight a specific point defined by the tuple (1, 1) on the plot with a red marker.\nThe title of the plot should be 'Different standard deviations'.\nInclude a legend for the plot.\nDisplay the final plot.",
        "expert_instruction": "Create a matplotlib plot that shows three confidence ellipses with different standard deviation, each wrapping a certain portion of scatter points:\n\n1. Begin by generating a subplot with a figure size of 6 by 6.\n2. Define a list, let's name it 'dependency_var', with two sublists: [0.6, 0.85] and [-0.3, 0.25].\n3. Define a tuple 'mu_var' with two elements: 1 and 1.\n4. Define another tuple 'scale_var' with two elements: 7 and 6.\n5. Draw a vertical and a horizontal line through the center of the plot with color 'grey' and line width 1.\n6. Generate a correlated dataset with 700 data points using the function that generates correlated dataset with 'dependency_var', 'mu_var', and 'scale_var' as arguments. Assign the output to two variables, let's call them 'x_var' and 'y_var'.\n7. Plot a scatter plot on 'ax_var' using 'x_var' and 'y_var' with a size of 0.5.\n8. Create three confidence ellipses on 'ax_var' using 'x_var' and 'y_var'. The first ellipse should have a standard deviation of 1, label '$1\\sigma$', and edge color 'firebrick'. The second ellipse should have a standard deviation of 2, label '$2\\sigma$', edge color 'fuchsia', and a dashed linestyle. The third ellipse should have a standard deviation of 3, label '$3\\sigma$', edge color 'blue', and a dotted linestyle.\n9. Plot a scatter point on the center with color 'red' and size 3.\n10. Set the title of 'ax_var' to 'Different standard deviations'.\n11. Add a legend to 'ax_var'.\n12. Finally, display the plot.",
        "id": 4
    },
    {
        "simple_instruction": "Create a plot consisting of a side-by-side pie chart and stacked bar chart with the following details:\n\nThe pie chart represents the distribution of fruits in a basket, with the proportions being 35% apples (with this slice separated from the others), 45% oranges, and 20% bananas.\nThe stacked bar chart shows the distribution of people favoring apples among different age groups: 25% under 18, 40% for ages 18-30, 20% for ages 30-50, and 15% for over 50.\nConnect the separated pie chart slice to the top and bottom of the stacked bar chart with lines, indicating the correspondence between the fruit types and their distribution among the age groups. These lines should be black in color and 1 in linewidth.\nEnsure the plot includes necessary adjustments for clarity and aesthetics, such as spacing between subplots, the orientation of the pie chart, labeling of the bar chart, titles for each subplot, a legend for clarity, and appropriate axis settings.\nDisplay the final plot.",
        "expert_instruction": "Compose a Python script that uses necessary libraries to generate a side-by-side pie chart and stacked bar chart. The stacked bar chart shows the composition of a specific slice of the pie chart. Start by importing the required libraries and creating a figure with two subplots. Adjust the space between the subplots.\n\nFor the pie chart, define the proportions, labels, and explode parameters. Rotate the chart so that the first segment is split by the x-axis. Create the pie chart on the first subplot, using the defined parameters.\n\nThe pie chart should represent the distribution of different types of fruits in a basket. The proportions could be 35% for apples, 45% for oranges, and 20% for bananas. The labels should correspond to these fruit types and the explode parameter should be set to separate the apple slice from the rest.\n\nFor the bar chart, define the proportions and labels. Create a loop to add bars to the existing bars from the top to stack them up. The legend should match the order of bars stacked. Set the title of the chart, add a legend, turn off the axis, and set the x-axis limit.\n\nThe bar chart should represent the distribution of these fruits among different age groups. The proportions shoud be 25% for under 18, 40% for 18-30, 20% for 30-50, and 15% for over 50. The labels should correspond to these age groups.\n\nUse a function from the imported libraries to draw connecting lines between the separated slice and the stacked bar chart. Calculate the coordinates for the top and bottom connecting lines based on the parameters of the pie chart and the height of the bar chart. Add the connecting lines to the second subplot and set their color and linewidth.\n\nFinally, display the plot.",
        "id": 5
    },
    {
        "simple_instruction": "Generate a scatter plot with polar projection using Python. The plot should have 200 points with their positions and colors determined by random values. The area of each point should be proportional to the square of its radial distance from the origin, and the color should be determined by its angle from the positive x-axis. The colors should be represented in the HSV color space. The plot should be reproducible with a fixed random state.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computation.\n2. Set a fixed random state for reproducibility using the numerical computation library's random seed function with the seed value as 12345678.\n3. Compute areas and colors for a scatter plot. To do this, first, define a variable N with a value of 200. Then, generate an array 'r' of N random values between 0 and 3 using the random.rand function from the numerical computation library. Similarly, generate an array 'theta' of N random values between 0 and 3\u03c0. The area of each point in the scatter plot is calculated as 300 times the square of corresponding 'r' value. The color of each point is determined by the corresponding 'theta' value.\n4. Create a new figure using the data visualization library's figure function.\n5. Add a subplot to the figure with a polar projection.\n6. Create a scatter plot on the subplot using the 'theta' and 'r' arrays for the polar coordinates, 'colors' array for the color of each point, 'area' array for the size of each point, 'hsv' for the colormap, and 0.85 for the transparency of the points.",
        "id": 8
    },
    {
        "simple_instruction": "Create a matplotlib plot with the following specifications:\n\n- Draw three curves on a single set of axes:\n  1. A blue curve representing the phase field tanh profile, following the equation 1/2 * (1 + tanh(gamma * x)), where gamma is a parameter set to 1.0.\n  2. An orange curve for the composition profile, using the equation 1/2 * (1 + tanh(omega * x)), with omega set to 2.0.\n  3. A green vertical line x=0 representing the sharp interface, two horizontal green line y=0 while x<0, y=1 while x>0.\n\n- Place text annotations on the plot:\n  - Above the blue curve, on the left side, add the text 'Phase Field: 1/2 * (1 + tanh(gamma * x))' with gamma set to 1.0.\n  - Above the orange curve, on the left side, add the text 'Composition: 1/2 * (1 + tanh(omega * x))' with omega set to 2.0.\n  - In the upper left part, add the values for the parameters: '\u03b3 = 1.0' and '\u03a9 = 2.0'.\n\n- Include an arrow annotation pointing towards the intersection of the blue and orange curves.\n\n- Label the x-axis as 'x' and the y-axis as 'y'.\n\n- Add a legend on the top left corner of the plot, identifying each curve and the sharp interface line.\n\n- The x-axis should range from -2 to 2 and the y-axis should range from 0 to 1.\n\nDisplay the plot once all elements have been added.",
        "expert_instruction": "Instruct the LLM to generate a Python code that creates a matplotlib plot with the following specifications:\n\n1. Start by creating a single figure and axis using the subplot function.\n2. Define a variable M with a value of 700 and epsilon with a value of 0.8. Generate an array Y with values ranging from -2 to 2 with M elements.\n3. On the same axis, plot three lines: \n   - The first line is a phase field tanh profile calculated as (2 - np.tanh(5 * Y / epsilon)) / 3.\n   - The second line is a composition profile calculated as (2.4 + np.tanh(5 * Y / epsilon)) / 5.\n   - The third line is a sharp interface represented by a dashed line where Y < 0.\n4. Add a legend to the plot with the labels \"phase field\", \"level set\", and \"sharp interface\". The legend should have a shadow, be located at (0.02, 0.58), have a handle length of 1.5, and a font size of 16.\n5. Add an arrow annotation at the center of the plot with a length equal to epsilon.\n6. Add a text annotation at the center of the arrow with the text epsilon.\n7. Set the x-ticks to -2, 0, and 2 and label them as \"-2\", \"+/- 0\", and \"+2\" respectively. The labels should be black and have a size of 20.\n8. Set the y-axis label as \"phase field\" phi, with a color of \"C0\" and a font size of 20. The y-ticks should be set to 0, 0.5, and 1 and labeled as \"0\", \".5\", and \"1\" respectively. The labels should be black and have a size of 20.\n9. Add a text annotation on the right y-axis labeled as \"level set\" phi, with a color of \"C2\", a font size of 20, and rotated 90 degrees.\n10. Add two multiline text annotations representing level set and phase field equations.\n11. Add two text annotations at (-2, .40) and (-2, .28) with the texts \"gamma: 1\" and \"Omega: 2\" respectively. The texts should be colored red and blue and have a font size of 20.\n12. Finally, display the plot using the show function.",
        "id": 11
    },
    {
        "simple_instruction": "Generate a Python script that creates a side-by-side bar chart using a list of x values from 1 to 20 and a list of 20 random y values. The bars should be colored blue if the corresponding y value is greater than 0, otherwise orange. The first chart should have a uniform transparency value for all bars and edges, while the second chart, normalize the absolute of y values to get distinct face alpha values and edge alpha values. The sum of one bar's alpha value and edge alpha value should be 1. The random number generator should have a fixed seed to ensure reproducibility. The titles for the first and second sections should be \"Uniform transparency value for all bars and edges\" and \"Adjusted transparencies for each bar and each edge\" respectively.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries that are used for data visualization and numerical computations.\n2. Set a fixed seed for the random number generator in the numerical computation library to ensure the results can be reproduced.\n3. Create a visual space with two sections arranged side by side and set the size of this visual space to 8x4.\n4. Generate a list of x values from 1 to 20.\n5. Generate a list of 20 random y values using the random number generator function from the numerical computation library.\n6. Create a list of colors for the bars, where each color is 'blue' if the corresponding y value is greater than 0, otherwise 'orange'. Use the same list for the edges of the bars.\n7. On the first section of the visual space, create a bar chart using the x and y values, colors for the bars, and colors for the edges. Set the transparency value to 0.6 for all bars and edges. Set the title of this section to \"Uniform transparency value for all bars and edges\".\n8. Adjust the y values to get distinct transparency values for each bar. Also, generate edge transparency values by subtracting each bar transparency from 1.\n9. Combine each bar color with its corresponding bar transparency, and each edge color with its corresponding edge transparency, into two separate lists.\n10. On the second section of the visual space, create a bar chart using the x and y values, and the lists of colors with transparencies. Set the title of this section to 'Adjusted transparencies for each bar and each edge'.\n11. Finally, display the visual space with the two sections.",
        "id": 12
    },
    {
        "simple_instruction": "Could you help me create a Python script that generates a plot for the equation (z - 4) * (z - 6) * (z - 8) + 90? The plot should range from 0 to 11 on the x-axis, with a shaded region between 3 and 10. The y-axis should start from 0. The plot line should be blue with a thickness of 2. The shaded region should be a light blue color. The plot should also include a text at the center of the shaded region with the integral formula, labels for the x and y axes, and x-ticks at 3 and 10 with corresponding labels. The y-ticks should be removed and the top and right borders of the subplot should be hidden.",
        "expert_instruction": "Here is the modified instruction:\n\n\"Could you help me create a Python script that does the following?\n\n1. First, we need to bring in some libraries. We'll need one for creating plots, one for numerical operations, and one for creating shapes in our plot.\n\n2. Next, let's define a function. Let's call it 'calculation'. This function should take a single input 'z'. The function should return the result of the equation (z - 4) * (z - 6) * (z - 8) + 90.\n\n3. Now, we need to set some limits for an integral. Let's call these 'start' and 'end'. Set 'start' to 3 and 'end' to 10.\n\n4. We need to create a linear space. Let's call it 'z_values'. It should go from 0 to 11. Then, calculate 'result_values' by passing 'z_values' to our 'calculation' function.\n\n5. Now, let's create a subplot and plot 'z_values' and 'result_values' with a line. The line should be blue and have a thickness of 2. Also, set the lower limit of the y-axis to 0.\n\n6. Let's create a shaded region. Generate a linear space between 'start' and 'end'. Calculate the corresponding y-values by passing this linear space to our 'calculation' function. Then, create a list of points by combining the x and y values. Add (start, 0) at the beginning and (end, 0) at the end. Create a shape with these points, give it a light color, and add it to our subplot.\n\n7. Add a text at the center of the shaded region with the integral formula.\n\n8. Add labels to the figure. The x-label should be at position (0.9, 0.05) and the y-label at position (0.1, 0.9).\n\n9. Hide the top and right borders of the subplot.\n\n10. Set the x-ticks to 'start' and 'end' and label them accordingly. Also, remove the y-ticks.\n\n11. Finally, display the plot.\"",
        "id": 15
    },
    {
        "simple_instruction": "Generate a 3D plot of a parametric curve using Python. The curve should be defined by three arrays: 'alpha', 'w', and 'p'. 'alpha' should range from -6\u03c0 to 6\u03c0, 'w' should range from -3 to 3, and 'p' should be the cube of 'w' plus 2. The curve should be plotted in terms of 'a', 'b', and 'w', where 'a' is the product of 'p' and the sine of 'alpha', and 'b' is the product of 'p' and the cosine of 'alpha'. The plot should be labeled as 'parametric curve' and include a legend.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Bring in a library in Python that is commonly used for creating static, animated, and interactive visualizations and another one that is used for working with arrays. Use 'plt' and 'np' as their respective aliases.\n2. Generate a new instance of a figure and add a 3D subplot to it. Assign this subplot to a variable named 'ax'.\n3. Create three arrays named 'alpha', 'w', and 'p'. 'alpha' should be an array with evenly spaced numbers over a specified range from -6\u03c0 to 6\u03c0 with 150 points. 'w' should be an array with evenly spaced numbers over a specified range from -3 to 3 with 150 points. 'p' should be an array where each element is the cube of the corresponding 'w' element plus 2.\n4. Compute 'a' and 'b' arrays using the 'p' and 'alpha' arrays. Each 'a' element should be the product of the corresponding 'p' element and the sine of the corresponding 'alpha' element. Each 'b' element should be the product of the corresponding 'p' element and the cosine of the corresponding 'alpha' element.\n5. Draw 'a', 'b', and 'w' on the 3D subplot using the plot method of 'ax'. Label the plot as 'parametric curve'.\n6. Incorporate a legend to the plot using the legend method of 'ax'.\n7. Render the plot using the show method from the 'plt' module.",
        "id": 23
    },
    {
        "simple_instruction": "\"Generate a 3D stem plot using Python. The plot should be based on an array of evenly spaced numbers from 0 to 4 times the mathematical constant pi. Create two sets of data based on the sine and cosine of these values, each subtracted by pi divided by 4. Use these two sets of data along with the original array to create the stem plot. The plot should be a discrete series plot, useful for plotting non-continuous or discrete data points.\"",
        "expert_instruction": "As an expert in LLMs and prompt engineering, I would like you to assist me in generating a code that accomplishes the following tasks:\n\n1. Start by importing two necessary libraries. One is widely used for creating static, animated, and interactive visualizations in Python. The other one is a library used for working with arrays in Python.\n\n2. Next, create a variable, let's call it 'alpha'. This variable should hold an array of evenly spaced numbers over a specified range. This time, let's make the range from 0 to 4 times the mathematical constant that represents the ratio of the circumference of a circle to its diameter.\n\n3. Now, create two more variables, let's name them 'p' and 'q'. Assign to 'p' the sine of the 'alpha' values subtracted by the mathematical constant divided by 4. Similarly, assign to 'q' the cosine of the 'alpha' values subtracted by the mathematical constant divided by 4.\n\n4. Create another variable, let's call it 'r'. This variable should hold the 'alpha' values.\n\n5. Now, let's create a 3D subplot. Use the function from the visualization library that creates a figure and a set of subplots. This function should take a dictionary as an argument, specifying a 'projection' of '3d'.\n\n6. On the created subplot, create a stem plot using 'p', 'q', and 'r'. The stem plot is a discrete series plot, which is useful for plotting non-continuous or discrete data points.\n\n7. Finally, display the plot using the function from the visualization library that shows the figure.\n\nRemember, the goal here is to change how the data points are produced while keeping the plot type the same. All other aspects of the plot should remain unchanged.",
        "id": 27
    },
    {
        "simple_instruction": "Generate a Python script that creates a 3D plot using a range of numbers from -10 to 10 with a step of 0.5 for both the horizontal and vertical axes. The third dimension should be calculated as the cosine of the square root of the sum of squares of the horizontal and vertical grid values. The plot should use the 'coolwarm' color map, have a line width of 0, and disable antialiasing. The third dimension axis should have limits of -1.01 and 1.01, with 10 ticks and numbers formatted to 2 decimal places. A color bar should be added to the figure with a shrink parameter of 0.5 and an aspect parameter of 5.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries that will allow for data manipulation, plotting, and customization of plots.\n\n2. Set up a 3D subplot using a function from the plotting library, ensuring the projection parameter is set to \"3d\".\n\n3. Generate a range of numbers from -10 to 10 with a step of 0.5 for both the horizontal and vertical axes using a function from the data manipulation library. Then, create a 2D grid of these numbers using a function from the same library.\n\n4. Calculate the square root of the sum of squares of the horizontal and vertical grid values for each point in the grid. Then, compute the cosine of these values to create the third dimension values.\n\n5. Plot the surface using a function from the plotting library with the horizontal, vertical, and third dimension values as inputs. Set the color map to 'coolwarm', line width to 0, and disable antialiasing.\n\n6. Set the limits of the third dimension axis to -1.01 and 1.01 using a function from the plotting library. Then, set the major locator of the third dimension axis to a locator with 10 ticks using a function from the plotting library. Also, set the major formatter of the third dimension axis to format the numbers to 2 decimal places.\n\n7. Add a color bar to the figure that maps the values to colors using a function from the plotting library. Set the shrink parameter to 0.5 and the aspect parameter to 5.\n\n8. Finally, display the plot using a function from the plotting library.",
        "id": 28
    },
    {
        "simple_instruction": "Write a Python script to create a filled 3D tricontour plot with these characteristics:\n- Set the range of radii from a minimum value up to 1.2, and ensure the points span a full circle.\n- Apply the CMRmap colormap to the plot.\n- Adjust the plot's viewing angle to enhance the visual representation of the data.",
        "expert_instruction": "Generate a Python script that performs the following tasks:\n\n1. Bring in the necessary libraries that will allow for data manipulation, plotting, and mathematical operations.\n2. Establish variables for the quantity of points, number of circles, and the smallest circle radius.\n3. Construct a mesh in polar coordinates and compute x, y, z. The radii should be a linear space from the smallest circle radius to 1.2, and the points should be a linear space from 0 to 2*pi. The points should be repeated for each radius, and every third point should be incremented by pi divided by the number of points.\n4. Transform the polar coordinates to Cartesian coordinates by multiplying the radii by the cosine and sine of the points, respectively. The z values should be the sine of the radii times the sine of two times the points.\n5. Create a custom triangulation using the x and y values.\n6. Exclude unwanted triangles by setting a mask on the triangulation. The mask should be a boolean array where each value indicates whether the mean hypotenuse of the x and y values of the triangles is less than the smallest circle radius.\n7. Add a subplot to a new figure with a 3D projection.\n8. Plot a tricontour plot on the subplot using the triangulation and z values, with a colormap of CMRmap.\n9. Adjust the view angle of the subplot to 50 degrees elevation for better understanding of the plot.\n10. Display the plot.",
        "id": 29
    },
    {
        "simple_instruction": "Generate a Python code that creates a 3D plot of a 10x10x10 grid with three cuboids and two link cuboids between them. The cuboids should be 3D volumetric objects plotted with voxels. The three cuboids should have a side length of 3. The first cuboid should be located in the bottom left corner, the second in the center, and the third in the top right corner. The link should be defined as all points where the sum of the absolute differences between x, y, and z is less than or equal to 3. Each object should have a distinct color: 'yellow' for the first cuboid, 'blue' for the second, 'green' for the third, and 'purple' for the link. The plot should have black edge colors.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries that will allow you to create plots and handle numerical operations.\n2. Generate coordinates for a 10x10x10 grid using a function from the numerical library that can create an evenly spaced grid of indices.\n3. Create three cuboids within this grid. The first cuboid should be located in the top left corner and defined by all points where x, y, and z are less than 4. The second cuboid should be in the center of the grid, defined by all points where x, y, and z are between 4 and 6. The third cuboid should be in the bottom right corner, defined by all points where x, y, and z are greater than or equal to 6.\n4. Define a link between the three cuboids. This link should be defined as all points where the sum of the absolute differences between x, y, and z is less than or equal to 3.\n5. Combine these four objects into a single boolean array using a logical operator that returns True if either of the conditions is met.\n6. Assign colors to each object by creating an empty array of the same shape as the boolean array. Assign the color 'purple' to the link, 'yellow' to the first cuboid, 'blue' to the second cuboid, and 'green' to the third cuboid.\n7. Plot everything using a function from the plotting library that allows 3D projection. Use a function that can plot the boolean array, with the facecolors set to the colors array and the edgecolor set to black.\n8. Lastly, display the plot using a function from the plotting library that shows the final figure.",
        "id": 31
    },
    {
        "simple_instruction": "Create a Python script to produce a 3D voxel plot with the following details:\n\nThe plot should feature a cube centered at the coordinates [0.5, 0.5, 0.5] with a side length of 0.5.\nConstruct a boolean array to represent the presence of the cube in the 3D space.\nGenerate three normalized 3D arrays of size (20, 20, 20) to represent the RGB color channels.\nUse the midpoint values of these arrays to color the voxels inside the cube.\nThe voxel edge colors should be a brighter variant of their face colors.\nLabel the axes with corresponding names to the three RGB arrays.\nEnsure the aspect ratio of the plot is equal.",
        "expert_instruction": "Instruct the LLM to generate a Python script that does the following:\n\n1. Import the necessary libraries for plotting and numerical computations.\n2. Define a function that takes a single argument, a multi-dimensional array. This function should calculate the midpoints of the array by iterating over its dimensions and averaging adjacent elements. The result should be returned.\n3. Create three multi-dimensional arrays with dimensions (20, 20, 20), and normalize their values by dividing them by 19.0.\n4. Use the previously defined function to calculate the midpoints of these three arrays and assign the results to three new variables.\n5. Define a cube in 3D space centered at [0.5, 0.5, 0.5] with a side length of 0.5. The cube should be represented as a boolean array where True values indicate points inside the cube.\n6. Create a 4D array with the same shape as the cube and an additional last dimension of size 3. Assign the three midpoint arrays to the red, green, and blue channels of this 4D array respectively.\n7. Create a 3D plot using a function that can plot voxels. The voxel grid should be defined by the three original arrays, and the voxels inside the cube should be colored according to the 4D array. The edge colors of the voxels should be a brighter version of the face colors, and the linewidth should be set to a small value.\n8. Label the x, y, and z axes with the names of the three original arrays respectively, and set the aspect ratio of the plot to 'equal'.\n9. Finally, display the plot.",
        "id": 32
    },
    {
        "simple_instruction": "Create a script in Python that:\n\n- Produces a 3D plot displaying a donut shape.\n- Uses three 3D grids to define the geometry: one grid ranging from 0 to 2, another from 0 to 2*pi, and the third from -1 to 1.\n- Generates a 4D array to derive RGB colors for the donut.\n- Applies the RGB colors to the faces of the donut and uses a brighter version for the edges.\n\nThe output should be a visually appealing 3D donut plot with the specified color attributes.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries that are used for data manipulation, mathematical operations, and data visualization.\n\n2. Define a function that takes a multi-dimensional array as input and calculates the midpoints of the array. This function should iterate over the dimensions of the array and for each dimension, calculate the average of the current and next element, then return the updated array.\n\n3. Generate three 3D grids. The first grid should range from 0 to 2 with 15 points, the second grid should range from 0 to 2*pi with 30 points, and the third grid should range from -1 to 1 with 15 points.\n\n4. Calculate two new arrays by multiplying the first grid with the cosine and sine of the second grid respectively.\n\n5. Calculate the midpoints of the three grids using the function defined in step 2 and assign the results to three new variables respectively.\n\n6. Define a 3D boolean array that represents a donut shape in the 3D grid.\n\n7. Create a 4D array with the same shape as the boolean array and an additional dimension of size 3. Assign the normalized second grid to the first color component, the first grid to the second, and the third grid offset by 0.5 to the third.\n\n8. Convert the 4D array colors to RGB format using a function from the imported libraries and assign the result to a new variable.\n\n9. Create a 3D plot by adding a subplot to a new figure. Use a function to plot the boolean array in 3D space, using the RGB colors for the facecolors and a brighter version of the RGB colors for the edgecolors. Set the linewidth to 0.5.\n\n10. Finally, display the plot using a function from the imported libraries.",
        "id": 33
    },
    {
        "simple_instruction": "Generate a Python script that plots a straight line y=x with longitude values ranging from -180 to 180 using the Mercator projection for scaling latitudes. The x-axis should be labeled 'Longitude' and the y-axis should be labeled 'Latitude'. The title of the plot should be 'Mercator projection'. The plot should also include a grid for better visualization.",
        "expert_instruction": "1. Import the necessary libraries. You'll need a library for numerical operations, a library for plotting, and some specific modules from the plotting library for scaling and transforming data.\n\n2. Create a class named `MercatorLatitudeScale` that inherits from the base scale class in the plotting library. This class will be used to scale data in the range -pi to pi (-180 to 180 degrees) using the system used to scale latitudes in a Mercator projection.\n\n3. In the `MercatorLatitudeScale` class, define an initialization method that accepts an `axis` and a `thresh` parameter. The `thresh` parameter should default to the radian equivalent of 180 degrees.\n\n4. Within the `MercatorLatitudeScale` class, define a method that returns an instance of a nested class `MercatorLatitudeTransform`.\n\n5. Define a method in the `MercatorLatitudeScale` class that sets up the locators and formatters to use with the scale.\n\n6. Define a method in the `MercatorLatitudeScale` class that limits the bounds of the axis to the domain of the transform.\n\n7. Define two nested classes within the `MercatorLatitudeScale` class: `MercatorLatitudeTransform` and `InvertedMercatorLatitudeTransform`. Both of these classes should inherit from the transform class in the plotting library.\n\n8. Register the `MercatorLatitudeScale` class using the register function in the scale module of the plotting library.\n\n9. In the main section of the script, create an array `t` with values ranging from -180.0 to 180.0 with a step of 0.1. Create another array `s` which is equal to `t`.\n\n10. Plot `t` against `s` using the plotting function in the plotting library. Set the y-scale to 'mercator' using the yscale function in the plotting library.\n\n11. Label the x-axis as 'Longitude', the y-axis as 'Latitude', and the title as 'Mercator projection'. Enable the grid and display the plot.",
        "id": 34
    },
    {
        "simple_instruction": "Generate a Python script that visualizes four different mathematical functions using a 2x2 grid of subplots. The first subplot should show the exponential decay of a range of data with a decay factor of 7.0, the second subplot should display the cosine of the data multiplied by 3\u03c0, the third subplot should plot 25 times the exponential decay of the data with a decay factor of 15.0 with a base 3 logarithmic scale on the x-axis, and the fourth subplot should plot cubed data generated by raising 15 to the power of a linearly spaced array, with error bars. The range of data for the first three subplots should be evenly spaced from 0.02 to 25.0 with a step of 0.02. The y-axis of the first subplot, the x-axis of the second subplot, and both axes of the third and fourth subplots should be on a logarithmic scale. The fourth subplot should have error bars, with the x error being 15% of x and the y error being 7.0 plus 80% of y, and its y-axis should have a lower limit of 0.15. The figure should be neatly laid out and displayed.",
        "expert_instruction": "Instruct the language model to generate a Python script that does the following:\n\n1. Import the necessary libraries for data visualization and numerical computations.\n2. Generate a range of data for plotting using a function that creates evenly spaced values within a given interval. Start from 0.02 up to 25.0 with a step of 0.02.\n3. Create a figure with 4 subplots arranged in a 2x2 grid.\n4. For the first subplot, plot the exponential decay of the data with a decay factor of 7.0 using a logarithmic scale on the y-axis. Title this subplot 'semilogy' and add a grid.\n5. For the second subplot, plot the cosine of the data multiplied by 3\u03c0 using a logarithmic scale on the x-axis. Title this subplot 'semilogx' and add a grid.\n6. For the third subplot, plot 25 times the exponential decay of the data with a decay factor of 15.0 using a logarithmic scale on both the x and y axes. Set the base of the x-axis logarithmic scale to 3. Title this subplot 'loglog base 3 on x' and add a grid.\n7. For the fourth subplot, generate new data by raising 15 to the power of a linearly spaced array from 0.0 to 3.0 with 25 points, and cube this data. Plot this data with error bars, setting the x error to 15% of x and the y error to 7.0 plus 80% of y. Use a logarithmic scale on both the x and y axes, clipping non-positive values. Title this subplot 'Errorbars go negative'. Set the lower limit of the y-axis to 0.15 after plotting the error bars to allow the error bars to autoscale the limits.\n8. Adjust the layout of the figure to fit the subplots neatly.\n9. Finally, display the figure using the function that shows the plot.",
        "id": 35
    },
    {
        "simple_instruction": "Create a Python script to generate a Sankey diagram titled \"Flow Diagram of a Gadget.\" The diagram should visually represent the operation of a gadget through several phases with the following specifications:\n\nThe diagram must have sequential phases labeled 'Phase 1', 'Phase 2', 'Phase 3', 'Phase 4', 'Phase 5', and 'Hurray!'.\nEach phase should have flow values indicating the transition magnitude between phases. For instance, the flow could be represented by hypothetical values like 100%, 20%, 20%, 20%, 20%, and 10% for each respective phase, showing a decrease in magnitude as the gadget progresses through each phase.\nThe orientation and path lengths of the flows should accurately represent the transition from one phase to the next.\nThe final phase, 'Success!', must be distinctively highlighted with a blue color and bold font.\nThis script should result in a clear Sankey diagram that effectively illustrates the different operational phases of the gadget and culminates in the 'Hurray!' phase",
        "expert_instruction": "\nTo create a Python code snippet using Matplotlib for generating a flow diagram of a gadget with specific features, follow these instructions:\n\nImport Required Libraries: Start by importing matplotlib.pyplot and the Sankey class from matplotlib.sankey.\n\nCreate a Figure and Axis: Initialize a Matplotlib figure and add an axis to it. Ensure that the axis has no x or y ticks and assign a title like \"Flow Diagram of a Gadget\".\n\nInitialize Sankey Diagram: Create a Sankey diagram instance. Set the following parameters: scale to a small value like 0.01, offset to 0.2, head_angle to a high value such as 120, and specify a format for numbers and a unit.\n\nAdd Flows and Labels: Add flows to the Sankey diagram. The flows should sum to zero and can include both positive and negative values, such as [100, -20, -20, -20, -20, -10]. Corresponding labels for each flow, like 'Phase 1', 'Phase 2', etc., should also be added. Set orientations for the flows and path lengths.\n\nCustomize Patch Label: Assign a patch label with a text like \"Widget A\" and customize it if needed.\n\nFinalize and Customize Diagram: Call the finish() method on the Sankey object. Customize the last text element of the first diagram to change its color to blue and make it bold. Also, make the main text of the diagram bold.\n\nDisplay the Diagram: Finally, use plt.show() to display the created Sankey diagram.",
        "id": 41
    },
    {
        "simple_instruction": "Create a Python script to generate a Sankey diagram that produces a long chain of connections with the following requirements:\n\nThe script should use a suitable library for creating visualizations.\nImplement a function named 'branch' that creates a side chain on the diagram. This function should:\nProduce side chains with alternating orientations and patch labels.\nImplement another function named 'turn' to generate a corner link in the diagram. This function should specify:\nOrientations, patch label, face color, previous value, connection, and alpha value for the corner link.\nThe diagram should have 8 chains on each side, created using the 'branch' function.\nThe overall plot should have the title \"This might seem unnecessary, but it's possible!\".\nThe initial flow in the flowchart should be set up with orientations [0, 1], patch label '0', face color red, and rotation 60 degrees.\nUse the 'branch' and 'turn' functions in a specified sequence to construct the final flowchart diagram.\nDisplay the completed Sankey diagram as the output.\nThis script should result in a detailed and structured Sankey diagram showcasing the intricate flow and connections as specified.",
        "expert_instruction": "Create a Python script that starts by importing a library that is commonly used for creating static, animated, and interactive visualizations in Python and a module from this library that is used for creating Sankey diagrams. Define a variable named 'chains_per_side' and set it to 4.\n\nCreate a function named 'branch' that takes two parameters: 'flowchart' and 'm' with a default value of 2. This function should generate a side chain. Inside this function, define a variable 'previous' that is equal to the number of diagrams in 'flowchart'. Then, create a loop that iterates over a range from 0 to 2*m with a step of 2. In each iteration, add a flow to the flowchart diagram with orientations [-1, -1], a patch label equal to the string representation of 'previous + i', a previous value of 'previous + i - 1', a connection of (1, 0), and an alpha value of 0.5. Repeat this process but with orientations [1, 1] and a patch label of 'previous + i + 1'.\n\nNext, create another function named 'turn' that takes 'flowchart' as a parameter. This function should generate a corner link. Inside this function, define 'previous' as before and add a flow to the flowchart diagram with orientations [0, 1], a patch label equal to the string representation of 'previous', a face color of 'k', a previous value of 'previous - 1', a connection of (1, 0), and an alpha value of 0.5.\n\nAfter defining these functions, create a figure and add a subplot to it with no xticks or yticks and a title of \"This might seem unnecessary, but it's possible!\". Create a flowchart diagram on this subplot with no unit. Add a flow to this diagram with orientations [0, 1], a patch label of \"0\", a face color of 'r', and a rotation of 60 degrees.\n\nThen, call the 'branch' function with 'flowchart' and 'chains_per_side' as arguments, followed by the 'turn' function with 'flowchart' as the argument. Repeat this process three more times. Finally, finish the flowchart diagram and display the plot.",
        "id": 42
    },
    {
        "simple_instruction": "Create a Python code that generates a matplotlib plot with four subplots arranged in a 2x2 mosaic. The plot should be based on a numpy array of 200 points between 0 and 4\u03c0, and its cosine multiplied by 3. The subplots should be titled 'center', 'zero', 'axes', and 'data', and the overall title of the figure should be 'Spine positions'. \n\nIn the 'center' subplot, the left and bottom spines should be positioned at the center, with the top and right spines invisible. In the 'zero' subplot, the left and bottom spines should be positioned at zero, with the top and right spines invisible. In the 'axes' subplot, the left spine should be positioned at 0.3 on the axes and the bottom spine at 0.3 on the axes, with the top and right spines invisible. In the 'data' subplot, the left spine should be positioned at 2 on the data and the bottom spine at 2 on the data, with the top and right spines invisible.",
        "expert_instruction": "Create a Python code that generates a matplotlib plot with the following characteristics:\n\n1. Start by defining a variable, let's call it `a`, which should be a numpy array of 200 points between 0 and 4\u03c0.\n2. Next, define another variable, `b`, which is the cosine of `a` multiplied by 3.\n\n3. Now, we need to create a 2x2 subplot mosaic. The keys for these subplots should be 'center', 'zero', 'axes', and 'data'. The overall title of the figure should be 'Spine positions'.\n\n4. For the 'center' subplot:\n   - Give it the title 'center'.\n   - Plot `b` against `a`.\n   - Position the left and bottom spines at the center.\n   - The top and right spines should be invisible.\n\n5. For the 'zero' subplot:\n   - Give it the title 'zero'.\n   - Plot `b` against `a`.\n   - Position the left and bottom spines at zero.\n   - The top and right spines should be invisible.\n\n6. For the 'axes' subplot:\n   - Give it the title 'axes' (0.3, 0.3).\n   - Plot `b` against `a`.\n   - Position the left spine at 0.3 on the axes.\n   - Position the bottom spine at 0.3 on the axes.\n   - The top and right spines should be invisible.\n\n7. For the 'data' subplot:\n   - Give it the title 'data' (2, 3).\n   - Plot `b` against `a`.\n   - Position the left spine at 2 on the data.\n   - Position the bottom spine at 3 on the data.\n   - The top and right spines should be invisible.\n\n8. Lastly, display the plot.",
        "id": 43
    },
    {
        "simple_instruction": "Generate a Python plot using a suitable library that includes three lines representing \"Pressure\", \"Humidity\", and \"Wind Speed\" over time. The \"Pressure\" line should be plotted with the points (0,0), (1,2), and (2,4), the \"Humidity\" line with the points (0,0), (1,4), and (2,3), and the \"Wind Speed\" line with the points (0,70), (1,40), and (2,20). Each line should be plotted on three separate y-axis with a shared x-axis representing \"Time\". The y-axis for \"Pressure\" should be limited to (0,4), for \"Humidity\" to (0,5), and for \"Wind Speed\" to (1,90). The colors of the y-axis labels and ticks should match the color of the corresponding line plots, which are blue, yellow and green. Include a legend for the three line plots and display the plot.",
        "expert_instruction": "1. Import a library in Python that is commonly used for creating static, animated, and interactive visualizations in Python.\n2. Generate a figure and a single subplot, assigning them to two variables. Adjust the right margin of the subplot to 0.75 using an appropriate method.\n3. Create two additional y-axes on the same x-axis by calling a suitable method on the variable that holds the subplot and assign them to two new variables.\n4. Adjust the position of the right spine of the second y-axis to 1.2 axes units to the right.\n5. Plot three lines on the three y-axes. The first line should be plotted on the first y-axis with the points (0,0), (1,2), and (2,4) and labeled as \"Pressure\" with color blue. The second line should be plotted on the second y-axis with the points (0,0), (1,4), and (2,3) and labeled as \"Humidity\" with color yellow. The third line should be plotted on the third y-axis with the points (0,70), (1,40), and (2,20) and labeled as \"Wind Speed\" with color green.\n6. Set the x-axis limit to (0,2) and the y-axis limit to (0,4) for the first y-axis. Label the x-axis as \"Time\" and the y-axis as \"Pressure\". For the second y-axis, set the y-axis limit to (0,5) and label it as \"Humidity\". For the third y-axis, set the y-axis limit to (1,90) and label it as \"Wind Speed\".\n7. Adjust the color of the y-axis labels to match the color of the corresponding line plots.\n8. Adjust the color of the y-axis ticks to match the color of the corresponding line plots.\n9. Add a legend to the subplot that includes the three line plots.\n10. Display the plot using an appropriate method.",
        "id": 44
    },
    {
        "simple_instruction": "Generate a Python code that creates a subplot figure with six different streamplots. The first streamplot should have varying density along a streamline, the second should have varying color along a streamline using the 'summer' colormap, the third should have varying line width along a streamline, the fourth should control the starting points of the streamlines and display these points with blue symbols, the fifth should have a mask and display the mask using imshow, and the last should have unbroken streamlines. The figure should be 8x10 with 3 rows and 2 columns, and the height ratios should be 1, 1, and 2. The streamplots should be based on a meshgrid with a range from -4 to 4 with 150 complex numbers, and the velocity should be calculated as the square root of the sum of squares of two given mathematical expressions:\nU = -1 - X**2 + Y\nV = 1 + X - Y**2.",
        "expert_instruction": "Instruct the LLM to generate a Python code that begins by importing necessary libraries for plotting and numerical computations. Define a variable 'z' as 4 and create a meshgrid 'P' and 'Q' using a numerical computation library with a range from negative 'z' to 'z' with 150 complex numbers. Define 'A' and 'B' as given mathematical expressions and calculate the velocity as the square root of the sum of squares of 'A' and 'B'.\n\nNext, create a subplot figure with 3 rows and 2 columns, with a size of 8x10 and height ratios of 1, 1, and 2. Flatten the axes for easier manipulation. \n\nOn the first subplot, create a streamplot with varying density along a streamline and set its title as 'Varying Density'. On the second subplot, create a streamplot with varying color along a streamline using the 'summer' colormap and set its title as 'Varying Color'. Add a colorbar to this subplot. \n\nOn the third subplot, create a streamplot with varying line width along a streamline and set its title as 'Varying Line Width'. \n\nOn the fourth subplot, control the starting points of the streamlines and display these points with red symbols. Set its title as 'Controlling Starting Points' and add a colorbar. \n\nOn the fifth subplot, create a streamplot with a mask and display the mask using imshow. Set its title as 'Streamplot with Masking' and set the aspect ratio as 'equal'. \n\nOn the last subplot, create a streamplot with unbroken streamlines and set its title as 'Streamplot with unbroken streamlines'. \n\nFinally, adjust the layout for a tight fit and display the plot.",
        "id": 46
    },
    {
        "simple_instruction": "Create a Python script that generates two types of box plots - a standard box plot and a notched box plot. The plots should be based on four sets of 150 normally distributed random numbers, each with a different standard deviation ranging from 2 to 5. The data sets should be labeled as 'y1', 'y2', 'y3', and 'y4'. \n\nThe plots should be arranged in one row and two columns. The first subplot should be a standard box plot, while the second subplot should be a notched box plot. Both plots should have the boxes vertically aligned, filled with different colors, and labeled according to the data set labels. The titles of the subplots should be 'Standard box plot' and 'Notched box plot' respectively.\n\nThe boxes in both plots should be filled with different colors: orange for 'y1', purple for 'y2', yellow for 'y3', and cyan for 'y4'. Both plots should have horizontal grid lines for better readability. The x-axis should be labeled as 'Four separate samples' and the y-axis as 'Measured values'.",
        "expert_instruction": "Craft a Python script that utilizes the matplotlib and numpy libraries to produce two variations of box plots: a standard box plot and a notched box plot. Start by importing the necessary modules from matplotlib and numpy. Then, generate some random test data by setting a seed for the numpy random number generator and creating four sets of 150 normally distributed random numbers, each with a different standard deviation ranging from 2 to 5. Label these data sets as 'y1', 'y2', 'y3', and 'y4'.\n\nNext, construct a figure with two subplots arranged in one row and two columns, and adjust the figure size to 10 by 5. On the first subplot, construct a standard box plot of the test data. Ensure the boxes are vertically aligned, filled with color, and labeled according to the labels you created earlier. Set the title of this subplot to 'Standard box plot'.\n\nOn the second subplot, construct a notched box plot of the same data, with the same specifications as the first plot, but with the notch shape enabled. Set the title of this subplot to 'Notched box plot'.\n\nThen, fill the boxes in both plots with different colors: orange for 'y1', purple for 'y2', yellow for 'y3', and cyan for 'y4'. Add horizontal grid lines to both plots for better readability. Label the x-axis as 'Four separate samples' and the y-axis as 'Measured values'. Finally, display the plots using the appropriate function.",
        "id": 49
    },
    {
        "simple_instruction": "Generate two polar plots with error bars using a numerical array named 'alpha' that spans from 0 to 4\u03c0 with a step of \u03c0/2. For both plots, use 'alpha' for the x values and the square root of 'alpha' divided by \u03c0, subtracted by 0.2, for the y values. \n\nFor the first plot, set the x error to 0.5, the y error to 0.2, the cap size to 7, the format to \"o\", and the color to \"seagreen\". Title this plot as \"Beautiful polar error bars\".\n\nFor the second plot, set the x error to 0.5, the y error to 20.2, the cap size to 7, the format to \"o\", and the color to \"orangered\". Title this plot as \"Huge radius error bars\". \n\nBoth plots should be 10x10 in size.",
        "expert_instruction": "\"\"\"\nInstruct the LLM to generate a Python script that does the following:\n\n1. Bring in the necessary libraries for plotting and numerical operations.\n2. Construct a numerical array named 'alpha' that spans from 0 to 4\u03c0 with a step of \u03c0/2.\n3. Define a variable 's' as the square root of 'alpha' divided by \u03c0, then subtract 0.2 from the result.\n4. Generate a figure object with a size of 10x10 using the figure function from the plotting library.\n5. Add a subplot to the figure with a polar projection.\n6. Draw an error bar on the polar plot with 'alpha' and 's' as the x and y values respectively. Set the x error to 0.5, the y error to 0.2, the cap size to 7, the format to \"o\", and the color to \"seagreen\".\n7. Assign the title of the plot as \"Beautiful polar error bars\".\n8. Render the plot using the appropriate function.\n9. Create another figure object with the same size of 10x10.\n10. Add another subplot to the figure with a polar projection.\n11. Draw an error bar on the polar plot with 'alpha' and 's' as the x and y values respectively. Set the x error to 0.5, the y error to 20.2, the cap size to 7, the format to \"o\", and the color to \"orangered\".\n12. Assign the title of the plot as \"Huge radius error bars\".\n13. Finally, render the plot using the appropriate function.\n\"\"\"",
        "id": 50
    },
    {
        "simple_instruction": "Create a visual representation of a path using Python. The path should be represented as a series of possibly disconnected, possibly closed, line and curve segments. The path should include the following steps:\n- Start at point (2.5, -1.5)\n- Create a cubic Bezier curve to point (1.2, -0.8)\n- Create another cubic Bezier curve to point (-2.3, 1.8)\n- Create yet another cubic Bezier curve to point (0.5, 2.2)\n- Draw a line to point (1.1, 0.9)\n- Create a cubic Bezier curve to point (2.8, 2.9)\n- Create another cubic Bezier curve to point (3.5, 0.1)\n- Create yet another cubic Bezier curve to point (2.5, -0.3)\n- Close the path at point (2.5, -1.5)\n\nThe path should be filled with blue color with a transparency of 0.5. The vertices of the path should be plotted as yellow dots connected by lines. The plot should have a grid and the aspect ratio should be equal.",
        "expert_instruction": "Create a visual representation of a path using a Python script. You'll need to use a library that's commonly used for creating static, animated, and interactive visualizations in Python.\n\nFirst, you'll need to import a module from this library that provides a MATLAB-like interface which is generally easy to get started with for simple plots. Also, import two modules from the same library which are used for creating shapes and paths respectively.\n\nNow, create a figure and a set of subplots. This will return a figure and axes object(s). \n\nNext, create a variable that will represent a series of possibly disconnected, possibly closed, line and curve segments. \n\nAfter that, define a list of tuples. Each tuple in the list should represent a step in the path to be plotted. The first element of each tuple should be a path command, such as moving to a point, creating a cubic Bezier curve, drawing a line to a point, or closing a polygon. The second element of each tuple should be a pair of coordinates. For instance, you can use the following data:\n- Move to point (2.5, -1.5)\n- Create a cubic Bezier curve to point (1.2, -0.8)\n- Create another cubic Bezier curve to point (-2.3, 1.8)\n- Create yet another cubic Bezier curve to point (0.5, 2.2)\n- Draw a line to point (1.1, 0.9)\n- Create a cubic Bezier curve to point (2.8, 2.9)\n- Create another cubic Bezier curve to point (3.5, 0.1)\n- Create yet another cubic Bezier curve to point (2.5, -0.3)\n- Close the polygon at point (2.5, -1.5)\n\nNow, separate the list of tuples into two separate lists, one for the path commands and one for the coordinates, using a function that makes iterables out of the elements of the tuples.\n\nCreate a path object by passing the coordinates and path commands to the constructor of the path object. \n\nCreate a shape object by passing the path object to the constructor of the shape object. Set the color inside the shape to blue and its transparency to 0.5. \n\nAdd the shape to the axes object using the appropriate method. \n\nPlot the vertices of the path as yellow dots connected by lines by calling the appropriate method on the axes object. \n\nTurn on the grid for the axes object by calling its appropriate method. \n\nSet the aspect of the axes object to equal by calling its appropriate method with the argument 'equal'. \n\nFinally, display the plot by calling the appropriate method from the plotting library.",
        "id": 51
    },
    {
        "simple_instruction": "Generate a plot with six distinct lines using the 'ggplot' style sheet. Each line should be a function of a variable y (ranging from -5 to 5), a cosine function of y, and a random number. The lines should vary based on the following conditions: \n\n1. The sum of the cosine function, y, and the random number.\n2. The sum of the cosine function, one-third of y, and the random number.\n3. The sum of the cosine function, three times y, and the random number.\n4. The sum of the cosine function, negative one-third of y, and the random number.\n5. The sum of the cosine function, negative three times y, and the random number.\n6. The sum of the cosine function and the random number.\n\nEnsure the consistency of the results by setting the random seed to 123456789. Title the plot as \"'ggplot' style sheet\".",
        "expert_instruction": "Commence by incorporating the necessary libraries for data visualization and numerical operations in Python. Choose the plot style to be 'ggplot'. Generate a variable y that is a linear space from -5 to 5. To ensure the consistency of the results, set the random seed to 123456789.\n\nCreate a figure and axes using the function that allows you to create multiple layouts of subplots on a single figure. On these axes, plot six distinct lines. Each line should be a function of y, a cosine function of y, and a random number. \n\nFor the first line, it should be the sum of the cosine function, y, and the random number. The second line should be the sum of the cosine function, one-third of y, and the random number. The third line should be the sum of the cosine function, three times y, and the random number. The fourth line should be the sum of the cosine function, negative one-third of y, and the random number. The fifth line should be the sum of the cosine function, negative three times y, and the random number. The sixth line should be the sum of the cosine function and the random number.\n\nSet the title of the axes to \"'ggplot' style sheet\". Lastly, display the plot using the function that renders all figure windows.",
        "id": 52
    },
    {
        "simple_instruction": "Generate a Python code to plot the hyperbolic tangent function for a numerical array of 200 evenly spaced numbers between -20 and 20. The plot should include horizontal lines at y=0, y=1.0, and y=-1.0, and a solid vertical line at x=0. Additionally, draw a line through the point (0, 0.5) with a slope of 0.5. The function should be labeled and the x-axis should be limited from -20 to 20. Include a legend with a fontsize of 14.",
        "expert_instruction": "Instruct the LLM to generate a Python code that does the following:\n\n1. Import the necessary libraries for plotting graphs and performing numerical operations.\n2. Create a variable 'x' and assign it a numerical array of 200 evenly spaced numbers between -20 and 20.\n3. Create a variable 'func' and assign it the hyperbolic tangent function applied to 'x'.\n4. Draw a horizontal line at y=0 with a dashed black line.\n5. Draw another horizontal line at y=1.0 with a dashed black line.\n6. Draw a third horizontal line at y=-1.0 with a dashed black line.\n7. Draw a vertical line at x=0 with a grey color.\n8. Draw a line starting from the point (0, 0.5) with a slope of 0.5 and a dashed black line.\n9. Plot the 'func' variable against 'x' with a linewidth of 2 and label it as the hyperbolic tangent function.\n10. Set the x-axis limit from -20 to 20.\n11. Label the x-axis as \"x\".\n12. Add a legend with a fontsize of 14.\n13. Finally, display the plot.",
        "id": 54
    },
    {
        "simple_instruction": "Create a Python script to visualize a 3D dataset in a 3D box surface plot where data values are plotted on the volume surfaces:\n\n- The dataset should be derived from a 3D grid with dimensions set to Px=100, Py=300, and Pz=500. Use the formula (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1) to generate the data.\n- The plot should include contour surfaces based on the Px, Py, and Pz parameters.\n- Customize the edges of the contours with specific color '0.4', linewidth of 1, and zorder of 1e3.\n- Label the x, y, and z axes as 'Px [km]', 'Py [km]', and 'Pz [m]' respectively.\n- Set the z-axis ticks to [0, -150, -300, -450].\n- Include a colorbar in the plot with the label 'Parameter [units]'.\n- Adjust the view angle and zoom level of the plot for clear and optimal visualization.\n\nThe script should result in a 3D plot that effectively represents the calculated dataset, with appropriate labels and visual enhancements for easy interpretation.",
        "expert_instruction": "Instruct the language model to generate a Python code that does the following:\n\n1. Import the necessary libraries for data visualization and numerical operations.\n2. Establish dimensions Px, Py, and Pz as 100, 300, and 500 respectively. Construct a 3D grid using a function from the numerical library with these dimensions.\n3. Generate a dataset using the formula (((Px+100)**2 + (Py-20)**2 + 2*Pz)/1000+1).\n4. Define a dictionary 'params' with keys 'vmin', 'vmax', and 'levels'. The values should be the minimum and maximum of the data, and a linearly spaced array from the minimum to the maximum of the data with 12 steps respectively.\n5. Create a 3D plot with a figure size of 6x5 using the visualization library's function to create a figure and add a subplot.\n6. Plot contour surfaces on the 3D plot using a function from the visualization library. Do this three times, each time with different parameters for Px, Py, and Pz.\n7. Set the limits of the plot to be the minimum and maximum of Px, Py, and Pz.\n8. Plot edges on the 3D plot using a function from the visualization library with parameters for color '0.4', linewidth of 1, and zorder of 1e3.\n9. Set the labels for the x, y, and z axes as 'Px [km]', 'Py [km]', and 'Pz [m]' respectively. Also, set the zticks to [0, -150, -300, -450].\n10. Set the view angle and zoom of the plot using functions from the visualization library.\n11. Add a colorbar to the figure with a label 'Parameter [units]'.\n12. Finally, display the figure using a function from the visualization library.",
        "id": 55
    },
    {
        "simple_instruction": "Create a Python script that generates a noisy signal from a logarithmic function, a cosine wave, and a constant. The signal should be plotted against a variable that ranges from 0.0 to 10.0 with an increment of 0.2 using the ^ marker. The plot should have two subplots in one row: one drawing vertical lines at each point of the variable starting from the x axis to the height of the value of the function at said point of the variable and two additional green vertical lines at points 3 and 6 through the whole figure, and the other demonstrating horizontal lines at each point of the variable starting from the y axis to the length of the value with the axes flipped. The plots should be displayed in a figure of size 12 by 6.",
        "expert_instruction": "Create a Python script that begins by importing the necessary libraries for data visualization and numerical computations. Establish a fixed random state to ensure the results can be reproduced, using the seed value 123456.\n\nNext, construct a variable 'x' that ranges from 0.0 to 10.0 with an increment of 0.2. Then, create a signal 'y' that is the sum of a logarithmic function, a cosine wave, and a constant 2.\n\nAfterwards, generate a figure with two subplots arranged in a single row and two columns, with a figure size of 12 by 6. Name the subplots 'subplot1' and 'subplot2'. \n\nOn the 'subplot1', plot the signal against the 'x' variable, using '^' as the marker. Add vertical lines at each 'x' point from 0 to the signal value. Also, add two green vertical lines at 'x' points 3 and 6 that span the height of the plot. Set the x-label to 'x-axis' and the title to 'Vertical lines demonstration'.\n\nOn the 'subplot2', plot the signal against the 'x' variable, using '^' as the marker, but with the axes flipped compared to 'subplot1'. Add horizontal lines at each 'x' point from 0 to the signal value, with a line width of 2. Set the x-label to 'x-axis' and the title to 'Horizontal lines demonstration'.\n\nLastly, display the plot.",
        "id": 56
    },
    {
        "simple_instruction": "Create a contour plot in Python with a size of 6x6. The plot should contain four different contours, one for the objective function and three for the constraints. Generate boundary curves of the constraint functions. Distinguish the valid and invalid sides of the constraint boundaries using TickedStrokes. The objective function is the sum of the squares of two variables, minus thrice each of the variables, plus 3. The constraints are defined by three different formulas. The levels for the objective function should be at 0.02, 0.2, 1, 2, 3, 6, 12, 24 and should be colored black. The levels for the constraints should be at 0 and should be colored 'sandybrown', 'orangered', and 'mediumblue' respectively. The contours should be labeled with a format of \"%2.1f\". The x and y limits of the axes should be set to 0 and 5.",
        "expert_instruction": "Create a Python script that generates a contour plot using necessary libraries. Begin by importing the required libraries and initializing a figure and axes with a size of 6x6. Define two variables, let's call them 'px' and 'py', with values 150 and 155 respectively.\n\nCreate two survey vectors, let's name them 'xvec' and 'yvec', using a function that generates evenly spaced numbers over a specified range, with ranges from 0.002 to 5.0. Then, create two survey matrices, let's call them 'x1' and 'x2', using a function that returns coordinate grids from coordinate vectors with 'xvec' and 'yvec' as inputs. \n\nNext, calculate the values for the plot. Define a variable, let's call it 'obj', as the sum of the squares of 'x1' and 'x2', minus thrice each of 'x1' and 'x2', plus 3. Define three more variables, let's call them 'g1', 'g2', and 'g3', with the formulas -(4*'x1' + 'x2' - 6.5), -('x1' + 3*'x2' - 5.5), and 1.0 + 'x1'**-3 - 'x2' respectively.\n\nCreate a contour plot of 'obj' on the axes with levels at 0.02, 0.2, 1, 2, 3, 6, 12, 24 and black color. Label the contours with a format of \"%2.1f\" and use_clabeltext set to True. \n\nCreate three more contour plots for 'g1', 'g2', and 'g3' with levels at 0 and colors 'sandybrown', 'orangered', and 'mediumblue' respectively. Apply path effects to these contours with angles of 145, 70, and a spacing of 8 respectively.\n\nSet the x and y limits of the axes to 0 and 5. Finally, display the plot.",
        "id": 57
    },
    {
        "simple_instruction": "Create a Python script to generate a 2x2 subplot with the following specifications:\n\nFirst Row:\n\nDisplay horizontal and vertical event plots using a random data array of size 8x70.\nSet specific colors for each plot, adjust line offsets, and define line lengths.\nFor instance, the horizontal plot could use a color like 'navy' with a line offset of 1 and line length of 0.5, while the vertical plot could use 'darkgreen', a line offset of 1, and line length of 0.5.\nSecond Row:\n\nShow horizontal and vertical event plots using random gamma-distributed data with a shape parameter of 5 and size 80x70.\nUse different color, line offset, and line length parameters compared to the first row. For example, the horizontal plot might have 'crimson' color, line offset of 2, and line length of 0.7, and the vertical plot could use 'darkorange', line offset of 2, and line length of 0.7.\nGeneral Settings:\n\nSet the font size to 8.0 for all text in the graphs for clarity.\nUse a fixed seed for the random number generator to ensure consistency in results.",
        "expert_instruction": "1. Start by importing the necessary libraries. You'll need one for plotting graphs and another for numerical operations.\n2. Adjust the font size of the graphing library to 8.0 for better visibility.\n3. To ensure the results are consistent, set a fixed seed for the random number generator. Use the seed value 12345678.\n4. Generate a random data array of size 8x70 using the random number generation method from the numerical library.\n5. Define colors for the first row plots. For instance, the horizontal plot could use a color like 'navy' and the vertical plot could use 'darkgreen'.\n6. Define line offsets and line lengths for the first row plots. For instance, both plots could have a line offset of 1 and line length of 0.5.\n7. Create a subplot with 2 rows and 2 columns using the subplots method from the graphing library.\n8. On the first subplot, create a horizontal event plot using the random data, color, line offset, and line length defined earlier.\n9. On the second subplot, create a vertical event plot using the same data, color, line offset, and line length.\n10. Generate another set of random data using the random gamma method from the numerical library with shape parameter 5 and size 80x70.\n11. Define colors for the second row plots. For instance, the horizontal plot could use a color like 'crimson' and the vertical plot could use 'darkorange'.\n12. Define line offsets and line lengths for the second row plots. For instance, both plots could have a line offset of 2 and line length of 0.7.\n13. On the third subplot, create a horizontal event plot using the new random data and the new parameters.\n14. On the fourth subplot, create a vertical event plot using the new random data and the new parameters.\n15. Finally, display the plot using the show method from the graphing library.",
        "id": 58
    },
    {
        "simple_instruction": "Generate a Python script that creates two 3D plots. The first plot should be a surface plot of a function defined in a parameter space of variables p and q, ranging from 0 to 4\u03c0 and -1 to 1 respectively. The function should map p, q pairs to x, y, z triples using the given formula. The plot should use a colormap that ranges from dark blue to light yellow and the z limit should be set to -2 and 2.\n\nThe second plot should be a surface plot of a function defined in a parameter space of radii and angles, ranging from 0.5 to 1.5 and 0 to 4\u03c0 respectively. The function should map radius, angle pairs to x, y, z points. The plot should use a colormap that ranges from dark red to light blue. Triangles where the square of the mean x and y coordinates is less than the square of the minimum radius should be masked off.",
        "expert_instruction": "Generate a Python script that does the following:\n\n1. Start by importing the necessary libraries. You will need a library for plotting, a library for numerical operations, and a library for triangulation.\n\n2. Create a figure with a specific aspect ratio using the plotting library's function.\n\n3. For the first plot:\n   - Create a mesh in the space of parameterisation variables p and q. Let p range from 0 to 4\u03c0 and q range from -1 to 1. Make sure to flatten the p and q arrays.\n   - Define a mapping that takes a p, q pair and returns an x, y, z triple. Use the formula x = (2 + 0.5 * q * cos(p / 2.0)) * cos(p), y = (2 + 0.5 * q * cos(p / 2.0)) * sin(p), and z = 0.5 * q * sin(p / 2.0).\n   - Triangulate the parameter space to determine the triangles.\n   - Plot the surface, with the triangles in parameter space determining which x, y, z points are connected by an edge. Use a colormap that ranges from dark blue to light yellow and set the z limit to -2 and 2.\n\n4. For the second plot:\n   - Define the parameter spaces for radii and angles. Let the radii range from 0.5 to 1.5 and the angles range from 0 to 4\u03c0.\n   - Map the radius, angle pairs to x, y, z points.\n   - Create the Triangulation with no triangles so a Delaunay triangulation is created.\n   - Mask off unwanted triangles by calculating the mean of x and y coordinates of the triangles and setting a condition that masks off triangles where the square of the mean x and y coordinates is less than the square of the minimum radius.\n   - Plot the surface using the plot_trisurf function with the triangulation and z values, and use a colormap that ranges from dark red to light blue.\n\n5. Finally, display the plot.",
        "id": 60
    },
    {
        "simple_instruction": "Create a stackplot where multiple datasets are shown as vertically stacked areas. Use the following election results data of different party votes to draw this plot: year = [1994, 1998, 2002, 2006, 2010, 2014, 2018, 2022]; gdp_by_sector = {Agriculture: [228, 284, 365, 477, 631, 814, 1044, 1275], Technology: [340, 425, 519, 619, 727, 840, 943, 1006], Manufacturing: [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560], Services: [220, 253, 276, 295, 310, 303, 294, 293], Research & Development: [120, 150, 190, 220, 260, 310, 360, 390]}. Set the alpha of the stackplot to 0.8. Set the legend of the plot to the upper left part. Add a title that says 'Imaginary country election results', set the x-axis label to 'Year' and y-axis label to 'Number of people (millions)'.",
        "expert_instruction": "Create a Python script using Matplotlib to visualize the growth of GDP in different economic sectors of an imaginary country over a range of years from 1994 to 2022. The sectors should include Agriculture, Technology, Manufacturing, Services, and Research & Development. Update the values for the 'Research & Development' sector to make them larger for better visibility in the graph.The data for each sector over the years should be represented in a stacked area plot. Each sector should be distinctly colored and the plot should have a legend indicating each sector. The x-axis should represent the years, and the y-axis should represent the GDP growth in millions. Include labels for both axes and a title for the graph indicating it's about the GDP growth in different economic sectors of an imaginary country.The data for each sector over the specified years should be as follows:Agriculture: [228, 284, 365, 477, 631, 814, 1044, 1275]Technology: [340, 425, 519, 619, 727, 840, 943, 1006]Manufacturing: [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560]Services: [220, 253, 276, 295, 310, 303, 294, 293]Research & Development: [120, 150, 190, 220, 260, 310, 360, 390]Finally, the script should display the plot.",
        "id": 63
    },
    {
        "simple_instruction": "Create a timeline with lines, dates, and text using real Matplotlib release dates.  Here are the versions and release dates: names = ['v2.2.4', 'v3.0.3', 'v3.0.2', 'v3.0.1', 'v3.0.0', 'v2.2.3',             'v2.2.2', 'v2.2.1', 'v2.2.0', 'v2.1.2', 'v2.1.1', 'v2.1.0',             'v2.0.2', 'v2.0.1', 'v2.0.0', 'v1.5.3', 'v1.5.2', 'v1.5.1',             'v1.5.0', 'v1.4.3', 'v1.4.2', 'v1.4.1', 'v1.4.0']    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',             '2014-10-26', '2014-10-18', '2014-08-26']. Create a stem plot titled 'Matplotlib Release Dates', where each version release date is represented by a vertical line perpendicular to the timeline. Adjust the height of these vertical lines to differentiate closely spaced events. Add markers at the base of each line to emphasize the timeline's one-dimensional nature. Annotate each vertical line with the corresponding version number, offsetting the text slightly from the tip of the line for clear visibility.",
        "expert_instruction": "Import necessary modules: Explain that the code should start by importing datetime from the datetime module, matplotlib.pyplot as plt, numpy as np, and matplotlib.dates as mdates. These are essential for handling dates, plotting, and numerical operations.Provide fallback data lists: Mention that in case of any issues such as a missing internet connection, the code should include predefined lists named names and dates. The names list will contain version strings, and the dates list will contain corresponding release dates in the 'YYYY-MM-DD' format.     names = ['v2.2.4', 'v3.0.3', 'v3.0.2', 'v3.0.1', 'v3.0.0', 'v2.2.3',             'v2.2.2', 'v2.2.1', 'v2.2.0', 'v2.1.2', 'v2.1.1', 'v2.1.0',             'v2.0.2', 'v2.0.1', 'v2.0.0', 'v1.5.3', 'v1.5.2', 'v1.5.1',             'v1.5.0', 'v1.4.3', 'v1.4.2', 'v1.4.1', 'v1.4.0']    dates = ['2019-02-26', '2019-02-26', '2018-11-10', '2018-11-10',             '2018-09-18', '2018-08-10', '2018-03-17', '2018-03-16',             '2018-03-06', '2018-01-18', '2017-12-10', '2017-10-07',             '2017-05-10', '2017-05-02', '2017-01-17', '2016-09-09',             '2016-07-03', '2016-01-10', '2015-10-29', '2015-02-16',             '2014-10-26', '2014-10-18', '2014-08-26'].Convert date strings to datetime objects: Instruct that the date strings in the dates list need to be converted into datetime objects using datetime.strptime with the format '%Y-%m-%d'.Create levels for the stem plot: Suggest creating an array of levels for plotting. These levels can be generated using np.tile with a pattern and length that matches the number of dates.Set up the figure and axes: Advise setting up a figure and axes for plotting using plt.subplots. Specify that the figure should have a constrained layout and a title indicating it's about Matplotlib release dates.Plot vertical lines and markers: Request plotting vertical lines (vlines) for each date with corresponding levels, and baseline markers (plot) on these dates.Annotate each line: Instruct to annotate each line with the corresponding name from the names list, adjusting the text alignment and position based on the level.Format the x-axis: Guide to format the x-axis to show dates at 4-month intervals and rotate the labels for better readability.Remove unnecessary elements: Suggest removing the y-axis and unnecessary spines from the plot for a cleaner look.Adjust margins and display the plot: Finally, instruct to adjust the margins and use plt.show() to display the plot.",
        "id": 66
    },
    {
        "simple_instruction": "Create two plots on the same axes with different left and right scales using matplotlib. Plot the data using the following arrays: t = np.arange(0.01, 10.0, 0.01), data1 = np.exp(t), data2 = np.sin(2 * np.pi * t).",
        "expert_instruction": "Write a Python script using Matplotlib to plot two different types of data on the same graph, with a shared x-axis but separate y-axes. The first dataset should be an exponential function, and the second dataset should be a sine function.Start by importing matplotlib.pyplot and numpy.Create a time variable 't' that ranges from 0.01 to 10.0, with increments of 0.01.Generate the first dataset 'data1' as an exponential function of 't'.Generate the second dataset 'data2' as the sine of 't' multiplied by 2\u03c0.Initialize a Matplotlib subplot.Set the x-axis label to 'time (s)'.Plot 'data1' on the primary y-axis (left side) with the label 'exp' and in red color. Ensure the y-axis tick labels are also in red.Create a secondary y-axis that shares the same x-axis with the primary y-axis.Plot 'data2' on this secondary y-axis (right side) with the label 'sin' and in blue color. The y-axis tick labels should be in blue as well.Finally, use 'fig.tight_layout()' to adjust the layout so that the right y-label is not clipped, and display the plot.",
        "id": 69
    },
    {
        "simple_instruction": "Create a broken axis plot with a portion of its y-axis cut out using matplotlib. Use some random data points to plot a scatter plot with ten outlier points on the upper part of the region, which are far away from many other scatter points on the lower part of the region. Use slanted lines to indicate the cut in the y-axis. The slanted lines themselves are markers at those locations, such that the lines keep their angle and position, independent of the axes size or scale",
        "expert_instruction": "Create a Python script using the matplotlib library to generate a broken axis plot. Follow these steps:Generate Random Data Points: Start by creating a set of random data points. These points will be used for the main scatter plot. You can use numpy's random number generation for this.Create Outlier Points: Add ten outlier points to your data set. Ensure these outliers are significantly distant from the main data points, for instance, by multiplying their values to increase the distance.Set Up a Broken Axis: Utilize matplotlib's functionality to create a plot with a broken y-axis. This involves creating two subplots (top and bottom) that share the same x-axis. Adjust the vertical spacing between these subplots to make it look like a single plot with a break in the y-axis.Add Slanted Lines as Markers: At the location of the y-axis break, add slanted lines to visually represent the discontinuity. These lines should be drawn as markers and should maintain their angle and position regardless of the axes' size or scale. Place these lines on both the top and bottom subplots at the edges where the axis breaks.Plot the Scatter Plot: Use the scatter plot function to plot the main data points and the outliers on your broken axis. Ensure the main data points appear on both the top and bottom subplots, while the outliers are only on the bottom subplot.Finalize the Plot: Adjust the plot's spines and ticks to hide the spines between the top and bottom subplots and to ensure tick labels appear correctly.End the script with a command to display the plot.",
        "id": 70
    },
    {
        "simple_instruction": "Create a Python script that generates a horizontal boxplot chart displaying the distribution of dataset measurements across different methods. The dataset should consist of several groups, each corresponding to a unique detection method, such as 'Spectral Analysis', 'Direct Observation', 'Light Curve Analysis', 'Doppler Shift', 'Phase Curve', 'Gravitational Lensing', 'Transit Photometry', 'Eclipse Timing', and 'Direct Imaging'. Each method should have a range of data points representing some hypothetical measurements like 'signal strength', 'light intensity', 'velocity', or any other relevant metric in a scientific context, distributed over varying distances or periods. The measurements should be on a logarithmic scale ranging from 1 to 10,000, and measurements should vary randomly within reasonable ranges for each method. Ensure to include elements such as the median, outliers, and quartiles, similar to the example. Make sure the plot aesthetics, color scheme, and layout are clean and visually engaging.",
        "expert_instruction": "To create a Python script for generating a horizontal boxplot chart that displays the distribution of dataset measurements across different methods, follow these instructions:Import Required Libraries: Use matplotlib.pyplot for plotting and numpy for numerical operations. Import these libraries at the beginning of your script.Prepare the Dataset:Define a list of methods representing different detection techniques like 'Spectral Analysis', 'Direct Observation', 'Light Curve Analysis', etc.Use numpy to generate random data for each method. This can be done using a dictionary comprehension, where keys are the methods and values are arrays of data points. Use np.random.lognormal to create a log-normal distribution of data for each method, with means and sigmas generated randomly within specified ranges.Ensure that the data points are within the range of 1 to 10,000 by using np.clip.Create a Horizontal Boxplot:Set up the figure using plt.figure, specifying the size.Use plt.boxplot to create the boxplot. Set vert=False for a horizontal plot. Use the data.values() for the boxplot data and methods for labels. Enable patch artist for custom box colors, and show elements like fliers, caps, means, and mean lines.Apply a logarithmic scale to the x-axis using plt.xscale('log') and set the limits from 1 to 10,000.Add x-axis label, title, and enable grid for better readability.Use plt.tight_layout() for a clean layout.Display the Plot: Finally, use plt.show() to display the generated boxplot.",
        "id": 72
    },
    {
        "simple_instruction": "Create a polar bar plot visualizing a dataset with 50 items. Each item belongs to one of four groups (A, B, C, D) and has a unique name and value. Data Requirements: The dataset should consist of 50 items named \"item 1\" to \"item 50\". Assign random integer values between 30 and 100 for each item. Group the items into four categories: First 10 as 'A', next 20 as 'B', following 12 as 'C', and last 8 as 'D'. Plot Features: Use a polar coordinate system. Assign different colors to each group. Ensure there's a clear separation between the groups on the plot. Display the name of each item at the end of its corresponding bar. Rotate the names so they align radially, with names on the left half of the plot facing outward and names on the right half facing inward. Remove all axis lines, grid lines, and tick marks for a clean look. Adjust the plot so that group 'A' starts from the top (0 degrees). The center of the plot should be blank, making the polar bar bottoms stem from a invisible circle. Technical Aspects: The plot should be reproducible, so set a fixed seed for random number generation. Use Python libraries like Matplotlib, Pandas, and NumPy. Include comments for clarity and future reference.",
        "expert_instruction": "Initialize the required libraries: Start by importing matplotlib.pyplot, numpy, and pandas. Make sure to alias them as plt, np, and pd respectively.Set up a reproducible random number generator: Utilize numpy's random generator with a fixed seed for reproducibility. For instance, use np.random.default_rng(123).Create a DataFrame: Generate a DataFrame df using pandas with three columns: 'name', 'value', and 'group'. The 'name' column should contain strings like \"item 1\", \"item 2\", ..., \"item 50\". The 'value' column should have random integers between 30 and 100. The 'group' column should consist of a predetermined sequence of group labels (e.g., \"A\" repeated 10 times, \"B\" 20 times, \"C\" 12 times, and \"D\" 8 times).Define a function for label rotation and alignment: Write a function get_label_rotation that takes an angle and an offset, converts the angle from radians to degrees, adjusts for alignment ('right' if the angle is less than or equal to \u03c0, otherwise 'left'), and then returns the rotation and alignment.Create a function to add labels: Write a function add_labels that takes angles, values, labels, an offset, and an axis object. This function should iterate over the given angles, values, and labels to place text labels on a plot with appropriate rotation and alignment, determined by the previously defined get_label_rotation function.Prepare data for the polar plot: Extract 'group', 'value', and 'name' columns from the DataFrame into variables. Set an offset for the polar plot. Calculate the number of angles based on the values and group sizes, adding padding for spacing between groups. Compute the width of each bar.Calculate indexes for the bars: Determine the right indexes to place the bars on the polar plot, considering the group sizes and added padding.Set up the polar plot: Initialize a polar subplot with a specified size. Configure the plot's aesthetics like theta offset, y-axis limits, and removing grids and ticks.Assign colors and plot the bars: Assign different colors for each group and plot the bars on the polar axis using these colors. Make sure to skip some angles to leave space between groups.Add labels to the plot: Use the add_labels function to add labels to each bar on the plot.Display the plot: Finally, use plt.show() to display the polar bar plot.",
        "id": 73
    },
    {
        "id": 76,
        "simple_instruction": "Write a code to load 'data.csv' and visualize the \"Women's millions of dollars\" column with a composite graph: an axis-free box plot above and a histogram below. Label key statistics on the box plot and detail the frequency distribution in the histogram. Highlight quartiles with continuous red dashed lines across both sections, ensuring no breaks.",
        "expert_instruction": "I Have some data of Clothing Stores Retail Sales in U.S.A named 'data.csv'. There are two columns in the CSV file. The first column is \"Woman's millions of dollars\". the second column is \"Men's millions of dollars\". Write a python script to read data from file \"data.csv\" and create a vertical two-part graph with the top part being a box plot and the bottom part a histogram. The data visualized relates to 'Women's millions of dollars' in retail sales. The plot showcase the distribution of women's clothing retail sales in the U.S. The upper section is an axis-free box plot highlighting key statistical values, while the lower section is a histogram detailing the frequency distribution. Red dashed lines indicate the quartiles, seamlessly connecting both plots to emphasize these measures.The box plot should have no visible axes, and it should be narrower in width. Include numerical labels for key statistics such as the minimum, lower quartile, median, upper quartile, and maximum values, placed just above the box plot. The histogram should have visible axes and a smaller bin size for finer details. Add two continuous red dashed lines at the lower and upper quartiles. These lines should extend seamlessly across both the box plot and the histogram, without any gaps. The entire plot should be tightly laid out with no space between the box plot and the histogram so that the line can have no break."
    },
    {
        "id": 78,
        "simple_instruction": "Create a Python script to generate a 3D scatter plot from a CSV file named \"data.csv\" with columns [\"0-60 mph(sec)\", \"Gas Mileage(mpg)\", \"Power(kW)\", \"Weight(kg)\", \"Engine Displacement(cc)\"]. The plot should meet the following specifications:\n- Plot each car as a point in 3D space using its acceleration time, gas mileage, and power as coordinates.\n- Point sizes should increase with the engine displacement, and colors should vary from one end of the spectrum (like purple) for smaller engines to the other end (like yellow) for larger engines.\n- Add flat projections of these points onto the XY, ZX, and YZ planes below and to the sides of the 3D points, colored blue, red, and green, respectively.\n- Include a color bar to indicate the relationship between color and engine displacement.\n- Label each axis to show what it represents and use a 3D perspective for viewing the plot.\n- Ensure the plot has a modern and clean design, with clear, semi-transparent points to avoid visual clutter.",
        "expert_instruction": "I have data of car named \"data.csv\". The column of data is [\"0-60 mph(sec)\",\"Gas Mileage(mpg)\",\"Power(kW)\",\"Weight(kg)\",\"Engine Displacement(cc)\"].\nWrite a python code to draw a plot.\n1. **Type of Plot**: This is a 3D scatter plot.\n\n2. **Axes Description**:\n   - The X-axis represents \"0-60 mph (sec)\".\n   - The Y-axis represents \"Gas Mileage (mpg)\".\n   - The Z-axis represents \"Power (kW)\".\n\n3. **Data Points**:\n   - Each data point in the 3D space represents a car, plotted according to its 0-60 mph time, gas mileage, and power.\n   - The size of each point correlates positively with the engine displacement (cc) of the car. Larger points signify larger engine displacements.\n   - The color of the points also represents engine displacement, using a gradient color scheme (like viridis), where one color end (like purple) indicates smaller displacement, and the other end (like yellow) indicates larger displacement.\n\n4. **Projections**:\n   - There are projections of these data points on three planes: XY, ZX, and YZ.\n   - Each projection uses dots of a single color for all points on that plane.\n   - The XY plane projection is at the bottom (below the main data points), colored blue.\n   - The ZX plane projection is on one side, colored red.\n   - The YZ plane projection is on another side, colored green.\n\n5. **Additional Elements**:\n   - A color bar is present, showing the correlation between color and engine displacement in cc.\n   - The plot has labels for each axis, clearly stating what each axis represents.\n   - The plot uses a 3D perspective, allowing the axes and projections to be viewed at an angle rather than straight on.\n\n6. **Style**:\n   - The plot should have a modern, clean look, with a focus on readability and clarity.\n   - The scatter points are solid and well-defined, with a slightly transparent look to prevent overcrowding visually."
    },
    {
        "id": 79,
        "simple_instruction": "I have data of iris flower named \"data.csv\". Generate a 3D scatter plot from \"data.csv\" using the columns \"Petal Length(cm)\", \"Petal Width(cm)\", \"Sepal Length(cm)\", and \"Species\". Use distinct colors to represent each iris flower species. For each species, include confidence ellipses that encompass 95% of the data points, ensuring these ellipses are aligned with the principal axes of variation in the dataset. The confidence ellipses should be solid, opaque, and color-matched to the scatter points of each species, without any wireframes. Ensure the plot includes labeled axes for 'Petal Length', 'Petal Width', and 'Sepal Length', and add a legend that clearly identifies each species by its corresponding color.",
        "expert_instruction": "I have data of iris flower named \"data.csv\". The column of data is [\"Petal Length(cm)\",\"Petal Width(cm)\",\"Sepal Length(cm)\",\"Sepal Width(cm)\",\"Species\"].\nWrite a python code to draw a plot.\n1. Create a 3D scatter plot with axes representing 'Petal Length', 'Petal Width', and 'Sepal Length'.\n2. Plot data points for each iris flower species using distinct colors.\n3. For each species, calculate the mean of the data points to determine the ellipsoid center.\n4. Compute the covariance matrix for each species to define the ellipsoid shape and orientation.\n5. Scale the ellipsoids to include 95% of the respective data points, ensuring they are aligned with the dataset's principal variation axes.\n6. Draw solid, opaque ellipsoids for each species in matching colors to the scatter points, without wireframes.\n7. Add axis labels for each measurement dimension and a legend that identifies each species by color."
    },
    {
        "id": 80,
        "simple_instruction": "Create a 3D topographic visualization using the elevation data from \"data.csv\". The visualization should be structured in layers with:\n\nA 2D terrain map as the base layer, featuring appropriate terrain colors.\nAbove the base, a 3D representation of the terrain in saddlebrown color.\nHigher than the terrain, a layer of colored contour lines.\nAt the top, a 3D grid overlay.\nEnsure the view angle allows a clear view of all layers, with appropriate z-axis limits to display each layer effectively. Include a color legend for elevation and label the color bar as 'Height (m)'. Also, label the x, y, and z axes for clarity.",
        "expert_instruction": "Create a 3D topographic visualization from \"data.csv\" with elevation data:\n1. Load the elevation data.\n2. Form a coordinate grid based on the dimensions of the data.\n3. Layer the 3D plot with:\n  - A 2D map with terrain colors at z=0.\n  - A 3D terrain in saddlebrown at z=-200.\n  - Colored contour lines at z=800.\n  - A 3D grid at z=750.\n4. Adjust the view angle for optimal visibility.\n5. Set the z-axis limits to ensure all layers are visible.\n6. Include a color legend indicating the height in meters.\n7. Add a color bar as a legend, with the label 'Height (m)'.\n8. Label the x, y, and z axes."
    },
    {
        "id": 84,
        "simple_instruction": "I want to create a phase diagram of water using Python. The data is in a file called 'data.csv'.\n\n- First, you should set up the chart with a horizontal axis for temperature and a vertical axis for pressure. These should be marked in Celsius, Kelvin, Pascals, bars and millibars, with conversions where necessary.\n- Next, you should use the data to draw the lines that separate the solid, liquid, and gas phases of water. Use columns 1 and 2 of data to draw the line that separates the solid, liquid, and gas phases. Use columns 3 and 4 to draw the line that separates the solid and liquid phases.\n- You should also mark two special points: the triple point at 273.16 K and 611.657 Pa, where solid, liquid, and gas coexist, and the critical point at 647.396 K and 22.064 MPa, where there's no difference between liquid and gas.\n- You should draw two vertical red lines to show the freezing and boiling points of water at normal pressure.\n- Make sure to label everything clearly, and color the different regions to show the solid, liquid, and gas phases.\n- Finally, you should add a grid to make the chart easier to read, and ensure the pressure scale is logarithmic, since phase diagrams often cover a wide range of pressures.",
        "expert_instruction": "Write a python script to draw the phase diagram of water with the provided data, named \"data.csv\":\n1. Prepare the Axes:\n- Create a horizontal axis for temperature, marking one scale in Celsius (0\u00b0C to 100\u00b0C) and another in Kelvin (273.15 K to 647.396 K). These scales should be aligned so that each temperature in Celsius matches its corresponding value in Kelvin.\n- Create a vertical axis for pressure, marking one scale in Pascals (from 611.657 Pa to 22.064 MPa, possibly using a logarithmic scale for better visualization) and another in bars and millibars. Align these scales so that, for example, 100 kPa corresponds with 1 bar.\n- Set X1 to x1 - 273.15 to convert Kelvin to Celsius for the top X-axis. Set Y1 to y1/100000 to convert Pascals to bars for the right Y-axis. Adjust the right Y-axis to have a Log10 scale type.\n2. Plot the Phase Boundaries:\n- Utilize columns 1 and 2 from your data to plot the boundary line between the solid, liquid, and gas phases, curving from the triple point to the critical point.\n- Use columns 3 and 4 to plot the boundary between solid and liquid phases, which typically curves less dramatically than the solid-liquid-gas line.\n3. Highlight Special Points:\n- Mark the triple point at 273.16 K and 611.657 Pa, where solid, liquid, and gas coexist.\n- Indicate the critical point at 647.396 K and 22.064 MPa, where the distinction between liquid and gas phases ends.\n4. Insert Red Lines:\n- Draw a vertical red line at 0\u00b0C and 273.15 K to represent the freezing point at 1 atm, intersecting the solid-liquid boundary.\n- Add another vertical red line at 100\u00b0C and 373.15 K for the boiling point at 1 atm, intersecting the liquid-gas boundary.\n5. Label and Color-Code:\n- Clearly label each axis with its respective units.\n- Color the different regions of the diagram to represent the solid (blue), liquid (green), and gas (yellow) phases.\n- Annotate the diagram with the special points and the red lines, including their corresponding temperature and pressure values.\n6. Grid and Scale:\n- It may be helpful to include a grid to accurately read off pressures and temperatures at various points on the diagram.\n- Ensure that the scale is logarithmic for pressure if you are spanning wide ranges, as phase diagrams often do."
    },
    {
        "id": 87,
        "simple_instruction": "Utilize the following data columns from 'data.csv' to create a sunburst plot:\n- 'country': for the names of the countries,\n- 'continent': to indicate which continent each country is in,\n- 'lifeExp': showing the expected lifespan in each country,\n- 'pop': representing the population of each country.\nYour chart should:\n- Organize the data hierarchically, starting with continents and then breaking down into countries.\n- Use the population of each country to determine the size of its segment in the chart.\n- Color code each segment by the country's expected lifespan, transitioning from red to blue across the range of values.\n- Set the central value of the color scale to the average lifespan, weighted by the population of the countries.\n- Finally, include a legend to help interpret the lifespan values as indicated by the color coding.",
        "expert_instruction": "Use data.csv to plot a sunburst chart.\n- The hierarchy is defined by the 'continent' and 'country' columns.\n- The size of each segment is determined by the 'pop' column (population).\n- The color of each segment is determined by the 'lifeExp' column (life expectancy).\n- The color scale is a diverging scale that goes from red to blue ('RdBu').\n- The midpoint of the color scale is the weighted average of the 'lifeExp' values, with the weights being the 'pop' values.\n- Add A color bar as a legend for the 'lifeExp' column."
    },
    {
        "id": 88,
        "simple_instruction": "The task is to write a Python code that uses a CSV file named 'data.csv'. Load a CSV file 'data.csv' with columns 'Major Area', 'Regions', 'Country', and 'Overall score'. Treat 'NA' in 'Regions' as a string, not a missing value. Then, using this DataFrame, create a sunburst chart.The center of the circle should be hollow. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. The legend on the chart indicates the color coding for different regions: Europe (dark green), Asia (yellow), Americas (blue), Oceania (purple), and Africa (green), which correspond to the sections of the sunburst chart. The center of the circle should be hollow. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'. \nFinally, the chart should be saved as an image file with dimensions of 1000x1000 pixels.",
        "expert_instruction": "My dataset is a CSV file named 'data.csv' containing the following columns:\n- Major Area: A string column representing the highest level of the hierarchy, such as continents or geopolitical regions.\n- Regions: A string column representing subdivisions within the Major Area. If a particular area does not fall into a region, it should be marked as 'NA', which will be treated as a regular string, not as a missing value.\n- Country: A string column with the name or code for each country, nested within Regions.\n- Overall score: A numeric column representing some quantifiable score attributed to each country.\nWrite a python code to plot a sunburst chart. Ensure that 'NA' values are treated as regular strings and not as missing values. Then, using this DataFrame, create a sunburst chart.The center of the circle should be hollow. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. The legend on the chart indicates the color coding for different regions: Europe (dark green), Asia (yellow), Americas (blue), Oceania (purple), and Africa (green), which correspond to the sections of the sunburst chart. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'.\nOnce the chart is created, save it as an image file with dimensions of 1000x1000 pixels."
    },
    {
        "id": 89,
        "simple_instruction": "I have a CSV file named 'data.csv' containing columns for \"Browser\", \"Version\", and \"Data\". I wish to create a chart with two concentric rings: the inner ring to display browser names, and the outer ring to show the various versions of these browsers. Each version in the outer ring should be clearly labeled with lines pointing to the segments. Visible gaps between both rings and within the segments will enhance readability. The browser names will be written directly on the segments of the inner ring. The center of the chart will be hollow, creating a donut-like appearance. The chart should be titled 'Browser Market Share'.",
        "expert_instruction": "I have a dataset named \"data.csv\" containing browser market share information in a CSV format with the following columns:\n- Browser: The name of the web browser.\n- Version: The specific version number of the browser.\n- Data: The market share percentage associated with each browser version.\nI want to create a two-layered sunburst chart to visualize this data. The chart should be designed as follows:\n- The inner layer should represent different browsers, with the browser names (Browser column) written on the segments.\n- The outer layer should depict the versions of these browsers (Version column), with labels and lines pointing to the specific data points on the chart's edge.\n- There should be white gaps between the layers and also between the segments within each layer for visual separation.\n- The center of the chart should be hollow, creating a donut-like appearance.\nPlease generate the sunburst chart using Python, ensuring that the 'Browser' and 'Version' columns are used for the hierarchical structure, and the 'Data' column is used to determine the size of each segment. The chart should be titled 'Browser Market Share'."
    },
    {
        "id": 90,
        "simple_instruction": "The task is to write a Python code that uses a CSV file named 'data.csv'. Load a CSV file 'data.csv' with columns 'Major Area', 'Regions', 'Country', and 'Overall score'. Treat 'NA' in 'Regions' as a string, not a missing value. The code should plot a sunburst chart using plotly, structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' providing the values for each segment. In the sunburst chart, regions' colors reflect the average scores of their countries, and continents' colors are averages of their regions. The color legend aligns shades with score ranges for easy comparison of hierarchical levels. The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'. \nFinally, the chart should be saved as an image file with dimensions of 1000x1000 pixels.",
        "expert_instruction": "My dataset is a CSV file named 'data.csv' containing the following columns:\n- Major Area: A string column representing the highest level of the hierarchy, such as continents or geopolitical regions.\n- Regions: A string column representing subdivisions within the Major Area. If a particular area does not fall into a region, it should be marked as 'NA', which will be treated as a regular string, not as a missing value.\n- Country: A string column with the name or code for each country, nested within Regions.\n- Overall score: A numeric column representing some quantifiable score attributed to each country.\nWrite a python code to plot a sunburst chart. Ensure that 'NA' values are treated as regular strings and not as missing values. Then, using this DataFrame, create a sunburst chart with plotly. The chart should be structured based on the hierarchy of 'Major Area', 'Regions', and 'Country' columns in the DataFrame, with the 'Overall score' column providing the values for each segment of the chart. \nIn the sunburst chart, the score of a region is represented as the average of its constituent countries' scores, and similarly, the score of a continent is depicted as the average of its regions' scores. The color intensity for each segment within the chart corresponds to these average scores, with darker shades indicating higher scores and lighter shades for lower scores. The accompanying color legend maps these shades to specific score ranges, allowing for quick visual comparison across different hierarchical levels.\n The chart should be titled 'Global Food Security Index, 2020' with a subtitle 'Overall score 0-100, 100 = best environment'.\nOnce the chart is created, save it as an image file with dimensions of 1000x1000 pixels."
    },
    {
        "id": 94,
        "simple_instruction": "Create a chord diagram titled \"Mobile Phone Brand Switching Behavior\" using Holoviews with Bokeh backend. The data represents transitions between Samsung, Apple, Huawei, and Other Android.\ndata = pd.DataFrame({\n    'Samsung': [0.2925, 0.0195, 0.0117, 0.0663],\n    'Apple': [0.0224, 0.2816, 0.0032, 0.0128],\n    'Huawei': [0.0288, 0.0063, 0.0279, 0.027],\n    'Other Android': [0.042, 0.008, 0.01, 0.14]\n}, index=['Samsung', 'Apple', 'Huawei', 'Other Android'])\nConvert the matrix into a links list with source, target, and value, omitting zero values. Create a corresponding nodes list. Customize the diagram with a colormap, ensuring smooth transitions for self-links and clear labels. Display the share of each brand on the outer arc. Save the visual as an image and include the source label: \"Source: Deloitte Global Mobile Consumer Survey 2019, NL edition\"",
        "expert_instruction": "Create a chord diagram titled \"Mobile Phone Brand Switching Behavior\"  using Holoviews with Bokeh backend to visualize mobile brand switching probabilities between Samsung, Apple, Huawei, and Other Android. The data is a matrix representing transitions between Samsung, Apple, Huawei, and Other Android.\ndata = pd.DataFrame({\n    'Samsung': [0.2925, 0.0195, 0.0117, 0.0663],\n    'Apple': [0.0224, 0.2816, 0.0032, 0.0128],\n    'Huawei': [0.0288, 0.0063, 0.0279, 0.027],\n    'Other Android': [0.042, 0.008, 0.01, 0.14]\n}, index=['Samsung', 'Apple', 'Huawei', 'Other Android'])\nConvert this matrix into a links list with source, target, and value, omitting zero values. Create a corresponding nodes list, ensure all data types align. Customize the diagram's appearance with a colormap, ensuring smooth transitions for self-links and clear labels for all four categories. Display the share of each brand on the outer arc of the diagram. Finally, save the visual as an image and include the source label: \"Source: Deloitte Global Mobile Consumer Survey 2019, NL edition\"."
    },
    {
        "id": 96,
        "simple_instruction": "Create a combination chart from the \"data.csv\" dataset, which contains sales data for various mobile phone brands across different quarters of the year. The columns in the CSV file are [\"Quarter\", \"Samsung\", \"Nokia/Microsoft\", \"Apple\", \"LG\", \"ZTE\", \"Huawei\"]. For each brand, create a box plot to represent the distribution of their sales data. On each box plot, display all the individual sales data points for that brand. Additionally, calculate the average sales for each brand and draw a line connecting these average values across the box plots. Use a consistent color scheme for the same quarter across different years, varying the shades to distinguish between years. Include a legend to aid in understanding the color coding.",
        "expert_instruction": "Write a Python code to create a combination chart from a dataset named \"data.csv\". The dataset contains sales data for various mobile phone brands (\"Samsung,\" \"Nokia/Microsoft,\" \"Apple,\" \"LG,\" \"ZTE,\" and \"Huawei\") across different quarters of the year titled \"Quarter\" (e.g., \"Q1 '10\" for the first quarter of 2010). The column of the CSV file is [\"Quarter\", \"Samsung\", \"Nokia/Microsoft\", \"Apple\", \"LG\", \"ZTE\", \"Huawei\"]. The chart should include a box plot for each brand showing the distribution of sales data across quarters, with individual sales data points represented as dots. Also, calculate the overall mean sales for each brand and draw a line connecting these points. Ensure the line points align with their respective box plots. Use a consistent color scheme for the same quarter across different years, varying the shades to distinguish between years. Include a legend to aid in understanding the color coding. The box plot should be the underlying layer, and the data points should be on top, ensuring visibility."
    },
    {
        "id": 99,
        "simple_instruction": "Create a dark-themed violin plot to compare the total bill amounts by day of the week from a CSV file named \"data.csv\" which includes columns \"total_bill\", \"tip\", \"sex\", \"smoker\", \"day\", \"time\", and \"size\". The plot should clearly distinguish between smokers and non-smokers using a green color for smokers and grey for non-smokers. Include split violins to show this distinction, and make sure the plot represents data quartiles inside each violin.",
        "expert_instruction": "To create a violin plot using Seaborn, you should use data from a CSV file named \"data.csv\" which includes columns \"total_bill\", \"tip\", \"sex\", \"smoker\", \"day\", \"time\", and \"size\". The plot should focus on comparing the 'total_bill' amounts for different 'day' values (days of the week), with a distinction between 'smoker' and 'non-smoker' categories. Implement split violins for this purpose, and within each violin, use quartiles to represent the data distribution. The color scheme should be green for smokers and grey for non-smokers. Adopt a dark style theme for the plot."
    },
    {
        "id": 100,
        "simple_instruction": "Use a CSV file named \"data.csv\" to create a polar plot visualizing electron transitions in an atom, with the plot representing only the top half of a circle (semi-circle). The file has columns 'Series', 'Wavelength', 'l position', and 'p position'. The plot should represent only the top half of a circle (semi-circle) and include the following elements:\n1. The semi-circle's radius should be divided into 6 concentric regions representing energy levels 1 to 6, with clear black lines separating them. Label the left side of the semi-circle with '1n' to '6n' indicators for each energy level, and the right side with corresponding energy values '0 eV' to '13.22 eV'.\n2. Electron transitions, indicated by arrows within the semi-circle, should originate from the 'l position' (lower energy level) and point to the 'p position' (higher energy level). Arrows should be evenly spaced to avoid overlap, and each should be annotated with its transition wavelength at the head, just outside the semi-circle.\n3. Color-code the transitions based on their series, like 'Lyman Series', 'Balmer Series', 'Paschen Series', etc., and use a lighter shade of the same color to highlight the angular range of each series.\n4. Ensure the plot is clear and legible, with no overlapping text or arrows. Exclude radial gridlines, radial ticks, or angle labels.\n5. Title the plot \"Electron Transitions for an Atom\".\nThe data should be sorted by the 'Series' column, and all labels and annotations should be easily readable. The plot should effectively represent the data in a visually appealing and scientifically accurate manner.",
        "expert_instruction": "Use a CSV file named \"data.csv\" to create a polar plot visualizing electron transitions in an atom, with the plot representing only the top half of a circle (semi-circle). The file has columns 'Series', 'Wavelength', 'l position', and 'p position'. Sort the data by the 'Series' column and group the transitions accordingly. \n\n1. The plot should be a semi-circle representing the top half of a polar coordinate system. The radius of the semi-circle should be divided into 6 concentric regions, each representing an energy level, numbered from 1 to 6 starting from the center. Black lines should separate these regions to clearly distinguish the different energy levels.\n2. Label the left side of the semi-circle with energy level indicators '1n' through '6n', with '1n' closest to the center and '6n' at the outer edge. These labels should be aligned with the divisions between the regions.\n3. Label the right side of the semi-circle with the energy values '0 eV', '10.2 eV', '12.09 eV', '12.75 eV', '13.06 eV', '13.22 eV', with '0 eV' closest to the center and '13.22 eV' at the outer edge. These labels should be aligned with the corresponding energy level divisions.\n4. Electron transitions should be represented by arrows within the semi-circle. Each arrow should start at the radial position corresponding to the 'l position' (lower energy level) and point towards the radial position corresponding to the 'p position' (higher energy level). Arrows should be evenly distributed across the semi-circle, with equal angular spacing between them to ensure clarity and avoid overlap.\n5. Annotate each arrow with the wavelength of the transition, placing the label at the head of the arrow, just outside the semi-circle.\n6. Group the transitions by series, such as 'Lyman Series', 'Balmer Series', 'Paschen Series', etc., and use different colors for each series. Highlight each series by filling the angular range it occupies with a lighter shade of the same color.\n7. Ensure the plot is clear, with no overlapping text or arrows, and all labels and annotations are easily readable.\n8. The plot should not display any radial gridlines, radial ticks, or angle labels, and should have a title \"Electron Transitions for an Atom\" at the top."
    }
]