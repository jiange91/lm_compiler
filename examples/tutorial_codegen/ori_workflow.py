import dotenv
import cognify

# Load the environment variables
dotenv.load_dotenv()

from langchain_openai import ChatOpenAI
from typing import List

from langchain_core.prompts import ChatPromptTemplate

model = ChatOpenAI(model="gpt-4o-mini", temperature=0)

#================= Complete Code Agent =================
cc_system_prompt = """
Given an incomplete python function, complete the function body according to the provided docstring. Only the function body should be returned, and wrapped in <result> and </result> tags.
"""
    
cc_agent_prompt = ChatPromptTemplate.from_messages(
    [
        ("system", cc_system_prompt),
        ("human", "incomplete function:\n\n{incomplete_function}"),
    ]
)

cc_agent = cc_agent_prompt | model

#================= Refine Code Agent =================
rc_system_prompt = """
Given an incomplete python function and the function body generated by another agent, improve the code completion. Only the function body should be returned, and wrapped in <result> and </result> tags.
"""

rc_agent_prompt = ChatPromptTemplate.from_messages(
    [
        ("system", rc_system_prompt),
        ("human", "incomplete function:\n\n{incomplete_function}\n\ncompleted code:\n\n{completed_code}"),
    ]
)

rc_agent = rc_agent_prompt | model

#================= CodeGen Workflow =================

def cc_agent_routine(state):
    func = state["incomplete_function"]
    return {"completed_code": cc_agent.invoke({"incomplete_function": func}).content}

def rc_agent_routine(state):
    func = state["incomplete_function"]
    completed_code = state["completed_code"]
    return {"finalized_code": rc_agent.invoke({"incomplete_function": func, "completed_code": completed_code}).content}

from langgraph.graph import END, START, StateGraph, MessagesState
from typing import Dict, TypedDict

class State(TypedDict):
    incomplete_function: str
    completed_code: str
    finalized_code: str
    
workflow = StateGraph(State)
workflow.add_node("complete_code", cc_agent_routine)
workflow.add_node("refine_code", rc_agent_routine)
workflow.add_edge(START, "complete_code")
workflow.add_edge("complete_code", "refine_code")
workflow.add_edge("refine_code", END)

app = workflow.compile()

@cognify.register_workflow
def do_code_gen(input):
    state = app.invoke(
        {"incomplete_function": input}
    )
    return {"pred": state["finalized_code"]}



# if __name__ == '__main__':
#     train, val, dev = load_data()
#     input, problem = train[0]
    
#     result = app.invoke({"incomplete_function": input})
    
#     print(result['incomplete_function'])
#     print(result['finalized_code'])
    
#     score = score_fn(problem, result['finalized_code'])
    
#     print(f"Score: {score}")